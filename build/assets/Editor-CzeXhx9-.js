var j5 = Object.defineProperty;
var U5 = (e, t, n) => (t in e ? j5(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (e[t] = n));
var Vt = (e, t, n) => U5(e, typeof t != "symbol" ? t + "" : t, n);
import {
  r as E,
  v as C,
  j as O,
  a as Ni,
  $ as _1,
  R as W5,
  b as Td,
  P as q,
  ae as Gh,
  af as K5,
  ag as Ad,
  ah as J5,
  g as G5,
} from "./react-CV3HRGEF.js";
import { a4 as $o } from "./mermaid-BthQq5t5.js";
import { g as w1, c as Zh } from "./common-5dK6VpSw.js";
import {
  c as Z5,
  o as q5,
  s as Y5,
  f as X5,
  a as Q5,
  h as eC,
  b as qh,
  l as tC,
  d as nC,
  e as Id,
} from "./excalidraw-Dj3WmK_c.js";
import {
  s as E1,
  E as kn,
  H as rC,
  t as ie,
  l as Nd,
  h as iC,
  a as oC,
  b as sC,
  f as lC,
  d as aC,
  c as uC,
  e as jr,
  i as cC,
  g as dC,
  j as fC,
  k as hC,
  r as pC,
  m as gC,
  n as mC,
  o as xC,
  p as k1,
  q as vC,
  u as bC,
  v as yC,
  w as CC,
  x as _C,
  y as wC,
  z as EC,
  A as kC,
  B as SC,
  C as TC,
  D as AC,
  M as IC,
} from "./codemirror-CUbsYH-3.js";
import { bt as NC, a9 as Yh } from "./index-CIdel1P5.js";
var LC = Object.defineProperty,
  MC = (e, t, n) => (t in e ? LC(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (e[t] = n)),
  ar = (e, t, n) => MC(e, typeof t != "symbol" ? t + "" : t, n);
let OC = class S1 {
    constructor(t = new Map()) {
      this.map = t;
    }
    clone() {
      return new S1(new Map(this.map));
    }
    increment(t) {
      const n = this.map.get(t) ?? 0;
      this.map.set(t, n + 1);
    }
    decrement(t, n) {
      let r = this.map.get(t);
      r !== void 0 && ((r -= 1), this.map.set(t, r), r === 0 && n());
    }
  },
  Ns = class {
    constructor() {
      ar(this, "map", new Map());
    }
    getOrCreate(t) {
      let n = this.map.get(t);
      return n === void 0 && ((n = new Set()), this.map.set(t, n)), n;
    }
    get(t) {
      return this.map.get(t);
    }
    use(t, n) {
      const r = this.get(t);
      r !== void 0 && n(r);
    }
    delete(t) {
      return this.map.delete(t);
    }
  };
function Rr(e, t) {
  return t(e), e;
}
function Ld() {}
const T1 = "cell";
function Xh(e, t) {
  return e === t;
}
const ql = new Map();
let FC = class {
  constructor(t = {}) {
    ar(this, "subscriptions", new Ns()),
      ar(this, "singletonSubscriptions", new Map()),
      ar(this, "graph", new Ns()),
      ar(this, "state", new Map()),
      ar(this, "distinctNodes", new Map()),
      ar(this, "executionMaps", new Map()),
      ar(this, "definitionRegistry", new Set());
    for (const n of Object.getOwnPropertySymbols(t)) this.state.set(n, t[n]);
  }
  cellInstance(t, n = !0, r = Symbol()) {
    return (
      this.state.has(r) || this.state.set(r, t),
      n !== !1 && !this.distinctNodes.has(r) && this.distinctNodes.set(r, n === !0 ? Xh : n),
      r
    );
  }
  signalInstance(t = !0, n = Symbol()) {
    return t !== !1 && this.distinctNodes.set(n, t === !0 ? Xh : t), n;
  }
  sub(t, n) {
    this.register(t);
    const r = this.subscriptions.getOrCreate(t);
    return r.add(n), () => r.delete(n);
  }
  singletonSub(t, n) {
    return (
      this.register(t),
      n === void 0 ? this.singletonSubscriptions.delete(t) : this.singletonSubscriptions.set(t, n),
      () => this.singletonSubscriptions.delete(t)
    );
  }
  resetSingletonSubs() {
    this.singletonSubscriptions.clear();
  }
  subMultiple(t, n) {
    const r = this.signalInstance();
    return (
      this.connect({
        map:
          (i) =>
          (...o) => {
            i(o);
          },
        sink: r,
        sources: t,
      }),
      this.sub(r, n)
    );
  }
  pubIn(t) {
    var n;
    const r = Reflect.ownKeys(t),
      i = this.getExecutionMap(r),
      o = i.refCount.clone(),
      s = i.participatingNodes.slice(),
      l = new Map(this.state),
      a = (u) => {
        this.graph.use(u, (c) => {
          for (const { sources: d, sink: f } of c)
            d.has(u) &&
              o.decrement(f, () => {
                s.splice(s.indexOf(f), 1), a(f);
              });
        });
      };
    for (;;) {
      const u = s.shift();
      if (u === void 0) break;
      const c = u;
      let d = !1;
      const f = (h) => {
        const p = this.distinctNodes.get(c);
        if (p != null && p(l.get(c), h)) {
          d = !1;
          return;
        }
        (d = !0), l.set(c, h), this.state.has(c) && this.state.set(c, h);
      };
      if (
        (Object.prototype.hasOwnProperty.call(t, c)
          ? f(t[c])
          : i.projections.use(c, (h) => {
              for (const p of h) {
                const g = [...Array.from(p.sources), ...Array.from(p.pulls)].map((x) => l.get(x));
                p.map(f)(...g);
              }
            }),
        d)
      ) {
        const h = l.get(c);
        this.inContext(() => {
          this.subscriptions.use(c, (p) => {
            for (const g of p) g(h);
          });
        }),
          (n = this.singletonSubscriptions.get(c)) == null || n(h);
      } else a(c);
    }
  }
  connect({ sources: t, pulls: n = [], map: r, sink: i }) {
    const o = { map: r, pulls: new Set(n), sink: this.register(i), sources: new Set(t) };
    for (const s of [...t, ...n]) this.register(s), this.graph.getOrCreate(s).add(o);
    this.executionMaps.clear();
  }
  pub(t, n) {
    this.pubIn({ [t]: n });
  }
  pipe(t, ...n) {
    return this.combineOperators(...n)(t);
  }
  transformer(...t) {
    return (n) => Rr(this.signalInstance(), (r) => (this.link(this.pipe(r, ...t), n), r));
  }
  link(t, n) {
    this.connect({
      map: (r) => (i) => {
        r(i);
      },
      sink: n,
      sources: [t],
    });
  }
  combine(...t) {
    return Rr(this.signalInstance(), (n) => {
      this.connect({
        map:
          (r) =>
          (...i) => {
            r(i);
          },
        sink: n,
        sources: t,
      });
    });
  }
  combineCells(...t) {
    return Rr(
      this.cellInstance(
        t.map((n) => this.getValue(n)),
        !0,
      ),
      (n) => {
        this.connect({
          map:
            (r) =>
            (...i) => {
              r(i);
            },
          sink: n,
          sources: t,
        });
      },
    );
  }
  getValue(t) {
    return this.register(t), this.state.get(t);
  }
  getValues(t) {
    return t.map((n) => this.getValue(n));
  }
  register(t) {
    const n = ql.get(t);
    return n === void 0 || this.definitionRegistry.has(t)
      ? t
      : (this.definitionRegistry.add(t),
        Rr(n.type === T1 ? this.cellInstance(n.initial, n.distinct, t) : this.signalInstance(n.distinct, t), (r) => {
          this.inContext(() => {
            n.init(this, r);
          });
        }));
  }
  inContext(t) {
    return t();
  }
  changeWith(t, n, r) {
    this.connect({
      sources: [n],
      pulls: [t],
      sink: t,
      map: (i) => (o, s) => {
        i(r(s, o));
      },
    });
  }
  calculateExecutionMap(t) {
    const n = [],
      r = new Set(),
      i = new Ns(),
      o = new OC(),
      s = new Ns(),
      l = (a, u = 0) => {
        o.increment(a),
          !r.has(a) &&
            (this.register(a),
            i.use(a, (c) => {
              u = Math.max(...Array.from(c).map((d) => n.indexOf(d))) + 1;
            }),
            this.graph.use(a, (c) => {
              for (const d of c)
                d.sources.has(a) ? (s.getOrCreate(d.sink).add(d), l(d.sink, u)) : i.getOrCreate(d.sink).add(a);
            }),
            r.add(a),
            n.splice(u, 0, a));
      };
    return t.forEach(l), { participatingNodes: n, pendingPulls: i, projections: s, refCount: o };
  }
  getExecutionMap(t) {
    let n = t;
    if (t.length === 1) {
      n = t[0];
      const i = this.executionMaps.get(n);
      if (i !== void 0) return i;
    } else
      for (const [i, o] of this.executionMaps.entries())
        if (Array.isArray(i) && i.length === t.length && i.every((s) => t.includes(s))) return o;
    const r = this.calculateExecutionMap(t);
    return this.executionMaps.set(n, r), r;
  }
  combineOperators(...t) {
    return (n) => {
      for (const r of t) n = r(n, this);
      return n;
    };
  }
};
function ne(e, t = Ld, n = !0) {
  return Rr(Symbol(), (r) => {
    ql.set(r, { type: T1, distinct: n, initial: e, init: t });
  });
}
function Ze(e = Ld, t = !1) {
  return Rr(Symbol(), (n) => {
    ql.set(n, { type: "signal", distinct: t, init: e });
  });
}
function Nn(e = Ld) {
  return Rr(Symbol(), (t) => {
    ql.set(t, { type: "signal", distinct: !1, init: e });
  });
}
const A1 = E.createContext(null);
function Gi() {
  const e = E.useContext(A1);
  if (e === null) throw new Error("useRealm must be used within a RealmContextProvider");
  return e;
}
function qe(e) {
  const t = Gi();
  t.register(e);
  const n = E.useCallback((r) => t.sub(e, r), [t, e]);
  return E.useSyncExternalStore(
    n,
    () => t.getValue(e),
    () => t.getValue(e),
  );
}
function Le(...e) {
  const t = Gi();
  return qe(t.combineCells.apply(t, e));
}
function Ie(e) {
  const t = Gi();
  return (
    t.register(e),
    E.useCallback(
      (n) => {
        t.pub(e, n);
      },
      [t, e],
    )
  );
}
function tn(e) {
  return (t, n) => {
    const r = n.signalInstance();
    return (
      n.connect({
        map: (i) => (o) => {
          i(e(o));
        },
        sink: r,
        sources: [t],
      }),
      r
    );
  };
}
function Ve(...e) {
  return (t, n) => {
    const r = n.signalInstance();
    return (
      n.connect({
        map:
          (i) =>
          (...o) => {
            i(o);
          },
        pulls: e,
        sink: r,
        sources: [t],
      }),
      r
    );
  };
}
function I1(e) {
  return (t, n) => {
    const r = n.signalInstance();
    return (
      n.connect({
        map: (i) => () => {
          i(e);
        },
        sink: r,
        sources: [t],
      }),
      r
    );
  };
}
function is(e) {
  return (t, n) => {
    const r = n.signalInstance();
    return (
      n.connect({
        map: (i) => (o) => {
          e(o) && i(o);
        },
        sink: r,
        sources: [t],
      }),
      r
    );
  };
}
function N1(e, t) {
  return (n, r) => {
    const i = r.signalInstance();
    return (
      r.connect({
        map: (o) => (s) => {
          o((t = e(t, s)));
        },
        sink: i,
        sources: [n],
      }),
      i
    );
  };
}
function RC(e, t) {
  return t(e), e;
}
function Pr() {}
function vt(e) {
  return function (t) {
    return {
      init: (n) => {
        var r;
        return (r = e.init) == null ? void 0 : r.call(e, n, t);
      },
      postInit: (n) => {
        var r;
        return (r = e.postInit) == null ? void 0 : r.call(e, n, t);
      },
      update: (n) => {
        var r;
        return (r = e.update) == null ? void 0 : r.call(e, n, t);
      },
    };
  };
}
function PC({ children: e, plugins: t }) {
  const n = C.useMemo(
    () =>
      RC(new FC(), (r) => {
        var i, o;
        for (const s of t) (i = s.init) == null || i.call(s, r);
        for (const s of t) (o = s.postInit) == null || o.call(s, r);
      }),
    [],
  );
  return (
    C.useEffect(() => {
      var r;
      for (const i of t) (r = i.update) == null || r.call(i, n);
    }),
    C.createElement(A1.Provider, { value: n }, e)
  );
}
const al = E.createContext(null);
function L1(e, t) {
  let n = null;
  return (
    e != null && (n = e[1]),
    {
      getTheme: function () {
        return t ?? (n != null ? n.getTheme() : null);
      },
    }
  );
}
function bt() {
  const e = E.useContext(al);
  return (
    e == null &&
      (function (t, ...n) {
        const r = new URL("https://lexical.dev/docs/error"),
          i = new URLSearchParams();
        i.append("code", t);
        for (const o of n) i.append("v", o);
        throw (
          ((r.search = i.toString()),
          Error(
            `Minified Lexical error #${t}; visit ${r.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`,
          ))
        );
      })(8),
    e
  );
}
function K(e, ...t) {
  const n = new URL("https://lexical.dev/docs/error"),
    r = new URLSearchParams();
  r.append("code", e);
  for (const i of t) r.append("v", i);
  throw (
    ((n.search = r.toString()),
    Error(
      `Minified Lexical error #${e}; visit ${n.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`,
    ))
  );
}
const cn = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0,
  DC = cn && "documentMode" in document ? document.documentMode : null,
  bn = cn && /Mac|iPod|iPhone|iPad/.test(navigator.platform),
  Ur = cn && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent),
  ul = !(!cn || !("InputEvent" in window) || DC) && "getTargetRanges" in new window.InputEvent("input"),
  Bo = cn && /Version\/[\d.]+.*Safari/.test(navigator.userAgent),
  Li = cn && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream,
  $C = cn && /Android/.test(navigator.userAgent),
  M1 = cn && /^(?=.*Chrome).*/i.test(navigator.userAgent),
  Qh = cn && $C && M1,
  cl = cn && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !M1;
function dl(...e) {
  const t = [];
  for (const n of e) if (n && typeof n == "string") for (const [r] of n.matchAll(/\S+/g)) t.push(r);
  return t;
}
const BC = 1,
  HC = 3,
  VC = 9,
  zC = 11,
  Wr = 0,
  O1 = 1,
  Mi = 2,
  jC = 0,
  UC = 1,
  WC = 2,
  fl = 4,
  hl = 8,
  Md = 128,
  KC = 1792 | (112 | (3 | fl | hl) | Md),
  Od = 1,
  Fd = 2,
  Rd = 3,
  Pd = 4,
  Dd = 5,
  $d = 6,
  Yl = Bo || Li || cl ? " " : "​",
  qn = `

`,
  JC = Ur ? " " : Yl,
  F1 = "֑-߿יִ-﷽ﹰ-ﻼ",
  R1 = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿",
  GC = new RegExp("^[^" + R1 + "]*[" + F1 + "]"),
  ZC = new RegExp("^[^" + F1 + "]*[" + R1 + "]"),
  Et = {
    bold: 1,
    capitalize: 1024,
    code: 16,
    highlight: Md,
    italic: 2,
    lowercase: 256,
    strikethrough: fl,
    subscript: 32,
    superscript: 64,
    underline: hl,
    uppercase: 512,
  },
  qC = { directionless: 1, unmergeable: 2 },
  ep = { center: Fd, end: $d, justify: Pd, left: Od, right: Rd, start: Dd },
  YC = { [Fd]: "center", [$d]: "end", [Pd]: "justify", [Od]: "left", [Rd]: "right", [Dd]: "start" },
  XC = { normal: 0, segmented: 2, token: 1 },
  QC = { [jC]: "normal", [WC]: "segmented", [UC]: "token" },
  e_ = "$";
function P1(e, t, n, r, i, o) {
  let s = e.getFirstChild();
  for (; s !== null; ) {
    const l = s.__key;
    s.__parent === t && (P(s) && P1(s, l, n, r, i, o), n.has(l) || o.delete(l), i.push(l)), (s = s.getNextSibling());
  }
}
const t_ = 100;
let nc = !1,
  Bd = 0;
function n_(e) {
  Bd = e.timeStamp;
}
function eu(e, t, n) {
  const r = e.nodeName === "BR",
    i = t.__lexicalLineBreak;
  return (i && (e === i || (r && e.previousSibling === i))) || (r && pa(e, n) !== void 0);
}
function r_(e, t, n) {
  const r = ln(Jt(n));
  let i = null,
    o = null;
  r !== null && r.anchorNode === e && ((i = r.anchorOffset), (o = r.focusOffset));
  const s = e.nodeValue;
  s !== null && cf(t, s, i, o, !1);
}
function i_(e, t, n) {
  if (H(e)) {
    const r = e.anchor.getNode();
    if (r.is(n) && e.format !== r.getFormat()) return !1;
  }
  return tr(t) && n.isAttached();
}
function o_(e, t, n, r) {
  for (let i = e; i && !G_(i); i = hs(i)) {
    const o = pa(i, t);
    if (o !== void 0) {
      const s = Oe(o, n);
      if (s) return Te(s) || !We(i) ? void 0 : [i, s];
    } else if (i === r) return [r, C0(n)];
  }
}
function D1(e, t, n) {
  nc = !0;
  const r = performance.now() - Bd > t_;
  try {
    Rt(e, () => {
      const i =
          J() ||
          (function (f) {
            return f.getEditorState().read(() => {
              const h = J();
              return h !== null ? h.clone() : null;
            });
          })(e),
        o = new Map(),
        s = e.getRootElement(),
        l = e._editorState,
        a = e._blockCursorElement;
      let u = !1,
        c = "";
      for (let f = 0; f < t.length; f++) {
        const h = t[f],
          p = h.type,
          g = h.target,
          x = o_(g, e, l, s);
        if (!x) continue;
        const [b, m] = x;
        if (p === "characterData") r && Z(m) && tr(g) && i_(i, g, m) && r_(g, m, e);
        else if (p === "childList") {
          u = !0;
          const v = h.addedNodes;
          for (let w = 0; w < v.length; w++) {
            const y = v[w],
              S = b0(y),
              T = y.parentNode;
            if (T != null && y !== a && S === null && !eu(y, T, e)) {
              if (Ur) {
                const A = (We(y) ? y.innerText : null) || y.nodeValue;
                A && (c += A);
              }
              T.removeChild(y);
            }
          }
          const _ = h.removedNodes,
            k = _.length;
          if (k > 0) {
            let w = 0;
            for (let y = 0; y < k; y++) {
              const S = _[y];
              (eu(S, g, e) || a === S) && (g.appendChild(S), w++);
            }
            k !== w && o.set(b, m);
          }
        }
      }
      if (o.size > 0) for (const [f, h] of o) h.reconcileObservedMutation(f, e);
      const d = n.takeRecords();
      if (d.length > 0) {
        for (let f = 0; f < d.length; f++) {
          const h = d[f],
            p = h.addedNodes,
            g = h.target;
          for (let x = 0; x < p.length; x++) {
            const b = p[x],
              m = b.parentNode;
            m == null || b.nodeName !== "BR" || eu(b, g, e) || m.removeChild(b);
          }
        }
        n.takeRecords();
      }
      i !== null && (u && Ye(i), Ur && k0(e) && i.insertRawText(c));
    });
  } finally {
    nc = !1;
  }
}
function $1(e) {
  const t = e._observer;
  t !== null && D1(e, t.takeRecords(), t);
}
function B1(e) {
  (function (t) {
    Bd === 0 && Jt(t).addEventListener("textInput", n_, !0);
  })(e),
    (e._observer = new MutationObserver((t, n) => {
      D1(e, t, n);
    }));
}
let s_ = class H1 {
  constructor(t, n = new Map(), r = void 0, i = new Map(), o = void 0) {
    (this.node = t), (this.sharedConfigMap = n), (this.unknownState = r), (this.knownState = i);
    const s =
      o !== void 0
        ? o
        : (function (l, a, u) {
            let c = u.size;
            if (a)
              for (const d in a) {
                const f = l.get(d);
                (f && u.has(f)) || c++;
              }
            return c;
          })(n, r, i);
    this.size = s;
  }
  getValue(t) {
    const n = this.knownState.get(t);
    if (n !== void 0) return n;
    this.sharedConfigMap.set(t.key, t);
    let r = t.defaultValue;
    if (this.unknownState && t.key in this.unknownState) {
      const i = this.unknownState[t.key];
      i !== void 0 && (r = t.parse(i)), this.updateFromKnown(t, r);
    }
    return r;
  }
  getInternalState() {
    return [this.unknownState, this.knownState];
  }
  toJSON() {
    const t = { ...this.unknownState };
    for (const [n, r] of this.knownState) n.isEqual(r, n.defaultValue) ? delete t[n.key] : (t[n.key] = n.unparse(r));
    return Ls(t) ? { [e_]: t } : {};
  }
  getWritable(t) {
    if (this.node === t) return this;
    const n = new Map(this.knownState),
      r = Ls((i = this.unknownState)) && { ...i };
    var i;
    if (r) for (const o of n.keys()) delete r[o.key];
    return new H1(t, this.sharedConfigMap, Ls(r), n, this.size);
  }
  updateFromKnown(t, n) {
    const r = t.key;
    this.sharedConfigMap.set(r, t);
    const { knownState: i, unknownState: o } = this;
    i.has(t) || (o && r in o) || this.size++, i.set(t, n);
  }
  updateFromUnknown(t, n) {
    const r = this.sharedConfigMap.get(t);
    r
      ? this.updateFromKnown(r, r.parse(n))
      : ((this.unknownState = this.unknownState || {}),
        t in this.unknownState || this.size++,
        (this.unknownState[t] = n));
  }
  updateFromJSON(t) {
    const { knownState: n } = this;
    for (const r of n.keys()) n.set(r, r.defaultValue);
    if (((this.size = n.size), (this.unknownState = {}), t))
      for (const [r, i] of Object.entries(t)) this.updateFromUnknown(r, i);
    this.unknownState = Ls(this.unknownState);
  }
};
function Ls(e) {
  if (e) for (const t in e) return e;
}
function l_(e) {
  const t = e.getWritable(),
    n = t.__state ? t.__state.getWritable(t) : new s_(t);
  return (t.__state = n), n;
}
function tp(e, t) {
  const n = e.__mode,
    r = e.__format,
    i = e.__style,
    o = t.__mode,
    s = t.__format,
    l = t.__style,
    a = e.__state,
    u = t.__state;
  return (
    (n === null || n === o) &&
    (r === null || r === s) &&
    (i === null || i === l) &&
    (e.__state === null ||
      a === u ||
      (function (c, d) {
        if (c === d) return !0;
        if (c && d && c.size !== d.size) return !1;
        const f = new Set(),
          h = (g, x) => {
            for (const [b, m] of g.knownState) {
              if (f.has(b.key)) continue;
              f.add(b.key);
              const v = x ? x.getValue(b) : b.defaultValue;
              if (v !== m && !b.isEqual(v, m)) return !0;
            }
            return !1;
          },
          p = (g, x) => {
            const { unknownState: b } = g,
              m = x ? x.unknownState : void 0;
            if (b) {
              for (const [v, _] of Object.entries(b)) if (!f.has(v) && (f.add(v), _ !== (m ? m[v] : void 0))) return !0;
            }
            return !1;
          };
        return !((c && h(c, d)) || (d && h(d, c)) || (c && p(c, d)) || (d && p(d, c)));
      })(a, u))
  );
}
function np(e, t) {
  const n = e.mergeWithSibling(t),
    r = Ge()._normalizedNodes;
  return r.add(e.__key), r.add(t.__key), n;
}
function rp(e) {
  let t,
    n,
    r = e;
  if (r.__text !== "" || !r.isSimpleText() || r.isUnmergeable()) {
    for (; (t = r.getPreviousSibling()) !== null && Z(t) && t.isSimpleText() && !t.isUnmergeable(); ) {
      if (t.__text !== "") {
        if (tp(t, r)) {
          r = np(t, r);
          break;
        }
        break;
      }
      t.remove();
    }
    for (; (n = r.getNextSibling()) !== null && Z(n) && n.isSimpleText() && !n.isUnmergeable(); ) {
      if (n.__text !== "") {
        if (tp(r, n)) {
          r = np(r, n);
          break;
        }
        break;
      }
      n.remove();
    }
  } else r.remove();
}
function Kr(e) {
  return ip(e.anchor), ip(e.focus), e;
}
function ip(e) {
  for (; e.type === "element"; ) {
    const t = e.getNode(),
      n = e.offset;
    let r, i;
    if (
      (n === t.getChildrenSize() ? ((r = t.getChildAtIndex(n - 1)), (i = !0)) : ((r = t.getChildAtIndex(n)), (i = !1)),
      Z(r))
    ) {
      e.set(r.__key, i ? r.getTextContentSize() : 0, "text", !0);
      break;
    }
    if (!P(r)) break;
    e.set(r.__key, i ? r.getChildrenSize() : 0, "element", !0);
  }
}
let gr,
  Tt,
  Ho,
  Xl,
  rc,
  ic,
  Jr,
  nn,
  oc,
  Vo,
  it = "",
  St = "",
  xn = null,
  vn = "",
  zn = "",
  V1 = !1,
  zo = !1,
  qs = null;
function pl(e, t) {
  const n = Jr.get(e);
  if (t !== null) {
    const r = ac(e);
    r.parentNode === t && t.removeChild(r);
  }
  if ((nn.has(e) || Tt._keyToDOMMap.delete(e), P(n))) {
    const r = ml(n, Jr);
    sc(r, 0, r.length - 1, null);
  }
  n !== void 0 && df(Vo, Ho, Xl, n, "destroyed");
}
function sc(e, t, n, r) {
  let i = t;
  for (; i <= n; ++i) {
    const o = e[i];
    o !== void 0 && pl(o, r);
  }
}
function Nr(e, t) {
  e.setProperty("text-align", t);
}
const a_ = "40px";
function z1(e, t) {
  const n = gr.theme.indent;
  if (typeof n == "string") {
    const i = e.classList.contains(n);
    t > 0 && !i ? e.classList.add(n) : t < 1 && i && e.classList.remove(n);
  }
  const r = getComputedStyle(e).getPropertyValue("--lexical-indent-base-value") || a_;
  e.style.setProperty("padding-inline-start", t === 0 ? "" : `calc(${t} * ${r})`);
}
function j1(e, t) {
  const n = e.style;
  t === 0
    ? Nr(n, "")
    : t === Od
      ? Nr(n, "left")
      : t === Fd
        ? Nr(n, "center")
        : t === Rd
          ? Nr(n, "right")
          : t === Pd
            ? Nr(n, "justify")
            : t === Dd
              ? Nr(n, "start")
              : t === $d && Nr(n, "end");
}
function gl(e, t) {
  const n = nn.get(e);
  n === void 0 && K(60);
  const r = n.createDOM(gr, Tt);
  if (
    ((function (i, o, s) {
      const l = s._keyToDOMMap;
      (function (a, u, c) {
        const d = `__lexicalKey_${u._key}`;
        a[d] = c;
      })(o, s, i),
        l.set(i, o);
    })(e, r, Tt),
    Z(n) ? r.setAttribute("data-lexical-text", "true") : Te(n) && r.setAttribute("data-lexical-decorator", "true"),
    P(n))
  ) {
    const i = n.__indent,
      o = n.__size;
    if ((i !== 0 && z1(r, i), o !== 0)) {
      const l = o - 1;
      (function (a, u, c, d) {
        const f = St;
        (St = ""), lc(a, c, 0, u, c.getDOMSlot(d)), W1(c, d), (St = f);
      })(ml(n, nn), l, n, r);
    }
    const s = n.__format;
    s !== 0 && j1(r, s), n.isInline() || U1(null, n, r), ga(n) && ((it += qn), (zn += qn));
  } else {
    const i = n.getTextContent();
    if (Te(n)) {
      const o = n.decorate(Tt, gr);
      o !== null && K1(e, o), (r.contentEditable = "false");
    } else Z(n) && (n.isDirectionless() || (St += i));
    (it += i), (zn += i);
  }
  return t !== null && t.insertChild(r), df(Vo, Ho, Xl, n, "created"), r;
}
function lc(e, t, n, r, i) {
  const o = it;
  it = "";
  let s = n;
  for (; s <= r; ++s) {
    gl(e[s], i);
    const l = nn.get(e[s]);
    l !== null && Z(l) && (xn === null && (xn = l.getFormat()), vn === "" && (vn = l.getStyle()));
  }
  ga(t) && (it += qn), (i.element.__lexicalTextContent = it), (it = o + it);
}
function op(e, t) {
  if (e) {
    const n = e.__last;
    if (n) {
      const r = t.get(n);
      if (r) return rn(r) ? "line-break" : Te(r) && r.isInline() ? "decorator" : null;
    }
    return "empty";
  }
  return null;
}
function U1(e, t, n) {
  const r = op(e, Jr),
    i = op(t, nn);
  r !== i && t.getDOMSlot(n).setManagedLineBreak(i);
}
function W1(e, t) {
  const n = t.__lexicalDirTextContent || "",
    r = t.__lexicalDir || "";
  if (n !== St || r !== qs) {
    const i = St === "",
      o = i
        ? qs
        : (function (s) {
            return GC.test(s) ? "rtl" : ZC.test(s) ? "ltr" : null;
          })(St);
    if (o !== r) {
      const s = t.classList,
        l = gr.theme;
      let a = r !== null ? l[r] : void 0,
        u = o !== null ? l[o] : void 0;
      if (a !== void 0) {
        if (typeof a == "string") {
          const c = dl(a);
          a = l[r] = c;
        }
        s.remove(...a);
      }
      if (o === null || (i && o === "ltr")) t.removeAttribute("dir");
      else {
        if (u !== void 0) {
          if (typeof u == "string") {
            const c = dl(u);
            u = l[o] = c;
          }
          u !== void 0 && s.add(...u);
        }
        t.dir = o;
      }
      zo || (e.getWritable().__dir = o);
    }
    (qs = o), (t.__lexicalDirTextContent = St), (t.__lexicalDir = o);
  }
}
function u_(e, t, n) {
  const r = St;
  var i;
  (St = ""),
    (xn = null),
    (vn = ""),
    (function (o, s, l) {
      const a = it,
        u = o.__size,
        c = s.__size;
      it = "";
      const d = l.element;
      if (u === 1 && c === 1) {
        const f = o.__first,
          h = s.__first;
        if (f === h) bo(f, d);
        else {
          const g = ac(f),
            x = gl(h, null);
          try {
            d.replaceChild(x, g);
          } catch (b) {
            if (typeof b == "object" && b != null) {
              const m = `${b.toString()} Parent: ${d.tagName}, new child: {tag: ${
                x.tagName
              } key: ${h}}, old child: {tag: ${g.tagName}, key: ${f}}.`;
              throw new Error(m);
            }
            throw b;
          }
          pl(f, null);
        }
        const p = nn.get(h);
        Z(p) && (xn === null && (xn = p.getFormat()), vn === "" && (vn = p.getStyle()));
      } else {
        const f = ml(o, Jr),
          h = ml(s, nn);
        if ((f.length !== u && K(227), h.length !== c && K(228), u === 0)) c !== 0 && lc(h, s, 0, c - 1, l);
        else if (c === 0) {
          if (u !== 0) {
            const p = l.after == null && l.before == null && l.element.__lexicalLineBreak == null;
            sc(f, 0, u - 1, p ? null : d), p && (d.textContent = "");
          }
        } else
          (function (p, g, x, b, m, v) {
            const _ = b - 1,
              k = m - 1;
            let w,
              y,
              S = v.getFirstChild(),
              T = 0,
              A = 0;
            for (; T <= _ && A <= k; ) {
              const V = g[T],
                B = x[A];
              if (V === B) (S = tu(bo(B, v.element))), T++, A++;
              else {
                w === void 0 && (w = new Set(g)), y === void 0 && (y = new Set(x));
                const G = y.has(V),
                  U = w.has(B);
                if (G)
                  if (U) {
                    const X = Ri(Tt, B);
                    X === S ? (S = tu(bo(B, v.element))) : (v.withBefore(S).insertChild(X), bo(B, v.element)), T++, A++;
                  } else gl(B, v.withBefore(S)), A++;
                else (S = tu(ac(V))), pl(V, v.element), T++;
              }
              const N = nn.get(B);
              N !== null && Z(N) && (xn === null && (xn = N.getFormat()), vn === "" && (vn = N.getStyle()));
            }
            const F = T > _,
              R = A > k;
            if (F && !R) {
              const V = x[k + 1],
                B = V === void 0 ? null : Tt.getElementByKey(V);
              lc(x, p, A, k, v.withBefore(B));
            } else R && !F && sc(g, T, _, v.element);
          })(s, f, h, u, c, l);
      }
      ga(s) && (it += qn), (d.__lexicalTextContent = it), (it = a + it);
    })(e, t, t.getDOMSlot(n)),
    W1(t, n),
    (i = t),
    xn == null || xn === i.__textFormat || zo || i.setTextFormat(xn),
    (function (o) {
      vn === "" || vn === o.__textStyle || zo || o.setTextStyle(vn);
    })(t),
    (St = r);
}
function ml(e, t) {
  const n = [];
  let r = e.__first;
  for (; r !== null; ) {
    const i = t.get(r);
    i === void 0 && K(101), n.push(r), (r = i.__next);
  }
  return n;
}
function bo(e, t) {
  const n = Jr.get(e);
  let r = nn.get(e);
  (n !== void 0 && r !== void 0) || K(61);
  const i = V1 || ic.has(e) || rc.has(e),
    o = Ri(Tt, e);
  if (n === r && !i) {
    if (P(n)) {
      const s = o.__lexicalTextContent;
      s !== void 0 && ((it += s), (zn += s));
      const l = o.__lexicalDirTextContent;
      l !== void 0 && (St += l);
    } else {
      const s = n.getTextContent();
      Z(n) && !n.isDirectionless() && (St += s), (zn += s), (it += s);
    }
    return o;
  }
  if ((n !== r && i && df(Vo, Ho, Xl, r, "updated"), r.updateDOM(n, o, gr))) {
    const s = gl(e, null);
    return t === null && K(62), t.replaceChild(s, o), pl(e, null), s;
  }
  if (P(n) && P(r)) {
    const s = r.__indent;
    s !== n.__indent && z1(o, s);
    const l = r.__format;
    l !== n.__format && j1(o, l),
      i && (u_(n, r, o), ut(r) || r.isInline() || U1(n, r, o)),
      ga(r) && ((it += qn), (zn += qn));
  } else {
    const s = r.getTextContent();
    if (Te(r)) {
      const l = r.decorate(Tt, gr);
      l !== null && K1(e, l);
    } else Z(r) && !r.isDirectionless() && (St += s);
    (it += s), (zn += s);
  }
  if (!zo && ut(r) && r.__cachedText !== zn) {
    const s = r.getWritable();
    (s.__cachedText = zn), (r = s);
  }
  return o;
}
function K1(e, t) {
  let n = Tt._pendingDecorators;
  const r = Tt._decorators;
  if (n === null) {
    if (r[e] === t) return;
    n = y0(Tt);
  }
  n[e] = t;
}
function tu(e) {
  let t = e.nextSibling;
  return t !== null && t === Tt._blockCursorElement && (t = t.nextSibling), t;
}
function c_(e, t, n, r, i, o) {
  (it = ""),
    (zn = ""),
    (St = ""),
    (V1 = r === Mi),
    (qs = null),
    (Tt = n),
    (gr = n._config),
    (Ho = n._nodes),
    (Xl = Tt._listeners.mutation),
    (rc = i),
    (ic = o),
    (Jr = e._nodeMap),
    (nn = t._nodeMap),
    (zo = t._readOnly),
    (oc = new Map(n._keyToDOMMap));
  const s = new Map();
  return (
    (Vo = s),
    bo("root", null),
    (Tt = void 0),
    (Ho = void 0),
    (rc = void 0),
    (ic = void 0),
    (Jr = void 0),
    (nn = void 0),
    (gr = void 0),
    (oc = void 0),
    (Vo = void 0),
    s
  );
}
function ac(e) {
  const t = oc.get(e);
  return t === void 0 && K(75, e), t;
}
function ae(e) {
  return { type: e };
}
const os = ae("SELECTION_CHANGE_COMMAND"),
  d_ = ae("SELECTION_INSERT_CLIPBOARD_NODES_COMMAND"),
  Ql = ae("CLICK_COMMAND"),
  Dr = ae("DELETE_CHARACTER_COMMAND"),
  ki = ae("INSERT_LINE_BREAK_COMMAND"),
  jo = ae("INSERT_PARAGRAPH_COMMAND"),
  Si = ae("CONTROLLED_TEXT_INSERTION_COMMAND"),
  ss = ae("PASTE_COMMAND"),
  uc = ae("REMOVE_TEXT_COMMAND"),
  Uo = ae("DELETE_WORD_COMMAND"),
  Wo = ae("DELETE_LINE_COMMAND"),
  Un = ae("FORMAT_TEXT_COMMAND"),
  ea = ae("UNDO_COMMAND"),
  ta = ae("REDO_COMMAND"),
  Hd = ae("KEYDOWN_COMMAND"),
  J1 = ae("KEY_ARROW_RIGHT_COMMAND"),
  f_ = ae("MOVE_TO_END"),
  Vd = ae("KEY_ARROW_LEFT_COMMAND"),
  h_ = ae("MOVE_TO_START"),
  zd = ae("KEY_ARROW_UP_COMMAND"),
  jd = ae("KEY_ARROW_DOWN_COMMAND"),
  Oi = ae("KEY_ENTER_COMMAND"),
  Ud = ae("KEY_SPACE_COMMAND"),
  na = ae("KEY_BACKSPACE_COMMAND"),
  ls = ae("KEY_ESCAPE_COMMAND"),
  Wd = ae("KEY_DELETE_COMMAND"),
  ra = ae("KEY_TAB_COMMAND"),
  G1 = ae("INSERT_TAB_COMMAND"),
  xl = ae("INDENT_CONTENT_COMMAND"),
  cc = ae("OUTDENT_CONTENT_COMMAND"),
  Kd = ae("DROP_COMMAND"),
  p_ = ae("FORMAT_ELEMENT_COMMAND"),
  ia = ae("DRAGSTART_COMMAND"),
  Jd = ae("DRAGOVER_COMMAND"),
  g_ = ae("DRAGEND_COMMAND"),
  oa = ae("COPY_COMMAND"),
  Gd = ae("CUT_COMMAND"),
  dc = ae("SELECT_ALL_COMMAND"),
  m_ = ae("CLEAR_EDITOR_COMMAND"),
  x_ = ae("CLEAR_HISTORY_COMMAND"),
  yo = ae("CAN_REDO_COMMAND"),
  Co = ae("CAN_UNDO_COMMAND"),
  sa = ae("FOCUS_COMMAND"),
  la = ae("BLUR_COMMAND"),
  Z1 = ae("KEY_MODIFIER_COMMAND"),
  Rn = Object.freeze({}),
  fc = 30,
  hc = [
    [
      "keydown",
      function (e, t) {
        if (((So = e.timeStamp), (q1 = e.key), !t.isComposing() && !re(t, Hd, e) && e.key != null)) {
          if (nu && Op(e))
            return (
              Rt(t, () => {
                Ms(t, ru);
              }),
              (nu = !1),
              void (ru = "")
            );
          if (
            (function (n) {
              return Ne(n, "ArrowRight", { shiftKey: "any" });
            })(e)
          )
            re(t, J1, e);
          else if (
            (function (n) {
              return Ne(n, "ArrowRight", Bn);
            })(e)
          )
            re(t, f_, e);
          else if (
            (function (n) {
              return Ne(n, "ArrowLeft", { shiftKey: "any" });
            })(e)
          )
            re(t, Vd, e);
          else if (
            (function (n) {
              return Ne(n, "ArrowLeft", Bn);
            })(e)
          )
            re(t, h_, e);
          else if (
            (function (n) {
              return Ne(n, "ArrowUp", { altKey: "any", shiftKey: "any" });
            })(e)
          )
            re(t, zd, e);
          else if (
            (function (n) {
              return Ne(n, "ArrowDown", { altKey: "any", shiftKey: "any" });
            })(e)
          )
            re(t, jd, e);
          else if (
            (function (n) {
              return Ne(n, "Enter", { altKey: "any", ctrlKey: "any", metaKey: "any", shiftKey: !0 });
            })(e)
          )
            (To = !0), re(t, Oi, e);
          else if (
            (function (n) {
              return n.key === " ";
            })(e)
          )
            re(t, Ud, e);
          else if (
            (function (n) {
              return bn && Ne(n, "o", { ctrlKey: !0 });
            })(e)
          )
            e.preventDefault(), (To = !0), re(t, ki, !0);
          else if (
            (function (n) {
              return Ne(n, "Enter", { altKey: "any", ctrlKey: "any", metaKey: "any" });
            })(e)
          )
            (To = !1), re(t, Oi, e);
          else if (
            (function (n) {
              return Ne(n, "Backspace", { shiftKey: "any" }) || (bn && Ne(n, "h", { ctrlKey: !0 }));
            })(e)
          )
            Op(e) ? re(t, na, e) : (e.preventDefault(), re(t, Dr, !0));
          else if (
            (function (n) {
              return n.key === "Escape";
            })(e)
          )
            re(t, ls, e);
          else if (
            (function (n) {
              return Ne(n, "Delete", {}) || (bn && Ne(n, "d", { ctrlKey: !0 }));
            })(e)
          )
            (function (n) {
              return n.key === "Delete";
            })(e)
              ? re(t, Wd, e)
              : (e.preventDefault(), re(t, Dr, !1));
          else if (
            (function (n) {
              return Ne(n, "Backspace", Mp);
            })(e)
          )
            e.preventDefault(), re(t, Uo, !0);
          else if (
            (function (n) {
              return Ne(n, "Delete", Mp);
            })(e)
          )
            e.preventDefault(), re(t, Uo, !1);
          else if (
            (function (n) {
              return bn && Ne(n, "Backspace", { metaKey: !0 });
            })(e)
          )
            e.preventDefault(), re(t, Wo, !0);
          else if (
            (function (n) {
              return bn && (Ne(n, "Delete", { metaKey: !0 }) || Ne(n, "k", { ctrlKey: !0 }));
            })(e)
          )
            e.preventDefault(), re(t, Wo, !1);
          else if (
            (function (n) {
              return Ne(n, "b", Bn);
            })(e)
          )
            e.preventDefault(), re(t, Un, "bold");
          else if (
            (function (n) {
              return Ne(n, "u", Bn);
            })(e)
          )
            e.preventDefault(), re(t, Un, "underline");
          else if (
            (function (n) {
              return Ne(n, "i", Bn);
            })(e)
          )
            e.preventDefault(), re(t, Un, "italic");
          else if (
            (function (n) {
              return Ne(n, "Tab", { shiftKey: "any" });
            })(e)
          )
            re(t, ra, e);
          else if (
            (function (n) {
              return Ne(n, "z", Bn);
            })(e)
          )
            e.preventDefault(), re(t, ea, void 0);
          else if (
            (function (n) {
              return bn
                ? Ne(n, "z", { metaKey: !0, shiftKey: !0 })
                : Ne(n, "y", { ctrlKey: !0 }) || Ne(n, "z", { ctrlKey: !0, shiftKey: !0 });
            })(e)
          )
            e.preventDefault(), re(t, ta, void 0);
          else {
            const n = t._editorState._selection;
            n === null || H(n)
              ? Fp(e) && (e.preventDefault(), re(t, dc, e))
              : (function (r) {
                    return Ne(r, "c", Bn);
                  })(e)
                ? (e.preventDefault(), re(t, oa, e))
                : (function (r) {
                      return Ne(r, "x", Bn);
                    })(e)
                  ? (e.preventDefault(), re(t, Gd, e))
                  : Fp(e) && (e.preventDefault(), re(t, dc, e));
          }
          (function (n) {
            return n.ctrlKey || n.shiftKey || n.altKey || n.metaKey;
          })(e) && re(t, Z1, e);
        }
      },
    ],
    [
      "pointerdown",
      function (e, t) {
        const n = e.target,
          r = e.pointerType;
        Qi(n) &&
          r !== "touch" &&
          r !== "pen" &&
          e.button === 0 &&
          Rt(t, () => {
            Ip(n) || (gc = !0);
          });
      },
    ],
    [
      "compositionstart",
      function (e, t) {
        Rt(t, () => {
          const n = J();
          if (H(n) && !t.isComposing()) {
            const r = n.anchor,
              i = n.anchor.getNode();
            ft(r.key),
              (e.timeStamp < So + fc ||
                r.type === "element" ||
                !n.isCollapsed() ||
                i.getFormat() !== n.format ||
                (Z(i) && i.getStyle() !== n.style)) &&
                re(t, Si, JC);
          }
        });
      },
    ],
    [
      "compositionend",
      function (e, t) {
        Ur
          ? (ho = !0)
          : Li || (!Bo && !cl)
            ? Rt(t, () => {
                Ms(t, e.data);
              })
            : ((nu = !0), (ru = e.data));
      },
    ],
    [
      "input",
      function (e, t) {
        e.stopPropagation(),
          Rt(
            t,
            () => {
              if (We(e.target) && Ip(e.target)) return;
              const n = J(),
                r = e.data,
                i = t0(e);
              if (r != null && H(n) && Q1(n, i, r, e.timeStamp, !1)) {
                ho && (Ms(t, r), (ho = !1));
                const o = n.anchor.getNode(),
                  s = ln(Jt(t));
                if (s === null) return;
                const l = n.isBackward(),
                  a = l ? n.anchor.offset : n.focus.offset,
                  u = l ? n.focus.offset : n.anchor.offset;
                (ul &&
                  !n.isCollapsed() &&
                  Z(o) &&
                  s.anchorNode !== null &&
                  o.getTextContent().slice(0, a) + r + o.getTextContent().slice(a + u) === E0(s.anchorNode)) ||
                  re(t, Si, r);
                const c = r.length;
                Ur && c > 1 && e.inputType === "insertCompositionText" && !t.isComposing() && (n.anchor.offset -= c),
                  Bo || Li || cl || !t.isComposing() || ((So = 0), ft(null));
              } else uf(!1, t, r !== null ? r : void 0), ho && (Ms(t, r || void 0), (ho = !1));
              (function () {
                pt();
                const o = Ge();
                $1(o);
              })();
            },
            { event: e },
          ),
          (vi = null);
      },
    ],
    [
      "click",
      function (e, t) {
        Rt(t, () => {
          const n = J(),
            r = ln(Jt(t)),
            i = oi();
          if (r) {
            if (H(n)) {
              const o = n.anchor,
                s = o.getNode();
              if (
                o.type === "element" &&
                o.offset === 0 &&
                n.isCollapsed() &&
                !ut(s) &&
                Ce().getChildrenSize() === 1 &&
                s.getTopLevelElementOrThrow().isEmpty() &&
                i !== null &&
                n.is(i)
              )
                r.removeAllRanges(), (n.dirty = !0);
              else if (e.detail === 3 && !n.isCollapsed() && s !== n.focus.getNode()) {
                const l = (function (a, u) {
                  let c = a;
                  for (; c !== Ce() && c != null; ) {
                    if (u(c)) return c;
                    c = c.getParent();
                  }
                  return null;
                })(s, (a) => P(a) && !a.isInline());
                P(l) && l.select(0);
              }
            } else if (e.pointerType === "touch" || e.pointerType === "pen") {
              const o = r.anchorNode;
              (We(o) || tr(o)) && Ye(Yd(i, r, t, e));
            }
          }
          re(t, Ql, e);
        });
      },
    ],
    ["cut", Rn],
    ["copy", Rn],
    ["dragstart", Rn],
    ["dragover", Rn],
    ["dragend", Rn],
    ["paste", Rn],
    ["focus", Rn],
    ["blur", Rn],
    ["drop", Rn],
  ];
ul &&
  hc.push([
    "beforeinput",
    (e, t) =>
      (function (n, r) {
        const i = n.inputType,
          o = t0(n);
        i === "deleteCompositionText" ||
          (Ur && k0(r)) ||
          (i !== "insertCompositionText" &&
            Rt(r, () => {
              const s = J();
              if (i === "deleteContentBackward") {
                if (s === null) {
                  const h = oi();
                  if (!H(h)) return;
                  Ye(h.clone());
                }
                if (H(s)) {
                  const h = s.anchor.key === s.focus.key;
                  if (((l = n.timeStamp), q1 === "MediaLast" && l < So + fc && r.isComposing() && h)) {
                    if (
                      (ft(null),
                      (So = 0),
                      setTimeout(() => {
                        Rt(r, () => {
                          ft(null);
                        });
                      }, fc),
                      H(s))
                    ) {
                      const p = s.anchor.getNode();
                      p.markDirty(), Z(p) || K(142), e0(s, p);
                    }
                  } else {
                    ft(null), n.preventDefault();
                    const p = s.anchor.getNode(),
                      g = p.getTextContent(),
                      x = p.canInsertTextAfter(),
                      b = s.anchor.offset === 0 && s.focus.offset === g.length;
                    let m = Qh && h && !b && x;
                    if ((m && s.isCollapsed() && (m = !Te(vc(s.anchor, !0))), !m)) {
                      re(r, Dr, !0);
                      const v = J();
                      Qh && H(v) && v.isCollapsed() && ((Fr = v), setTimeout(() => (Fr = null)));
                    }
                  }
                  return;
                }
              }
              var l;
              if (!H(s)) return;
              const a = n.data;
              vi !== null && uf(!1, r, vi),
                (s.dirty && vi === null) ||
                  !s.isCollapsed() ||
                  ut(s.anchor.getNode()) ||
                  o === null ||
                  s.applyDOMRange(o),
                (vi = null);
              const u = s.anchor,
                c = s.focus,
                d = u.getNode(),
                f = c.getNode();
              if (i !== "insertText" && i !== "insertTranspose")
                switch ((n.preventDefault(), i)) {
                  case "insertFromYank":
                  case "insertFromDrop":
                  case "insertReplacementText":
                    re(r, Si, n);
                    break;
                  case "insertFromComposition":
                    ft(null), re(r, Si, n);
                    break;
                  case "insertLineBreak":
                    ft(null), re(r, ki, !1);
                    break;
                  case "insertParagraph":
                    ft(null), To && !Li ? ((To = !1), re(r, ki, !1)) : re(r, jo, void 0);
                    break;
                  case "insertFromPaste":
                  case "insertFromPasteAsQuotation":
                    re(r, ss, n);
                    break;
                  case "deleteByComposition":
                    (function (h, p) {
                      return h !== p || P(h) || P(p) || !$r(h) || !$r(p);
                    })(d, f) && re(r, uc, n);
                    break;
                  case "deleteByDrag":
                  case "deleteByCut":
                    re(r, uc, n);
                    break;
                  case "deleteContent":
                    re(r, Dr, !1);
                    break;
                  case "deleteWordBackward":
                    re(r, Uo, !0);
                    break;
                  case "deleteWordForward":
                    re(r, Uo, !1);
                    break;
                  case "deleteHardLineBackward":
                  case "deleteSoftLineBackward":
                    re(r, Wo, !0);
                    break;
                  case "deleteContentForward":
                  case "deleteHardLineForward":
                  case "deleteSoftLineForward":
                    re(r, Wo, !1);
                    break;
                  case "formatStrikeThrough":
                    re(r, Un, "strikethrough");
                    break;
                  case "formatBold":
                    re(r, Un, "bold");
                    break;
                  case "formatItalic":
                    re(r, Un, "italic");
                    break;
                  case "formatUnderline":
                    re(r, Un, "underline");
                    break;
                  case "historyUndo":
                    re(r, ea, void 0);
                    break;
                  case "historyRedo":
                    re(r, ta, void 0);
                }
              else {
                if (
                  a ===
                  `
`
                )
                  n.preventDefault(), re(r, ki, !1);
                else if (a === qn) n.preventDefault(), re(r, jo, void 0);
                else if (a == null && n.dataTransfer) {
                  const h = n.dataTransfer.getData("text/plain");
                  n.preventDefault(), s.insertRawText(h);
                } else a != null && Q1(s, o, a, n.timeStamp, !0) ? (n.preventDefault(), re(r, Si, a)) : (vi = a);
                Y1 = n.timeStamp;
              }
            }));
      })(e, t),
  ]);
let So = 0,
  q1 = null,
  Y1 = 0,
  vi = null;
const vl = new WeakMap();
let pc = !1,
  gc = !1,
  To = !1,
  ho = !1,
  nu = !1,
  ru = "",
  Fr = null,
  X1 = [0, "", 0, "root", 0];
function Q1(e, t, n, r, i) {
  const o = e.anchor,
    s = e.focus,
    l = o.getNode(),
    a = Ge(),
    u = ln(Jt(a)),
    c = u !== null ? u.anchorNode : null,
    d = o.key,
    f = a.getElementByKey(d),
    h = n.length;
  return (
    d !== s.key ||
    !Z(l) ||
    (((!i && (!ul || Y1 < r + 50)) || (l.isDirty() && h < 2) || _0(n)) && o.offset !== s.offset && !l.isComposing()) ||
    Vn(l) ||
    (l.isDirty() && h > 1) ||
    ((i || !ul) && f !== null && !l.isComposing() && c !== Fi(f)) ||
    (u !== null &&
      t !== null &&
      (!t.collapsed || t.startContainer !== u.anchorNode || t.startOffset !== u.anchorOffset)) ||
    l.getFormat() !== e.format ||
    l.getStyle() !== e.style ||
    (function (p, g) {
      if (g.isSegmented()) return !0;
      if (!p.isCollapsed()) return !1;
      const x = p.anchor.offset,
        b = g.getParentOrThrow(),
        m = $r(g);
      return x === 0
        ? !g.canInsertTextBefore() ||
            (!b.canInsertTextBefore() && !g.isComposing()) ||
            m ||
            (function (v) {
              const _ = v.getPreviousSibling();
              return (Z(_) || (P(_) && _.isInline())) && !_.canInsertTextAfter();
            })(g)
        : x === g.getTextContentSize() &&
            (!g.canInsertTextAfter() || (!b.canInsertTextAfter() && !g.isComposing()) || m);
    })(e, l)
  );
}
function sp(e, t) {
  return tr(e) && e.nodeValue !== null && t !== 0 && t !== e.nodeValue.length;
}
function lp(e, t, n) {
  const { anchorNode: r, anchorOffset: i, focusNode: o, focusOffset: s } = e;
  (pc && ((pc = !1), sp(r, i) && sp(o, s) && !Fr)) ||
    Rt(t, () => {
      if (!n) return void Ye(null);
      if (!fs(t, r, o)) return;
      let l = J();
      if (Fr && H(l) && l.isCollapsed()) {
        const a = l.anchor,
          u = Fr.anchor;
        ((a.key === u.key && a.offset === u.offset + 1) ||
          (a.offset === 1 && u.getNode().is(a.getNode().getPreviousSibling()))) &&
          ((l = Fr.clone()), Ye(l));
      }
      if (((Fr = null), H(l))) {
        const a = l.anchor,
          u = a.getNode();
        if (l.isCollapsed()) {
          e.type === "Range" && e.anchorNode === e.focusNode && (l.dirty = !0);
          const c = Jt(t).event,
            d = c ? c.timeStamp : performance.now(),
            [f, h, p, g, x] = X1,
            b = Ce(),
            m = t.isComposing() === !1 && b.getTextContent() === "";
          if (d < x + 200 && a.offset === p && a.key === g) Ys(l, f, h);
          else if (a.type === "text") Z(u) || K(141), e0(l, u);
          else if (a.type === "element" && !m) {
            P(u) || K(259);
            const v = a.getNode();
            v.isEmpty()
              ? (function (_, k) {
                  const w = k.getTextFormat(),
                    y = k.getTextStyle();
                  Ys(_, w, y);
                })(l, v)
              : Ys(l, 0, "");
          }
        } else {
          const c = a.key,
            d = l.focus.key,
            f = l.getNodes(),
            h = f.length,
            p = l.isBackward(),
            g = p ? s : i,
            x = p ? i : s,
            b = p ? d : c,
            m = p ? c : d;
          let v = KC,
            _ = !1;
          for (let k = 0; k < h; k++) {
            const w = f[k],
              y = w.getTextContentSize();
            if (
              Z(w) &&
              y !== 0 &&
              !((k === 0 && w.__key === b && g === y) || (k === h - 1 && w.__key === m && x === 0)) &&
              ((_ = !0), (v &= w.getFormat()), v === 0)
            )
              break;
          }
          l.format = _ ? v : 0;
        }
      }
      re(t, os, void 0);
    });
}
function Ys(e, t, n) {
  (e.format === t && e.style === n) || ((e.format = t), (e.style = n), (e.dirty = !0));
}
function e0(e, t) {
  Ys(e, t.getFormat(), t.getStyle());
}
function t0(e) {
  if (!e.getTargetRanges) return null;
  const t = e.getTargetRanges();
  return t.length === 0 ? null : t[0];
}
function Ms(e, t) {
  const n = e._compositionKey;
  if ((ft(null), n !== null && t != null)) {
    if (t === "") {
      const r = Oe(n),
        i = Fi(e.getElementByKey(n));
      return void (i !== null && i.nodeValue !== null && Z(r) && cf(r, i.nodeValue, null, null, !0));
    }
    if (
      t[t.length - 1] ===
      `
`
    ) {
      const r = J();
      if (H(r)) {
        const i = r.focus;
        return r.anchor.set(i.key, i.offset, i.type), void re(e, Oi, null);
      }
    }
  }
  uf(!0, e, t);
}
function n0(e) {
  let t = e.__lexicalEventHandles;
  return t === void 0 && ((t = []), (e.__lexicalEventHandles = t)), t;
}
const Ti = new Map();
function r0(e) {
  const t = K_(e.target);
  if (t === null) return;
  const n = lf(t.anchorNode);
  if (n === null) return;
  gc &&
    ((gc = !1),
    Rt(n, () => {
      const a = oi(),
        u = t.anchorNode;
      (We(u) || tr(u)) && Ye(Yd(a, t, n, e));
    }));
  const r = af(n),
    i = r[r.length - 1],
    o = i._key,
    s = Ti.get(o),
    l = s || i;
  l !== n && lp(t, l, !1), lp(t, n, !0), n !== i ? Ti.set(o, n) : s && Ti.delete(o);
}
function ap(e) {
  e._lexicalHandled = !0;
}
function up(e) {
  return e._lexicalHandled === !0;
}
const v_ = () => {};
function b_(e) {
  const t = e.ownerDocument,
    n = vl.get(t);
  if (n === void 0) return void v_();
  const r = n - 1;
  r >= 0 || K(164), vl.set(t, r), r === 0 && t.removeEventListener("selectionchange", r0);
  const i = ha(e);
  sf(i)
    ? ((function (s) {
        if (s._parentEditor !== null) {
          const l = af(s),
            a = l[l.length - 1]._key;
          Ti.get(a) === s && Ti.delete(a);
        } else Ti.delete(s._key);
      })(i),
      (e.__lexicalEditor = null))
    : i && K(198);
  const o = n0(e);
  for (let s = 0; s < o.length; s++) o[s]();
  e.__lexicalEventHandles = [];
}
function mc(e, t, n) {
  pt();
  const r = e.__key,
    i = e.getParent();
  if (i === null) return;
  const o = (function (l) {
    const a = J();
    if (!H(a) || !P(l)) return a;
    const { anchor: u, focus: c } = a,
      d = u.getNode(),
      f = c.getNode();
    return bc(d, l) && u.set(l.__key, 0, "element"), bc(f, l) && c.set(l.__key, 0, "element"), a;
  })(e);
  let s = !1;
  if (H(o) && t) {
    const l = o.anchor,
      a = o.focus;
    l.key === r && (Cl(l, e, i, e.getPreviousSibling(), e.getNextSibling()), (s = !0)),
      a.key === r && (Cl(a, e, i, e.getPreviousSibling(), e.getNextSibling()), (s = !0));
  } else Je(o) && t && e.isSelected() && e.selectPrevious();
  if (H(o) && t && !s) {
    const l = e.getIndexWithinParent();
    Br(e), yl(o, i, l, -1);
  } else Br(e);
  n || tt(i) || i.canBeEmpty() || !i.isEmpty() || mc(i, t), t && o && ut(i) && i.isEmpty() && i.selectEnd();
}
class aa {
  static getType() {
    K(64, this.name);
  }
  static clone(t) {
    K(65, this.name);
  }
  afterCloneFrom(t) {
    (this.__parent = t.__parent), (this.__next = t.__next), (this.__prev = t.__prev), (this.__state = t.__state);
  }
  constructor(t) {
    (this.__type = this.constructor.getType()),
      (this.__parent = null),
      (this.__prev = null),
      (this.__next = null),
      Object.defineProperty(this, "__state", { configurable: !0, enumerable: !1, value: void 0, writable: !0 }),
      v0(this, t);
  }
  getType() {
    return this.__type;
  }
  isInline() {
    K(137, this.constructor.name);
  }
  isAttached() {
    let t = this.__key;
    for (; t !== null; ) {
      if (t === "root") return !0;
      const n = Oe(t);
      if (n === null) break;
      t = n.__parent;
    }
    return !1;
  }
  isSelected(t) {
    const n = t || J();
    if (n == null) return !1;
    const r = n.getNodes().some((i) => i.__key === this.__key);
    if (Z(this)) return r;
    if (H(n) && n.anchor.type === "element" && n.focus.type === "element") {
      if (n.isCollapsed()) return !1;
      const i = this.getParent();
      if (Te(this) && this.isInline() && i) {
        const o = n.isBackward() ? n.focus : n.anchor;
        if (i.is(o.getNode()) && o.offset === i.getChildrenSize() && this.is(i.getLastChild())) return !1;
      }
    }
    return r;
  }
  getKey() {
    return this.__key;
  }
  getIndexWithinParent() {
    const t = this.getParent();
    if (t === null) return -1;
    let n = t.getFirstChild(),
      r = 0;
    for (; n !== null; ) {
      if (this.is(n)) return r;
      r++, (n = n.getNextSibling());
    }
    return -1;
  }
  getParent() {
    const t = this.getLatest().__parent;
    return t === null ? null : Oe(t);
  }
  getParentOrThrow() {
    const t = this.getParent();
    return t === null && K(66, this.__key), t;
  }
  getTopLevelElement() {
    let t = this;
    for (; t !== null; ) {
      const n = t.getParent();
      if (tt(n)) return P(t) || (t === this && Te(t)) || K(194), t;
      t = n;
    }
    return null;
  }
  getTopLevelElementOrThrow() {
    const t = this.getTopLevelElement();
    return t === null && K(67, this.__key), t;
  }
  getParents() {
    const t = [];
    let n = this.getParent();
    for (; n !== null; ) t.push(n), (n = n.getParent());
    return t;
  }
  getParentKeys() {
    const t = [];
    let n = this.getParent();
    for (; n !== null; ) t.push(n.__key), (n = n.getParent());
    return t;
  }
  getPreviousSibling() {
    const t = this.getLatest().__prev;
    return t === null ? null : Oe(t);
  }
  getPreviousSiblings() {
    const t = [],
      n = this.getParent();
    if (n === null) return t;
    let r = n.getFirstChild();
    for (; r !== null && !r.is(this); ) t.push(r), (r = r.getNextSibling());
    return t;
  }
  getNextSibling() {
    const t = this.getLatest().__next;
    return t === null ? null : Oe(t);
  }
  getNextSiblings() {
    const t = [];
    let n = this.getNextSibling();
    for (; n !== null; ) t.push(n), (n = n.getNextSibling());
    return t;
  }
  getCommonAncestor(t) {
    const n = P(this) ? this : this.getParent(),
      r = P(t) ? t : t.getParent(),
      i = n && r ? el(n, r) : null;
    return i ? i.commonAncestor : null;
  }
  is(t) {
    return t != null && this.__key === t.__key;
  }
  isBefore(t) {
    const n = el(this, t);
    return (
      n !== null &&
      (n.type === "descendant" ||
        (n.type === "branch" ? O0(n) === -1 : (n.type !== "same" && n.type !== "ancestor" && K(279), !1)))
    );
  }
  isParentOf(t) {
    const n = el(this, t);
    return n !== null && n.type === "ancestor";
  }
  getNodesBetween(t) {
    const n = this.isBefore(t),
      r = [],
      i = new Set();
    let o = this;
    for (; o !== null; ) {
      const s = o.__key;
      if ((i.has(s) || (i.add(s), r.push(o)), o === t)) break;
      const l = P(o) ? (n ? o.getFirstChild() : o.getLastChild()) : null;
      if (l !== null) {
        o = l;
        continue;
      }
      const a = n ? o.getNextSibling() : o.getPreviousSibling();
      if (a !== null) {
        o = a;
        continue;
      }
      const u = o.getParentOrThrow();
      if ((i.has(u.__key) || r.push(u), u === t)) break;
      let c = null,
        d = u;
      do {
        if (
          (d === null && K(68), (c = n ? d.getNextSibling() : d.getPreviousSibling()), (d = d.getParent()), d === null)
        )
          break;
        c !== null || i.has(d.__key) || r.push(d);
      } while (c === null);
      o = c;
    }
    return n || r.reverse(), r;
  }
  isDirty() {
    const t = Ge()._dirtyLeaves;
    return t !== null && t.has(this.__key);
  }
  getLatest() {
    const t = Oe(this.__key);
    return t === null && K(113), t;
  }
  getWritable() {
    pt();
    const t = yr(),
      n = Ge(),
      r = t._nodeMap,
      i = this.__key,
      o = this.getLatest(),
      s = n._cloneNotNeeded,
      l = J();
    if ((l !== null && l.setCachedNodes(null), s.has(i))) return kl(o), o;
    const a = hf(o);
    return s.add(i), kl(a), r.set(i, a), a;
  }
  getTextContent() {
    return "";
  }
  getTextContentSize() {
    return this.getTextContent().length;
  }
  createDOM(t, n) {
    K(70);
  }
  updateDOM(t, n, r) {
    K(71);
  }
  exportDOM(t) {
    return { element: this.createDOM(t._config, t) };
  }
  exportJSON() {
    const t = this.__state ? this.__state.toJSON() : void 0;
    return { type: this.__type, version: 1, ...t };
  }
  static importJSON(t) {
    K(18, this.name);
  }
  updateFromJSON(t) {
    return (function (n, r) {
      const i = n.getWritable();
      return (r || i.__state) && l_(n).updateFromJSON(r), i;
    })(this, t.$);
  }
  static transform() {
    return null;
  }
  remove(t) {
    mc(this, !0, t);
  }
  replace(t, n) {
    pt();
    let r = J();
    r !== null && (r = r.clone()), uu(this, t);
    const i = this.getLatest(),
      o = this.__key,
      s = t.__key,
      l = t.getWritable(),
      a = this.getParentOrThrow().getWritable(),
      u = a.__size;
    Br(l);
    const c = i.getPreviousSibling(),
      d = i.getNextSibling(),
      f = i.__prev,
      h = i.__next,
      p = i.__parent;
    if (
      (mc(i, !1, !0),
      c === null ? (a.__first = s) : (c.getWritable().__next = s),
      (l.__prev = f),
      d === null ? (a.__last = s) : (d.getWritable().__prev = s),
      (l.__next = h),
      (l.__parent = p),
      (a.__size = u),
      n &&
        ((P(this) && P(l)) || K(139),
        this.getChildren().forEach((g) => {
          l.append(g);
        })),
      H(r))
    ) {
      Ye(r);
      const g = r.anchor,
        x = r.focus;
      g.key === o && hp(g, l), x.key === o && hp(x, l);
    }
    return cr() === o && ft(s), l;
  }
  insertAfter(t, n = !0) {
    pt(), uu(this, t);
    const r = this.getWritable(),
      i = t.getWritable(),
      o = i.getParent(),
      s = J();
    let l = !1,
      a = !1;
    if (o !== null) {
      const h = t.getIndexWithinParent();
      if ((Br(i), H(s))) {
        const p = o.__key,
          g = s.anchor,
          x = s.focus;
        (l = g.type === "element" && g.key === p && g.offset === h + 1),
          (a = x.type === "element" && x.key === p && x.offset === h + 1);
      }
    }
    const u = this.getNextSibling(),
      c = this.getParentOrThrow().getWritable(),
      d = i.__key,
      f = r.__next;
    if (
      (u === null ? (c.__last = d) : (u.getWritable().__prev = d),
      c.__size++,
      (r.__next = d),
      (i.__next = f),
      (i.__prev = r.__key),
      (i.__parent = r.__parent),
      n && H(s))
    ) {
      const h = this.getIndexWithinParent();
      yl(s, c, h + 1);
      const p = c.__key;
      l && s.anchor.set(p, h + 2, "element"), a && s.focus.set(p, h + 2, "element");
    }
    return t;
  }
  insertBefore(t, n = !0) {
    pt(), uu(this, t);
    const r = this.getWritable(),
      i = t.getWritable(),
      o = i.__key;
    Br(i);
    const s = this.getPreviousSibling(),
      l = this.getParentOrThrow().getWritable(),
      a = r.__prev,
      u = this.getIndexWithinParent();
    s === null ? (l.__first = o) : (s.getWritable().__next = o),
      l.__size++,
      (r.__prev = o),
      (i.__prev = a),
      (i.__next = r.__key),
      (i.__parent = r.__parent);
    const c = J();
    return n && H(c) && yl(c, this.getParentOrThrow(), u), t;
  }
  isParentRequired() {
    return !1;
  }
  createParentElementNode() {
    return Se();
  }
  selectStart() {
    return this.selectPrevious();
  }
  selectEnd() {
    return this.selectNext(0, 0);
  }
  selectPrevious(t, n) {
    pt();
    const r = this.getPreviousSibling(),
      i = this.getParentOrThrow();
    if (r === null) return i.select(0, 0);
    if (P(r)) return r.select();
    if (!Z(r)) {
      const o = r.getIndexWithinParent() + 1;
      return i.select(o, o);
    }
    return r.select(t, n);
  }
  selectNext(t, n) {
    pt();
    const r = this.getNextSibling(),
      i = this.getParentOrThrow();
    if (r === null) return i.select();
    if (P(r)) return r.select(0, 0);
    if (!Z(r)) {
      const o = r.getIndexWithinParent();
      return i.select(o, o);
    }
    return r.select(t, n);
  }
  markDirty() {
    this.getWritable();
  }
  reconcileObservedMutation(t, n) {
    this.markDirty();
  }
}
class as extends aa {
  static getType() {
    return "linebreak";
  }
  static clone(t) {
    return new as(t.__key);
  }
  constructor(t) {
    super(t);
  }
  getTextContent() {
    return `
`;
  }
  createDOM() {
    return document.createElement("br");
  }
  updateDOM() {
    return !1;
  }
  isInline() {
    return !0;
  }
  static importDOM() {
    return {
      br: (t) =>
        (function (n) {
          const r = n.parentElement;
          if (r !== null && Sl(r)) {
            const i = r.firstChild;
            if (i === n || (i.nextSibling === n && Os(i))) {
              const o = r.lastChild;
              if (o === n || (o.previousSibling === n && Os(o))) return !0;
            }
          }
          return !1;
        })(t) ||
        (function (n) {
          const r = n.parentElement;
          if (r !== null && Sl(r)) {
            const i = r.firstChild;
            if (i === n || (i.nextSibling === n && Os(i))) return !1;
            const o = r.lastChild;
            if (o === n || (o.previousSibling === n && Os(o))) return !0;
          }
          return !1;
        })(t)
          ? null
          : { conversion: y_, priority: 0 },
    };
  }
  static importJSON(t) {
    return sn().updateFromJSON(t);
  }
}
function y_(e) {
  return { node: sn() };
}
function sn() {
  return Mt(new as());
}
function rn(e) {
  return e instanceof as;
}
function Os(e) {
  return tr(e) && /^( |\t|\r?\n)+$/.test(e.textContent || "");
}
function iu(e, t) {
  return 16 & t ? "code" : t & Md ? "mark" : 32 & t ? "sub" : 64 & t ? "sup" : null;
}
function ou(e, t) {
  return 1 & t ? "strong" : 2 & t ? "em" : "span";
}
function i0(e, t, n, r, i) {
  const o = r.classList;
  let s = Ai(i, "base");
  s !== void 0 && o.add(...s), (s = Ai(i, "underlineStrikethrough"));
  let l = !1;
  const a = t & hl && t & fl;
  s !== void 0 && (n & hl && n & fl ? ((l = !0), a || o.add(...s)) : a && o.remove(...s));
  for (const u in Et) {
    const c = Et[u];
    if (((s = Ai(i, u)), s !== void 0))
      if (n & c) {
        if (l && (u === "underline" || u === "strikethrough")) {
          t & c && o.remove(...s);
          continue;
        }
        (t & c && (!a || u !== "underline") && u !== "strikethrough") || o.add(...s);
      } else t & c && o.remove(...s);
  }
}
function o0(e, t, n) {
  const r = t.firstChild,
    i = n.isComposing(),
    o = e + (i ? Yl : "");
  if (r == null) t.textContent = o;
  else {
    const s = r.nodeValue;
    if (s !== o)
      if (i || Ur) {
        const [l, a, u] = (function (c, d) {
          const f = c.length,
            h = d.length;
          let p = 0,
            g = 0;
          for (; p < f && p < h && c[p] === d[p]; ) p++;
          for (; g + p < f && g + p < h && c[f - g - 1] === d[h - g - 1]; ) g++;
          return [p, f - p - g, d.slice(p, h - g)];
        })(s, o);
        a !== 0 && r.deleteData(l, a), r.insertData(l, u);
      } else r.nodeValue = o;
  }
}
function cp(e, t, n, r, i, o) {
  o0(i, e, t);
  const s = o.theme.text;
  s !== void 0 && i0(0, 0, r, e, s);
}
function Fs(e, t) {
  const n = document.createElement(t);
  return n.appendChild(e), n;
}
class Ln extends aa {
  static getType() {
    return "text";
  }
  static clone(t) {
    return new Ln(t.__text, t.__key);
  }
  afterCloneFrom(t) {
    super.afterCloneFrom(t),
      (this.__text = t.__text),
      (this.__format = t.__format),
      (this.__style = t.__style),
      (this.__mode = t.__mode),
      (this.__detail = t.__detail);
  }
  constructor(t = "", n) {
    super(n), (this.__text = t), (this.__format = 0), (this.__style = ""), (this.__mode = 0), (this.__detail = 0);
  }
  getFormat() {
    return this.getLatest().__format;
  }
  getDetail() {
    return this.getLatest().__detail;
  }
  getMode() {
    const t = this.getLatest();
    return QC[t.__mode];
  }
  getStyle() {
    return this.getLatest().__style;
  }
  isToken() {
    return this.getLatest().__mode === 1;
  }
  isComposing() {
    return this.__key === cr();
  }
  isSegmented() {
    return this.getLatest().__mode === 2;
  }
  isDirectionless() {
    return !!(1 & this.getLatest().__detail);
  }
  isUnmergeable() {
    return !!(2 & this.getLatest().__detail);
  }
  hasFormat(t) {
    const n = Et[t];
    return !!(this.getFormat() & n);
  }
  isSimpleText() {
    return this.__type === "text" && this.__mode === 0;
  }
  getTextContent() {
    return this.getLatest().__text;
  }
  getFormatFlags(t, n) {
    return El(this.getLatest().__format, t, n);
  }
  canHaveFormat() {
    return !0;
  }
  isInline() {
    return !0;
  }
  createDOM(t, n) {
    const r = this.__format,
      i = iu(0, r),
      o = ou(0, r),
      s = i === null ? o : i,
      l = document.createElement(s);
    let a = l;
    this.hasFormat("code") && l.setAttribute("spellcheck", "false"),
      i !== null && ((a = document.createElement(o)), l.appendChild(a)),
      cp(a, this, 0, r, this.__text, t);
    const u = this.__style;
    return u !== "" && (l.style.cssText = u), l;
  }
  updateDOM(t, n, r) {
    const i = this.__text,
      o = t.__format,
      s = this.__format,
      l = iu(0, o),
      a = iu(0, s),
      u = ou(0, o),
      c = ou(0, s);
    if ((l === null ? u : l) !== (a === null ? c : a)) return !0;
    if (l === a && u !== c) {
      const g = n.firstChild;
      g == null && K(48);
      const x = document.createElement(c);
      return cp(x, this, 0, s, i, r), n.replaceChild(x, g), !1;
    }
    let d = n;
    a !== null && l !== null && ((d = n.firstChild), d == null && K(49)), o0(i, d, this);
    const f = r.theme.text;
    f !== void 0 && o !== s && i0(0, o, s, d, f);
    const h = t.__style,
      p = this.__style;
    return h !== p && (n.style.cssText = p), !1;
  }
  static importDOM() {
    return {
      "#text": () => ({ conversion: E_, priority: 0 }),
      b: () => ({ conversion: __, priority: 0 }),
      code: () => ({ conversion: Pn, priority: 0 }),
      em: () => ({ conversion: Pn, priority: 0 }),
      i: () => ({ conversion: Pn, priority: 0 }),
      mark: () => ({ conversion: Pn, priority: 0 }),
      s: () => ({ conversion: Pn, priority: 0 }),
      span: () => ({ conversion: C_, priority: 0 }),
      strong: () => ({ conversion: Pn, priority: 0 }),
      sub: () => ({ conversion: Pn, priority: 0 }),
      sup: () => ({ conversion: Pn, priority: 0 }),
      u: () => ({ conversion: Pn, priority: 0 }),
    };
  }
  static importJSON(t) {
    return Be().updateFromJSON(t);
  }
  updateFromJSON(t) {
    return super
      .updateFromJSON(t)
      .setTextContent(t.text)
      .setFormat(t.format)
      .setDetail(t.detail)
      .setMode(t.mode)
      .setStyle(t.style);
  }
  exportDOM(t) {
    let { element: n } = super.exportDOM(t);
    return (
      We(n) || K(132),
      (n.style.whiteSpace = "pre-wrap"),
      this.hasFormat("lowercase")
        ? (n.style.textTransform = "lowercase")
        : this.hasFormat("uppercase")
          ? (n.style.textTransform = "uppercase")
          : this.hasFormat("capitalize") && (n.style.textTransform = "capitalize"),
      this.hasFormat("bold") && (n = Fs(n, "b")),
      this.hasFormat("italic") && (n = Fs(n, "i")),
      this.hasFormat("strikethrough") && (n = Fs(n, "s")),
      this.hasFormat("underline") && (n = Fs(n, "u")),
      { element: n }
    );
  }
  exportJSON() {
    return {
      detail: this.getDetail(),
      format: this.getFormat(),
      mode: this.getMode(),
      style: this.getStyle(),
      text: this.getTextContent(),
      ...super.exportJSON(),
    };
  }
  selectionTransform(t, n) {}
  setFormat(t) {
    const n = this.getWritable();
    return (n.__format = typeof t == "string" ? Et[t] : t), n;
  }
  setDetail(t) {
    const n = this.getWritable();
    return (n.__detail = typeof t == "string" ? qC[t] : t), n;
  }
  setStyle(t) {
    const n = this.getWritable();
    return (n.__style = t), n;
  }
  toggleFormat(t) {
    const n = El(this.getFormat(), t, null);
    return this.setFormat(n);
  }
  toggleDirectionless() {
    const t = this.getWritable();
    return (t.__detail ^= 1), t;
  }
  toggleUnmergeable() {
    const t = this.getWritable();
    return (t.__detail ^= 2), t;
  }
  setMode(t) {
    const n = XC[t];
    if (this.__mode === n) return this;
    const r = this.getWritable();
    return (r.__mode = n), r;
  }
  setTextContent(t) {
    if (this.__text === t) return this;
    const n = this.getWritable();
    return (n.__text = t), n;
  }
  select(t, n) {
    pt();
    let r = t,
      i = n;
    const o = J(),
      s = this.getTextContent(),
      l = this.__key;
    if (typeof s == "string") {
      const a = s.length;
      r === void 0 && (r = a), i === void 0 && (i = a);
    } else (r = 0), (i = 0);
    if (!H(o)) return a0(l, r, l, i, "text", "text");
    {
      const a = cr();
      (a !== o.anchor.key && a !== o.focus.key) || ft(l), o.setTextNodeRange(this, r, this, i);
    }
    return o;
  }
  selectStart() {
    return this.select(0, 0);
  }
  selectEnd() {
    const t = this.getTextContentSize();
    return this.select(t, t);
  }
  spliceText(t, n, r, i) {
    const o = this.getWritable(),
      s = o.__text,
      l = r.length;
    let a = t;
    a < 0 && ((a = l + a), a < 0 && (a = 0));
    const u = J();
    if (i && H(u)) {
      const d = t + l;
      u.setTextNodeRange(o, d, o, d);
    }
    const c = s.slice(0, a) + r + s.slice(a + n);
    return (o.__text = c), o;
  }
  canInsertTextBefore() {
    return !0;
  }
  canInsertTextAfter() {
    return !0;
  }
  splitText(...t) {
    pt();
    const n = this.getLatest(),
      r = n.getTextContent();
    if (r === "") return [];
    const i = n.__key,
      o = cr(),
      s = r.length;
    t.sort((S, T) => S - T), t.push(s);
    const l = [],
      a = t.length;
    for (let S = 0, T = 0; S < s && T <= a; T++) {
      const A = t[T];
      A > S && (l.push(r.slice(S, A)), (S = A));
    }
    const u = l.length;
    if (u === 1) return [n];
    const c = l[0],
      d = n.getParent();
    let f;
    const h = n.getFormat(),
      p = n.getStyle(),
      g = n.__detail;
    let x = !1,
      b = null,
      m = null;
    const v = J();
    if (H(v)) {
      const [S, T] = v.isBackward() ? [v.focus, v.anchor] : [v.anchor, v.focus];
      S.type === "text" && S.key === i && (b = S), T.type === "text" && T.key === i && (m = T);
    }
    n.isSegmented()
      ? ((f = Be(c)), (f.__format = h), (f.__style = p), (f.__detail = g), (x = !0))
      : (f = n.setTextContent(c));
    const _ = [f];
    for (let S = 1; S < u; S++) {
      const T = Be(l[S]);
      (T.__format = h), (T.__style = p), (T.__detail = g);
      const A = T.__key;
      o === i && ft(A), _.push(T);
    }
    const k = b ? b.offset : null,
      w = m ? m.offset : null;
    let y = 0;
    for (const S of _) {
      if (!b && !m) break;
      const T = y + S.getTextContentSize();
      if (
        (b !== null && k !== null && k <= T && k >= y && (b.set(S.getKey(), k - y, "text"), k < T && (b = null)),
        m !== null && w !== null && w <= T && w >= y)
      ) {
        m.set(S.getKey(), w - y, "text");
        break;
      }
      y = T;
    }
    if (d !== null) {
      (function (A) {
        const F = A.getPreviousSibling(),
          R = A.getNextSibling();
        F !== null && kl(F), R !== null && kl(R);
      })(this);
      const S = d.getWritable(),
        T = this.getIndexWithinParent();
      x ? (S.splice(T, 0, _), this.remove()) : S.splice(T, 1, _), H(v) && yl(v, d, T, u - 1);
    }
    return _;
  }
  mergeWithSibling(t) {
    const n = t === this.getPreviousSibling();
    n || t === this.getNextSibling() || K(50);
    const r = this.__key,
      i = t.__key,
      o = this.__text,
      s = o.length;
    cr() === i && ft(r);
    const l = J();
    if (H(l)) {
      const d = l.anchor,
        f = l.focus;
      d !== null && d.key === i && yp(d, n, r, t, s), f !== null && f.key === i && yp(f, n, r, t, s);
    }
    const a = t.__text,
      u = n ? a + o : o + a;
    this.setTextContent(u);
    const c = this.getWritable();
    return t.remove(), c;
  }
  isTextEntity() {
    return !1;
  }
}
function C_(e) {
  return { forChild: Zd(e.style), node: null };
}
function __(e) {
  const t = e,
    n = t.style.fontWeight === "normal";
  return { forChild: Zd(t.style, n ? void 0 : "bold"), node: null };
}
const dp = new WeakMap();
function w_(e) {
  if (!We(e)) return !1;
  if (e.nodeName === "PRE") return !0;
  const t = e.style.whiteSpace;
  return typeof t == "string" && t.startsWith("pre");
}
function E_(e) {
  const t = e;
  e.parentElement === null && K(129);
  let n = t.textContent || "";
  if (
    (function (r) {
      let i,
        o = r.parentNode;
      const s = [r];
      for (; o !== null && (i = dp.get(o)) === void 0 && !w_(o); ) s.push(o), (o = o.parentNode);
      const l = i === void 0 ? o : i;
      for (let a = 0; a < s.length; a++) dp.set(s[a], l);
      return l;
    })(t) !== null
  ) {
    const r = n.split(/(\r?\n|\t)/),
      i = [],
      o = r.length;
    for (let s = 0; s < o; s++) {
      const l = r[s];
      l ===
        `
` ||
      l ===
        `\r
`
        ? i.push(sn())
        : l === "	"
          ? i.push(Zi())
          : l !== "" && i.push(Be(l));
    }
    return { node: i };
  }
  if (((n = n.replace(/\r/g, "").replace(/[ \t\n]+/g, " ")), n === "")) return { node: null };
  if (n[0] === " ") {
    let r = t,
      i = !0;
    for (; r !== null && (r = fp(r, !1)) !== null; ) {
      const o = r.textContent || "";
      if (o.length > 0) {
        /[ \t\n]$/.test(o) && (n = n.slice(1)), (i = !1);
        break;
      }
    }
    i && (n = n.slice(1));
  }
  if (n[n.length - 1] === " ") {
    let r = t,
      i = !0;
    for (; r !== null && (r = fp(r, !0)) !== null; )
      if ((r.textContent || "").replace(/^( |\t|\r?\n)+/, "").length > 0) {
        i = !1;
        break;
      }
    i && (n = n.slice(0, n.length - 1));
  }
  return n === "" ? { node: null } : { node: Be(n) };
}
function fp(e, t) {
  let n = e;
  for (;;) {
    let r;
    for (; (r = t ? n.nextSibling : n.previousSibling) === null; ) {
      const o = n.parentElement;
      if (o === null) return null;
      n = o;
    }
    if (((n = r), We(n))) {
      const o = n.style.display;
      if ((o === "" && !_c(n)) || (o !== "" && !o.startsWith("inline"))) return null;
    }
    let i = n;
    for (; (i = t ? n.firstChild : n.lastChild) !== null; ) n = i;
    if (tr(n)) return n;
    if (n.nodeName === "BR") return null;
  }
}
const k_ = {
  code: "code",
  em: "italic",
  i: "italic",
  mark: "highlight",
  s: "strikethrough",
  strong: "bold",
  sub: "subscript",
  sup: "superscript",
  u: "underline",
};
function Pn(e) {
  const t = k_[e.nodeName.toLowerCase()];
  return t === void 0 ? { node: null } : { forChild: Zd(e.style, t), node: null };
}
function Be(e = "") {
  return Mt(new Ln(e));
}
function Z(e) {
  return e instanceof Ln;
}
function Zd(e, t) {
  const n = e.fontWeight,
    r = e.textDecoration.split(" "),
    i = n === "700" || n === "bold",
    o = r.includes("line-through"),
    s = e.fontStyle === "italic",
    l = r.includes("underline"),
    a = e.verticalAlign;
  return (u) => (
    Z(u) &&
      (i && !u.hasFormat("bold") && u.toggleFormat("bold"),
      o && !u.hasFormat("strikethrough") && u.toggleFormat("strikethrough"),
      s && !u.hasFormat("italic") && u.toggleFormat("italic"),
      l && !u.hasFormat("underline") && u.toggleFormat("underline"),
      a !== "sub" || u.hasFormat("subscript") || u.toggleFormat("subscript"),
      a !== "super" || u.hasFormat("superscript") || u.toggleFormat("superscript"),
      t && !u.hasFormat(t) && u.toggleFormat(t)),
    u
  );
}
class us extends Ln {
  static getType() {
    return "tab";
  }
  static clone(t) {
    return new us(t.__key);
  }
  constructor(t) {
    super("	", t), (this.__detail = 2);
  }
  static importDOM() {
    return null;
  }
  createDOM(t) {
    const n = super.createDOM(t),
      r = Ai(t.theme, "tab");
    return r !== void 0 && n.classList.add(...r), n;
  }
  static importJSON(t) {
    return Zi().updateFromJSON(t);
  }
  setTextContent(t) {
    return t !== "	" && t !== "" && K(126), super.setTextContent("	");
  }
  spliceText(t, n, r, i) {
    return (r === "" && n === 0) || (r === "	" && n === 1) || K(286), this;
  }
  setDetail(t) {
    return t !== 2 && K(127), this;
  }
  setMode(t) {
    return t !== "normal" && K(128), this;
  }
  canInsertTextBefore() {
    return !1;
  }
  canInsertTextAfter() {
    return !1;
  }
}
function Zi() {
  return Mt(new us());
}
function ua(e) {
  return e instanceof us;
}
class S_ {
  constructor(t, n, r) {
    (this._selection = null), (this.key = t), (this.offset = n), (this.type = r);
  }
  is(t) {
    return this.key === t.key && this.offset === t.offset && this.type === t.type;
  }
  isBefore(t) {
    return this.key === t.key ? this.offset < t.offset : M0(Pt(Yn(this, "next")), Pt(Yn(t, "next"))) < 0;
  }
  getNode() {
    const t = Oe(this.key);
    return t === null && K(20), t;
  }
  set(t, n, r, i) {
    const o = this._selection,
      s = this.key;
    (i && this.key === t && this.offset === n && this.type === r) ||
      ((this.key = t),
      (this.offset = n),
      (this.type = r),
      cs() || (cr() === s && ft(t), o !== null && (o.setCachedNodes(null), (o.dirty = !0))));
  }
}
function Tn(e, t, n) {
  return new S_(e, t, n);
}
function su(e, t) {
  let n = t.__key,
    r = e.offset,
    i = "element";
  if (Z(t)) {
    i = "text";
    const o = t.getTextContentSize();
    r > o && (r = o);
  } else if (!P(t)) {
    const o = t.getNextSibling();
    if (Z(o)) (n = o.__key), (r = 0), (i = "text");
    else {
      const s = t.getParent();
      s && ((n = s.__key), (r = t.getIndexWithinParent() + 1));
    }
  }
  e.set(n, r, i);
}
function hp(e, t) {
  if (P(t)) {
    const n = t.getLastDescendant();
    P(n) || Z(n) ? su(e, n) : su(e, t);
  } else su(e, t);
}
class ca {
  constructor(t) {
    (this._cachedNodes = null), (this._nodes = t), (this.dirty = !1);
  }
  getCachedNodes() {
    return this._cachedNodes;
  }
  setCachedNodes(t) {
    this._cachedNodes = t;
  }
  is(t) {
    if (!Je(t)) return !1;
    const n = this._nodes,
      r = t._nodes;
    return n.size === r.size && Array.from(n).every((i) => r.has(i));
  }
  isCollapsed() {
    return !1;
  }
  isBackward() {
    return !1;
  }
  getStartEndPoints() {
    return null;
  }
  add(t) {
    (this.dirty = !0), this._nodes.add(t), (this._cachedNodes = null);
  }
  delete(t) {
    (this.dirty = !0), this._nodes.delete(t), (this._cachedNodes = null);
  }
  clear() {
    (this.dirty = !0), this._nodes.clear(), (this._cachedNodes = null);
  }
  has(t) {
    return this._nodes.has(t);
  }
  clone() {
    return new ca(new Set(this._nodes));
  }
  extract() {
    return this.getNodes();
  }
  insertRawText(t) {}
  insertText() {}
  insertNodes(t) {
    const n = this.getNodes(),
      r = n.length,
      i = n[r - 1];
    let o;
    if (Z(i)) o = i.select();
    else {
      const s = i.getIndexWithinParent() + 1;
      o = i.getParentOrThrow().select(s, s);
    }
    o.insertNodes(t);
    for (let s = 0; s < r; s++) n[s].remove();
  }
  getNodes() {
    const t = this._cachedNodes;
    if (t !== null) return t;
    const n = this._nodes,
      r = [];
    for (const i of n) {
      const o = Oe(i);
      o !== null && r.push(o);
    }
    return cs() || (this._cachedNodes = r), r;
  }
  getTextContent() {
    const t = this.getNodes();
    let n = "";
    for (let r = 0; r < t.length; r++) n += t[r].getTextContent();
    return n;
  }
  deleteNodes() {
    const t = this.getNodes();
    if ((J() || oi()) === this && t[0]) {
      const n = nt(t[0], "next");
      F0(Yr(n, n));
    }
    for (const n of t) n.remove();
  }
}
function H(e) {
  return e instanceof ii;
}
class ii {
  constructor(t, n, r, i) {
    (this.anchor = t),
      (this.focus = n),
      (t._selection = this),
      (n._selection = this),
      (this._cachedNodes = null),
      (this.format = r),
      (this.style = i),
      (this.dirty = !1);
  }
  getCachedNodes() {
    return this._cachedNodes;
  }
  setCachedNodes(t) {
    this._cachedNodes = t;
  }
  is(t) {
    return (
      !!H(t) && this.anchor.is(t.anchor) && this.focus.is(t.focus) && this.format === t.format && this.style === t.style
    );
  }
  isCollapsed() {
    return this.anchor.is(this.focus);
  }
  getNodes() {
    const t = this._cachedNodes;
    if (t !== null) return t;
    const n = (function (r) {
      const i = [],
        [o, s] = r.getTextSlices();
      o && i.push(o.caret.origin);
      const l = new Set(),
        a = new Set();
      for (const u of r)
        if (Kt(u)) {
          const { origin: c } = u;
          i.length === 0 ? l.add(c) : (a.add(c), i.push(c));
        } else {
          const { origin: c } = u;
          (P(c) && a.has(c)) || i.push(c);
        }
      if ((s && i.push(s.caret.origin), Pi(r.focus) && P(r.focus.origin) && r.focus.getNodeAtCaret() === null))
        for (
          let u = an(r.focus.origin, "previous");
          Kt(u) && l.has(u.origin) && !u.origin.isEmpty() && u.origin.is(i[i.length - 1]);
          u = ma(u)
        )
          l.delete(u.origin), i.pop();
      for (; i.length > 1; ) {
        const u = i[i.length - 1];
        if (!P(u) || a.has(u) || u.isEmpty() || l.has(u)) break;
        i.pop();
      }
      if (i.length === 0 && r.isCollapsed()) {
        const u = Pt(r.anchor),
          c = Pt(r.anchor.getFlipped()),
          d = (h) => (Gn(h) ? h.origin : h.getNodeAtCaret()),
          f = d(u) || d(c) || (r.anchor.getNodeAtCaret() ? u.origin : c.origin);
        i.push(f);
      }
      return i;
    })(P0(Hp(this), "next"));
    return cs() || (this._cachedNodes = n), n;
  }
  setTextNodeRange(t, n, r, i) {
    this.anchor.set(t.__key, n, "text"), this.focus.set(r.__key, i, "text");
  }
  getTextContent() {
    const t = this.getNodes();
    if (t.length === 0) return "";
    const n = t[0],
      r = t[t.length - 1],
      i = this.anchor,
      o = this.focus,
      s = i.isBefore(o),
      [l, a] = xc(this);
    let u = "",
      c = !0;
    for (let d = 0; d < t.length; d++) {
      const f = t[d];
      if (P(f) && !f.isInline())
        c ||
          (u += `
`),
          (c = !f.isEmpty());
      else if (((c = !1), Z(f))) {
        let h = f.getTextContent();
        f === n
          ? f === r
            ? (i.type === "element" && o.type === "element" && o.offset !== i.offset) ||
              (h = l < a ? h.slice(l, a) : h.slice(a, l))
            : (h = s ? h.slice(l) : h.slice(a))
          : f === r && (h = s ? h.slice(0, a) : h.slice(0, l)),
          (u += h);
      } else (!Te(f) && !rn(f)) || (f === r && this.isCollapsed()) || (u += f.getTextContent());
    }
    return u;
  }
  applyDOMRange(t) {
    const n = Ge(),
      r = n.getEditorState()._selection,
      i = l0(t.startContainer, t.startOffset, t.endContainer, t.endOffset, n, r);
    if (i === null) return;
    const [o, s] = i;
    this.anchor.set(o.key, o.offset, o.type, !0), this.focus.set(s.key, s.offset, s.type, !0), Kr(this);
  }
  clone() {
    const t = this.anchor,
      n = this.focus;
    return new ii(Tn(t.key, t.offset, t.type), Tn(n.key, n.offset, n.type), this.format, this.style);
  }
  toggleFormat(t) {
    (this.format = El(this.format, t, null)), (this.dirty = !0);
  }
  setStyle(t) {
    (this.style = t), (this.dirty = !0);
  }
  hasFormat(t) {
    const n = Et[t];
    return !!(this.format & n);
  }
  insertRawText(t) {
    const n = t.split(/(\r?\n|\t)/),
      r = [],
      i = n.length;
    for (let o = 0; o < i; o++) {
      const s = n[o];
      s ===
        `
` ||
      s ===
        `\r
`
        ? r.push(sn())
        : s === "	"
          ? r.push(Zi())
          : r.push(Be(s));
    }
    this.insertNodes(r);
  }
  insertText(t) {
    const n = this.anchor,
      r = this.focus,
      i = this.format,
      o = this.style;
    let s = n,
      l = r;
    !this.isCollapsed() && r.isBefore(n) && ((s = r), (l = n)),
      s.type === "element" &&
        (function (x, b, m, v) {
          const _ = x.getNode(),
            k = _.getChildAtIndex(x.offset),
            w = Be(),
            y = ut(_) ? Se().append(w) : w;
          w.setFormat(m),
            w.setStyle(v),
            k === null ? _.append(y) : k.insertBefore(y),
            x.is(b) && b.set(w.__key, 0, "text"),
            x.set(w.__key, 0, "text");
        })(s, l, i, o),
      l.type === "element" && Xr(l, Pt(Yn(l, "next")));
    const a = s.offset;
    let u = l.offset;
    const c = this.getNodes(),
      d = c.length;
    let f = c[0];
    Z(f) || K(26);
    const h = f.getTextContent().length,
      p = f.getParentOrThrow();
    let g = c[d - 1];
    if (
      (d === 1 && l.type === "element" && ((u = h), l.set(s.key, u, "text")),
      this.isCollapsed() &&
        a === h &&
        (Vn(f) || !f.canInsertTextAfter() || (!p.canInsertTextAfter() && f.getNextSibling() === null)))
    ) {
      let x = f.getNextSibling();
      if (
        ((Z(x) && x.canInsertTextBefore() && !Vn(x)) ||
          ((x = Be()), x.setFormat(i), x.setStyle(o), p.canInsertTextAfter() ? f.insertAfter(x) : p.insertAfter(x)),
        x.select(0, 0),
        (f = x),
        t !== "")
      )
        return void this.insertText(t);
    } else if (
      this.isCollapsed() &&
      a === 0 &&
      (Vn(f) || !f.canInsertTextBefore() || (!p.canInsertTextBefore() && f.getPreviousSibling() === null))
    ) {
      let x = f.getPreviousSibling();
      if (
        ((Z(x) && !Vn(x)) ||
          ((x = Be()), x.setFormat(i), p.canInsertTextBefore() ? f.insertBefore(x) : p.insertBefore(x)),
        x.select(),
        (f = x),
        t !== "")
      )
        return void this.insertText(t);
    } else if (f.isSegmented() && a !== h) {
      const x = Be(f.getTextContent());
      x.setFormat(i), f.replace(x), (f = x);
    } else if (!this.isCollapsed() && t !== "") {
      const x = g.getParent();
      if (
        !p.canInsertTextBefore() ||
        !p.canInsertTextAfter() ||
        (P(x) && (!x.canInsertTextBefore() || !x.canInsertTextAfter()))
      )
        return this.insertText(""), s0(this.anchor, this.focus, null), void this.insertText(t);
    }
    if (d === 1) {
      if ($r(f)) {
        const v = Be(t);
        return v.select(), void f.replace(v);
      }
      const x = f.getFormat(),
        b = f.getStyle();
      if (a !== u || (x === i && b === o)) {
        if (ua(f)) {
          const v = Be(t);
          return v.setFormat(i), v.setStyle(o), v.select(), void f.replace(v);
        }
      } else {
        if (f.getTextContent() !== "") {
          const v = Be(t);
          if ((v.setFormat(i), v.setStyle(o), v.select(), a === 0)) f.insertBefore(v, !1);
          else {
            const [_] = f.splitText(a);
            _.insertAfter(v, !1);
          }
          return void (v.isComposing() && this.anchor.type === "text" && (this.anchor.offset -= t.length));
        }
        f.setFormat(i), f.setStyle(o);
      }
      const m = u - a;
      (f = f.spliceText(a, m, t, !0)),
        f.getTextContent() === ""
          ? f.remove()
          : this.anchor.type === "text" &&
            (f.isComposing() ? (this.anchor.offset -= t.length) : ((this.format = x), (this.style = b)));
    } else {
      const x = new Set([...f.getParentKeys(), ...g.getParentKeys()]),
        b = P(f) ? f : f.getParentOrThrow();
      let m = P(g) ? g : g.getParentOrThrow(),
        v = g;
      if (!b.is(m) && m.isInline())
        do (v = m), (m = m.getParentOrThrow());
        while (m.isInline());
      if (
        (l.type === "text" && (u !== 0 || g.getTextContent() === "")) ||
        (l.type === "element" && g.getIndexWithinParent() < u)
      )
        if (Z(g) && !$r(g) && u !== g.getTextContentSize()) {
          if (g.isSegmented()) {
            const S = Be(g.getTextContent());
            g.replace(S), (g = S);
          }
          ut(l.getNode()) || l.type !== "text" || (g = g.spliceText(0, u, "")), x.add(g.__key);
        } else {
          const S = g.getParentOrThrow();
          S.canBeEmpty() || S.getChildrenSize() !== 1 ? g.remove() : S.remove();
        }
      else x.add(g.__key);
      const _ = m.getChildren(),
        k = new Set(c),
        w = b.is(m),
        y = b.isInline() && f.getNextSibling() === null ? b : f;
      for (let S = _.length - 1; S >= 0; S--) {
        const T = _[S];
        if (T.is(f) || (P(T) && T.isParentOf(f))) break;
        T.isAttached() && (!k.has(T) || T.is(v) ? w || y.insertAfter(T, !1) : T.remove());
      }
      if (!w) {
        let S = m,
          T = null;
        for (; S !== null; ) {
          const A = S.getChildren(),
            F = A.length;
          (F === 0 || A[F - 1].is(T)) && (x.delete(S.__key), (T = S)), (S = S.getParent());
        }
      }
      if ($r(f))
        if (a === h) f.select();
        else {
          const S = Be(t);
          S.select(), f.replace(S);
        }
      else
        (f = f.spliceText(a, h - a, t, !0)),
          f.getTextContent() === ""
            ? f.remove()
            : f.isComposing() && this.anchor.type === "text" && (this.anchor.offset -= t.length);
      for (let S = 1; S < d; S++) {
        const T = c[S],
          A = T.__key;
        x.has(A) || T.remove();
      }
    }
  }
  removeText() {
    const t = J() === this;
    tl(this, nw(Hp(this))), t && J() !== this && Ye(this);
  }
  formatText(t, n = null) {
    if (this.isCollapsed()) return this.toggleFormat(t), void ft(null);
    const r = this.getNodes(),
      i = [];
    for (const _ of r) Z(_) && i.push(_);
    const o = (_) => {
        r.forEach((k) => {
          if (P(k)) {
            const w = k.getFormatFlags(t, _);
            k.setTextFormat(w);
          }
        });
      },
      s = i.length;
    if (s === 0) return this.toggleFormat(t), ft(null), void o(n);
    const l = this.anchor,
      a = this.focus,
      u = this.isBackward(),
      c = u ? a : l,
      d = u ? l : a;
    let f = 0,
      h = i[0],
      p = c.type === "element" ? 0 : c.offset;
    if ((c.type === "text" && p === h.getTextContentSize() && ((f = 1), (h = i[1]), (p = 0)), h == null)) return;
    const g = h.getFormatFlags(t, n);
    o(g);
    const x = s - 1;
    let b = i[x];
    const m = d.type === "text" ? d.offset : b.getTextContentSize();
    if (h.is(b)) {
      if (p === m) return;
      if (Vn(h) || (p === 0 && m === h.getTextContentSize())) h.setFormat(g);
      else {
        const _ = h.splitText(p, m),
          k = p === 0 ? _[0] : _[1];
        k.setFormat(g),
          c.type === "text" && c.set(k.__key, 0, "text"),
          d.type === "text" && d.set(k.__key, m - p, "text");
      }
      return void (this.format = g);
    }
    p === 0 || Vn(h) || (([, h] = h.splitText(p)), (p = 0)), h.setFormat(g);
    const v = b.getFormatFlags(t, g);
    m > 0 && (m === b.getTextContentSize() || Vn(b) || ([b] = b.splitText(m)), b.setFormat(v));
    for (let _ = f + 1; _ < x; _++) {
      const k = i[_],
        w = k.getFormatFlags(t, v);
      k.setFormat(w);
    }
    c.type === "text" && c.set(h.__key, p, "text"),
      d.type === "text" && d.set(b.__key, m, "text"),
      (this.format = g | v);
  }
  insertNodes(t) {
    if (t.length === 0) return;
    if ((this.isCollapsed() || this.removeText(), this.anchor.key === "root")) {
      this.insertParagraph();
      const p = J();
      return H(p) || K(134), p.insertNodes(t);
    }
    const n = (this.isBackward() ? this.focus : this.anchor).getNode(),
      r = du(n, Ut),
      i = t[t.length - 1];
    if (P(r) && "__language" in r) {
      if ("__language" in t[0]) this.insertText(t[0].getTextContent());
      else {
        const p = lu(this);
        r.splice(p, 0, t), i.selectEnd();
      }
      return;
    }
    if (!t.some((p) => (P(p) || Te(p)) && !p.isInline())) {
      P(r) || K(211, n.constructor.name, n.getType());
      const p = lu(this);
      return r.splice(p, 0, t), void i.selectEnd();
    }
    const o = (function (p) {
        const g = Se();
        let x = null;
        for (let b = 0; b < p.length; b++) {
          const m = p[b],
            v = rn(m);
          if (v || (Te(m) && m.isInline()) || (P(m) && m.isInline()) || Z(m) || m.isParentRequired()) {
            if (x === null && ((x = m.createParentElementNode()), g.append(x), v)) continue;
            x !== null && x.append(m);
          } else g.append(m), (x = null);
        }
        return g;
      })(t),
      s = o.getLastDescendant(),
      l = o.getChildren(),
      a = !P(r) || !r.isEmpty() ? this.insertParagraph() : null,
      u = l[l.length - 1];
    let c = l[0];
    var d;
    P((d = c)) &&
      Ut(d) &&
      !d.isEmpty() &&
      P(r) &&
      (!r.isEmpty() || r.canMergeWhenEmpty()) &&
      (P(r) || K(211, n.constructor.name, n.getType()), r.append(...c.getChildren()), (c = l[1])),
      c &&
        (r === null && K(212, n.constructor.name, n.getType()),
        (function (p, g, x) {
          const b = g.getParentOrThrow().getLastChild();
          let m = g;
          const v = [g];
          for (; m !== b; ) m.getNextSibling() || K(140), (m = m.getNextSibling()), v.push(m);
          let _ = p;
          for (const k of v) _ = _.insertAfter(k);
        })(r, c));
    const f = du(s, Ut);
    a && P(f) && (a.canMergeWhenEmpty() || Ut(u)) && (f.append(...a.getChildren()), a.remove()),
      P(r) && r.isEmpty() && r.remove(),
      s.selectEnd();
    const h = P(r) ? r.getLastChild() : null;
    rn(h) && f !== r && h.remove();
  }
  insertParagraph() {
    if (this.anchor.key === "root") {
      const s = Se();
      return Ce().splice(this.anchor.offset, 0, [s]), s.select(), s;
    }
    const t = lu(this),
      n = du(this.anchor.getNode(), Ut);
    P(n) || K(213);
    const r = n.getChildAtIndex(t),
      i = r ? [r, ...r.getNextSiblings()] : [],
      o = n.insertNewAfter(this, !1);
    return o ? (o.append(...i), o.selectStart(), o) : null;
  }
  insertLineBreak(t) {
    const n = sn();
    if ((this.insertNodes([n]), t)) {
      const r = n.getParentOrThrow(),
        i = n.getIndexWithinParent();
      r.select(i, i);
    }
  }
  extract() {
    const t = this.getNodes(),
      n = t.length,
      r = n - 1,
      i = this.anchor,
      o = this.focus;
    let s = t[0],
      l = t[r];
    const [a, u] = xc(this);
    if (n === 0) return [];
    if (n === 1) {
      if (Z(s) && !this.isCollapsed()) {
        const d = a > u ? u : a,
          f = a > u ? a : u,
          h = s.splitText(d, f),
          p = d === 0 ? h[0] : h[1];
        return p != null ? [p] : [];
      }
      return [s];
    }
    const c = i.isBefore(o);
    if (Z(s)) {
      const d = c ? a : u;
      d === s.getTextContentSize() ? t.shift() : d !== 0 && (([, s] = s.splitText(d)), (t[0] = s));
    }
    if (Z(l)) {
      const d = l.getTextContent().length,
        f = c ? u : a;
      f === 0 ? t.pop() : f !== d && (([l] = l.splitText(f)), (t[r] = l));
    }
    return t;
  }
  modify(t, n, r) {
    if (Cp(this, t, n, r)) return;
    const i = t === "move",
      o = Ge(),
      s = ln(Jt(o));
    if (!s) return;
    const l = o._blockCursorElement,
      a = o._rootElement,
      u = this.focus.getNode();
    if ((a === null || l === null || !P(u) || u.isInline() || u.canBeEmpty() || yc(l, o, a), this.dirty)) {
      let c = Ri(o, this.anchor.key),
        d = Ri(o, this.focus.key);
      this.anchor.type === "text" && (c = Fi(c)),
        this.focus.type === "text" && (d = Fi(d)),
        c && d && u0(s, c, this.anchor.offset, d, this.focus.offset);
    }
    if (
      ((function (c, d, f, h) {
        c.modify(d, f, h);
      })(s, t, n ? "backward" : "forward", r),
      s.rangeCount > 0)
    ) {
      const c = s.getRangeAt(0),
        d = this.anchor.getNode(),
        f = ut(d) ? d : j_(d);
      if ((this.applyDOMRange(c), (this.dirty = !0), !i)) {
        const h = this.getNodes(),
          p = [];
        let g = !1;
        for (let x = 0; x < h.length; x++) {
          const b = h[x];
          bc(b, f) ? p.push(b) : (g = !0);
        }
        if (g && p.length > 0)
          if (n) {
            const x = p[0];
            P(x) ? x.selectStart() : x.getParentOrThrow().selectStart();
          } else {
            const x = p[p.length - 1];
            P(x) ? x.selectEnd() : x.getParentOrThrow().selectEnd();
          }
        (s.anchorNode === c.startContainer && s.anchorOffset === c.startOffset) ||
          (function (x) {
            const b = x.focus,
              m = x.anchor,
              v = m.key,
              _ = m.offset,
              k = m.type;
            m.set(b.key, b.offset, b.type, !0), b.set(v, _, k, !0);
          })(this);
      }
    }
    r === "lineboundary" && Cp(this, t, n, r, "decorators");
  }
  forwardDeletion(t, n, r) {
    if (
      !r &&
      ((t.type === "element" && P(n) && t.offset === n.getChildrenSize()) ||
        (t.type === "text" && t.offset === n.getTextContentSize()))
    ) {
      const i = n.getParent(),
        o = n.getNextSibling() || (i === null ? null : i.getNextSibling());
      if (P(o) && o.isShadowRoot()) return !0;
    }
    return !1;
  }
  deleteCharacter(t) {
    const n = this.isCollapsed();
    if (this.isCollapsed()) {
      const r = this.anchor;
      let i = r.getNode();
      if (this.forwardDeletion(r, i, t)) return;
      const o = vf(Yn(r, t ? "previous" : "next"));
      if (o.getTextSlices().every((l) => l === null || l.distance === 0)) {
        let l = { type: "initial" };
        for (const a of o.iterNodeCarets("shadowRoot"))
          if (Kt(a)) {
            if (!a.origin.isInline()) {
              if (a.origin.isShadowRoot()) {
                if (l.type === "merge-block") break;
                if (P(o.anchor.origin) && o.anchor.origin.isEmpty()) {
                  const u = Pt(a);
                  tl(this, Yr(u, u)), o.anchor.origin.remove();
                }
                return;
              }
              (l.type !== "merge-next-block" && l.type !== "merge-block") ||
                (l = { block: l.block, caret: a, type: "merge-block" });
            }
          } else {
            if (l.type === "merge-block") break;
            if (Pi(a)) {
              if (P(a.origin)) {
                if (a.origin.isInline()) {
                  if (!a.origin.isParentOf(o.anchor.origin)) break;
                } else l = { block: a.origin, type: "merge-next-block" };
                continue;
              }
              if (Te(a.origin)) {
                if (!a.origin.isIsolated())
                  if (
                    l.type === "merge-next-block" &&
                    (a.origin.isKeyboardSelectable() || !a.origin.isInline()) &&
                    P(o.anchor.origin) &&
                    o.anchor.origin.isEmpty()
                  ) {
                    o.anchor.origin.remove();
                    const u = qd();
                    u.add(a.origin.getKey()), Ye(u);
                  } else a.origin.remove();
                return;
              }
              break;
            }
          }
        if (l.type === "merge-block") {
          const { caret: a, block: u } = l;
          return (
            tl(this, Yr(!a.origin.isEmpty() && u.isEmpty() ? ps(nt(u, a.direction)) : o.anchor, a)), this.removeText()
          );
        }
      }
      const s = this.focus;
      if ((this.modify("extend", t, "character"), this.isCollapsed())) {
        if (t && r.offset === 0 && gp(this, r.getNode())) return;
      } else {
        const l = s.type === "text" ? s.getNode() : null;
        if (((i = r.type === "text" ? r.getNode() : null), l !== null && l.isSegmented())) {
          const a = s.offset,
            u = l.getTextContentSize();
          if (l.is(i) || (t && a !== u) || (!t && a !== 0)) return void mp(l, t, a);
        } else if (i !== null && i.isSegmented()) {
          const a = r.offset,
            u = i.getTextContentSize();
          if (i.is(l) || (t && a !== 0) || (!t && a !== u)) return void mp(i, t, a);
        }
        (function (a, u) {
          const c = a.anchor,
            d = a.focus,
            f = c.getNode(),
            h = d.getNode();
          if (f === h && c.type === "text" && d.type === "text") {
            const p = c.offset,
              g = d.offset,
              x = p < g,
              b = x ? p : g,
              m = x ? g : p,
              v = m - 1;
            b !== v &&
              (function (_) {
                return !(_0(_) || T_(_));
              })(f.getTextContent().slice(b, m)) &&
              (u ? d.set(d.key, v, d.type) : c.set(c.key, v, c.type));
          }
        })(this, t);
      }
    }
    if (
      (this.removeText(), t && !n && this.isCollapsed() && this.anchor.type === "element" && this.anchor.offset === 0)
    ) {
      const r = this.anchor.getNode();
      r.isEmpty() && ut(r.getParent()) && r.getPreviousSibling() === null && gp(this, r);
    }
  }
  deleteLine(t) {
    this.isCollapsed() && this.modify("extend", t, "lineboundary"),
      this.isCollapsed() ? this.deleteCharacter(t) : this.removeText();
  }
  deleteWord(t) {
    if (this.isCollapsed()) {
      const n = this.anchor,
        r = n.getNode();
      if (this.forwardDeletion(n, r, t)) return;
      this.modify("extend", t, "word");
    }
    this.removeText();
  }
  isBackward() {
    return this.focus.isBefore(this.anchor);
  }
  getStartEndPoints() {
    return [this.anchor, this.focus];
  }
}
function Je(e) {
  return e instanceof ca;
}
function pp(e) {
  const t = e.offset;
  if (e.type === "text") return t;
  const n = e.getNode();
  return t === n.getChildrenSize() ? n.getTextContent().length : 0;
}
function xc(e) {
  const t = e.getStartEndPoints();
  if (t === null) return [0, 0];
  const [n, r] = t;
  return n.type === "element" && r.type === "element" && n.key === r.key && n.offset === r.offset
    ? [0, 0]
    : [pp(n), pp(r)];
}
function gp(e, t) {
  for (let n = t; n; n = n.getParent()) {
    if (P(n)) {
      if (n.collapseAtStart(e)) return !0;
      if (tt(n)) break;
    }
    if (n.getPreviousSibling()) break;
  }
  return !1;
}
const T_ = (() => {
  try {
    const e = new RegExp("\\p{Emoji}", "u"),
      t = e.test.bind(e);
    if (t("❤️") && t("#️⃣") && t("👍")) return t;
  } catch {}
  return () => !1;
})();
function mp(e, t, n) {
  const r = e,
    i = r.getTextContent().split(/(?=\s)/g),
    o = i.length;
  let s = 0,
    l = 0;
  for (let u = 0; u < o; u++) {
    const c = u === o - 1;
    if (((l = s), (s += i[u].length), (t && s === n) || s > n || c)) {
      i.splice(u, 1), c && (l = void 0);
      break;
    }
  }
  const a = i.join("").trim();
  a === "" ? r.remove() : (r.setTextContent(a), r.select(l, l));
}
function xp(e, t, n, r) {
  let i,
    o = t;
  if (We(e)) {
    let s = !1;
    const l = e.childNodes,
      a = l.length,
      u = r._blockCursorElement;
    o === a && ((s = !0), (o = a - 1));
    let c = l[o],
      d = !1;
    if (c === u) (c = l[o + 1]), (d = !0);
    else if (u !== null) {
      const f = u.parentNode;
      e === f && t > Array.prototype.indexOf.call(f.children, u) && o--;
    }
    if (((i = Ci(c)), Z(i))) o = Lp(i, s);
    else {
      let f = Ci(e);
      if (f === null) return null;
      if (P(f)) {
        const h = r.getElementByKey(f.getKey());
        h === null && K(214),
          ([f, o] = f.getDOMSlot(h).resolveChildIndex(f, h, e, t)),
          P(f) || K(215),
          s && o >= f.getChildrenSize() && (o = Math.max(0, f.getChildrenSize() - 1));
        let g = f.getChildAtIndex(o);
        if (
          P(g) &&
          (function (x, b, m) {
            const v = x.getParent();
            return m === null || v === null || !v.canBeEmpty() || v !== m.getNode();
          })(g, 0, n)
        ) {
          const x = s ? g.getLastDescendant() : g.getFirstDescendant();
          x === null ? (f = g) : ((g = x), (f = P(g) ? g : g.getParentOrThrow())), (o = 0);
        }
        Z(g)
          ? ((i = g), (f = null), (o = Lp(g, s)))
          : g !== f && s && !d && (P(f) || K(216), (o = Math.min(f.getChildrenSize(), o + 1)));
      } else {
        const h = f.getIndexWithinParent();
        (o = t === 0 && Te(f) && Ci(e) === f ? h : h + 1), (f = f.getParentOrThrow());
      }
      if (P(f)) return Tn(f.__key, o, "element");
    }
  } else i = Ci(e);
  return Z(i) ? Tn(i.__key, o, "text") : null;
}
function vp(e, t, n) {
  const r = e.offset,
    i = e.getNode();
  if (r === 0) {
    const o = i.getPreviousSibling(),
      s = i.getParent();
    if (t) {
      if ((n || !t) && o === null && P(s) && s.isInline()) {
        const l = s.getPreviousSibling();
        Z(l) && e.set(l.__key, l.getTextContent().length, "text");
      }
    } else
      P(o) && !n && o.isInline()
        ? e.set(o.__key, o.getChildrenSize(), "element")
        : Z(o) && e.set(o.__key, o.getTextContent().length, "text");
  } else if (r === i.getTextContent().length) {
    const o = i.getNextSibling(),
      s = i.getParent();
    if (t && P(o) && o.isInline()) e.set(o.__key, 0, "element");
    else if ((n || t) && o === null && P(s) && s.isInline() && !s.canInsertTextAfter()) {
      const l = s.getNextSibling();
      Z(l) && e.set(l.__key, 0, "text");
    }
  }
}
function s0(e, t, n) {
  if (e.type === "text" && t.type === "text") {
    const r = e.isBefore(t),
      i = e.is(t);
    vp(e, r, i), vp(t, !r, i), i && t.set(e.key, e.offset, e.type);
    const o = Ge();
    if (o.isComposing() && o._compositionKey !== e.key && H(n)) {
      const s = n.anchor,
        l = n.focus;
      e.set(s.key, s.offset, s.type, !0), t.set(l.key, l.offset, l.type, !0);
    }
  }
}
function l0(e, t, n, r, i, o) {
  if (e === null || n === null || !fs(i, e, n)) return null;
  const s = xp(e, t, H(o) ? o.anchor : null, i);
  if (s === null) return null;
  const l = xp(n, r, H(o) ? o.focus : null, i);
  if (l === null) return null;
  if (s.type === "element" && l.type === "element") {
    const a = Ci(e),
      u = Ci(n);
    if (Te(a) && Te(u)) return null;
  }
  return s0(s, l, o), [s, l];
}
function bl(e) {
  return P(e) && !e.isInline();
}
function a0(e, t, n, r, i, o) {
  const s = yr(),
    l = new ii(Tn(e, t, i), Tn(n, r, o), 0, "");
  return (l.dirty = !0), (s._selection = l), l;
}
function qi() {
  const e = Tn("root", 0, "element"),
    t = Tn("root", 0, "element");
  return new ii(e, t, 0, "");
}
function qd() {
  return new ca(new Set());
}
function Yd(e, t, n, r) {
  const i = n._window;
  if (i === null) return null;
  const o = r || i.event,
    s = o ? o.type : void 0,
    l = s === "selectionchange",
    a =
      !nc &&
      (l ||
        s === "beforeinput" ||
        s === "compositionstart" ||
        s === "compositionend" ||
        (s === "click" && o && o.detail === 3) ||
        s === "drop" ||
        s === void 0);
  let u, c, d, f;
  if (H(e) && !a) return e.clone();
  if (t === null) return null;
  if (((u = t.anchorNode), (c = t.focusNode), (d = t.anchorOffset), (f = t.focusOffset), l && H(e) && !fs(n, u, c)))
    return e.clone();
  const h = l0(u, d, c, f, n, e);
  if (h === null) return null;
  const [p, g] = h;
  return new ii(p, g, H(e) ? e.format : 0, H(e) ? e.style : "");
}
function J() {
  return yr()._selection;
}
function oi() {
  return Ge()._editorState._selection;
}
function yl(e, t, n, r = 1) {
  const i = e.anchor,
    o = e.focus,
    s = i.getNode(),
    l = o.getNode();
  if (!t.is(s) && !t.is(l)) return;
  const a = t.__key;
  if (e.isCollapsed()) {
    const u = i.offset;
    if ((n <= u && r > 0) || (n < u && r < 0)) {
      const c = Math.max(0, u + r);
      i.set(a, c, "element"), o.set(a, c, "element"), bp(e);
    }
  } else {
    const u = e.isBackward(),
      c = u ? o : i,
      d = c.getNode(),
      f = u ? i : o,
      h = f.getNode();
    if (t.is(d)) {
      const p = c.offset;
      ((n <= p && r > 0) || (n < p && r < 0)) && c.set(a, Math.max(0, p + r), "element");
    }
    if (t.is(h)) {
      const p = f.offset;
      ((n <= p && r > 0) || (n < p && r < 0)) && f.set(a, Math.max(0, p + r), "element");
    }
  }
  bp(e);
}
function bp(e) {
  const t = e.anchor,
    n = t.offset,
    r = e.focus,
    i = r.offset,
    o = t.getNode(),
    s = r.getNode();
  if (e.isCollapsed()) {
    if (!P(o)) return;
    const l = o.getChildrenSize(),
      a = n >= l,
      u = a ? o.getChildAtIndex(l - 1) : o.getChildAtIndex(n);
    if (Z(u)) {
      let c = 0;
      a && (c = u.getTextContentSize()), t.set(u.__key, c, "text"), r.set(u.__key, c, "text");
    }
  } else {
    if (P(o)) {
      const l = o.getChildrenSize(),
        a = n >= l,
        u = a ? o.getChildAtIndex(l - 1) : o.getChildAtIndex(n);
      if (Z(u)) {
        let c = 0;
        a && (c = u.getTextContentSize()), t.set(u.__key, c, "text");
      }
    }
    if (P(s)) {
      const l = s.getChildrenSize(),
        a = i >= l,
        u = a ? s.getChildAtIndex(l - 1) : s.getChildAtIndex(i);
      if (Z(u)) {
        let c = 0;
        a && (c = u.getTextContentSize()), r.set(u.__key, c, "text");
      }
    }
  }
}
function Cl(e, t, n, r, i) {
  let o = null,
    s = 0,
    l = null;
  r !== null
    ? ((o = r.__key),
      Z(r) ? ((s = r.getTextContentSize()), (l = "text")) : P(r) && ((s = r.getChildrenSize()), (l = "element")))
    : i !== null && ((o = i.__key), Z(i) ? (l = "text") : P(i) && (l = "element")),
    o !== null && l !== null
      ? e.set(o, s, l)
      : ((s = t.getIndexWithinParent()), s === -1 && (s = n.getChildrenSize()), e.set(n.__key, s, "element"));
}
function yp(e, t, n, r, i) {
  e.type === "text"
    ? e.set(n, e.offset + (t ? 0 : i), "text")
    : e.offset > r.getIndexWithinParent() && e.set(e.key, e.offset - 1, "element");
}
function u0(e, t, n, r, i) {
  try {
    e.setBaseAndExtent(t, n, r, i);
  } catch {}
}
function A_(e, t, n, r, i, o, s) {
  const l = r.anchorNode,
    a = r.focusNode,
    u = r.anchorOffset,
    c = r.focusOffset,
    d = document.activeElement;
  if ((i.has(g0) && d !== o) || (d !== null && of(d))) return;
  if (!H(t)) return void (e !== null && fs(n, l, a) && r.removeAllRanges());
  const f = t.anchor,
    h = t.focus,
    p = f.key,
    g = h.key,
    x = Ri(n, p),
    b = Ri(n, g),
    m = f.offset,
    v = h.offset,
    _ = t.format,
    k = t.style,
    w = t.isCollapsed();
  let y = x,
    S = b,
    T = !1;
  if (f.type === "text") {
    y = Fi(x);
    const N = f.getNode();
    T = N.getFormat() !== _ || N.getStyle() !== k;
  } else H(e) && e.anchor.type === "text" && (T = !0);
  var A, F, R, V, B;
  if (
    (h.type === "text" && (S = Fi(b)),
    y !== null &&
      S !== null &&
      (w &&
        (e === null || T || (H(e) && (e.format !== _ || e.style !== k))) &&
        ((A = _), (F = k), (R = m), (V = p), (B = performance.now()), (X1 = [A, F, R, V, B])),
      u !== m ||
        c !== v ||
        l !== y ||
        a !== S ||
        (r.type === "Range" && w) ||
        ((d !== null && o.contains(d)) || o.focus({ preventScroll: !0 }), f.type === "element")))
  ) {
    if ((u0(r, y, m, S, v), !i.has(F_) && t.isCollapsed() && o !== null && o === document.activeElement)) {
      const N =
        H(t) && t.anchor.type === "element" ? y.childNodes[m] || null : r.rangeCount > 0 ? r.getRangeAt(0) : null;
      if (N !== null) {
        let G;
        if (N instanceof Text) {
          const U = document.createRange();
          U.selectNode(N), (G = U.getBoundingClientRect());
        } else G = N.getBoundingClientRect();
        (function (U, X, te) {
          const L = S0(te),
            se = ff(L);
          if (L === null || se === null) return;
          let { top: pe, bottom: M } = X,
            me = 0,
            Ee = 0,
            ce = te;
          for (; ce !== null; ) {
            const z = ce === L.body;
            if (z) (me = 0), (Ee = Jt(U).innerHeight);
            else {
              const Y = ce.getBoundingClientRect();
              (me = Y.top), (Ee = Y.bottom);
            }
            let W = 0;
            if ((pe < me ? (W = -(me - pe)) : M > Ee && (W = M - Ee), W !== 0))
              if (z) se.scrollBy(0, W);
              else {
                const Y = ce.scrollTop;
                ce.scrollTop += W;
                const Q = ce.scrollTop - Y;
                (pe -= Q), (M -= Q);
              }
            if (z) break;
            ce = hs(ce);
          }
        })(n, G, o);
      }
    }
    pc = !0;
  }
}
function Yi(e) {
  let t = J() || oi();
  t === null && (t = Ce().selectEnd()), t.insertNodes(e);
}
function lu(e) {
  let t = e;
  e.isCollapsed() || t.removeText();
  const n = J();
  H(n) && (t = n), H(t) || K(161);
  const r = t.anchor;
  let i = r.getNode(),
    o = r.offset;
  for (; !Ut(i); ) {
    const s = i;
    if ((([i, o] = I_(i, o)), s.is(i))) break;
  }
  return o;
}
function I_(e, t) {
  const n = e.getParent();
  if (!n) {
    const i = Se();
    return Ce().append(i), i.select(), [Ce(), 0];
  }
  if (Z(e)) {
    const i = e.splitText(t);
    if (i.length === 0) return [n, e.getIndexWithinParent()];
    const o = t === 0 ? 0 : 1;
    return [n, i[0].getIndexWithinParent() + o];
  }
  if (!P(e) || t === 0) return [n, e.getIndexWithinParent()];
  const r = e.getChildAtIndex(t);
  if (r) {
    const i = new ii(Tn(e.__key, t, "element"), Tn(e.__key, t, "element"), 0, ""),
      o = e.insertNewAfter(i);
    o && o.append(r, ...r.getNextSiblings());
  }
  return [n, e.getIndexWithinParent() + 1];
}
function Cp(e, t, n, r, i = "decorators-and-blocks") {
  if (t === "move" && r === "character" && !e.isCollapsed()) {
    const [c, d] = n === e.isBackward() ? [e.focus, e.anchor] : [e.anchor, e.focus];
    return d.set(c.key, c.offset, c.type), !0;
  }
  const o = Yn(e.focus, n ? "previous" : "next"),
    s = r === "lineboundary",
    l = t === "move";
  let a = o,
    u = i === "decorators-and-blocks";
  if (!R0(a)) {
    for (const c of a) {
      u = !1;
      const { origin: d } = c;
      if (!Te(d) || d.isIsolated() || ((a = c), !s || !d.isInline())) break;
    }
    if (u)
      for (const c of vf(o).iterNodeCarets(t === "extend" ? "shadowRoot" : "root")) {
        if (Kt(c)) c.origin.isInline() || (a = c);
        else {
          if (P(c.origin)) continue;
          Te(c.origin) && !c.origin.isInline() && (a = c);
        }
        break;
      }
  }
  if (a === o) return !1;
  if (l && !s && Te(a.origin) && a.origin.isKeyboardSelectable()) {
    const c = qd();
    return c.add(a.origin.getKey()), Ye(c), !0;
  }
  return (a = Pt(a)), l && Xr(e.anchor, a), Xr(e.focus, a), u || !s;
}
let lt = null,
  at = null,
  Lt = !1,
  au = !1,
  Xs = 0;
const _p = { characterData: !0, childList: !0, subtree: !0 };
function cs() {
  return Lt || (lt !== null && lt._readOnly);
}
function pt() {
  Lt && K(13);
}
function c0() {
  Xs > 99 && K(14);
}
function yr() {
  return lt === null && K(195, d0()), lt;
}
function Ge() {
  return at === null && K(196, d0()), at;
}
function d0() {
  let e = 0;
  const t = new Set(),
    n = fa.version;
  if (typeof window < "u")
    for (const i of document.querySelectorAll("[contenteditable]")) {
      const o = ha(i);
      if (sf(o)) e++;
      else if (o) {
        let s = String(o.constructor.version || "<0.17.1");
        s === n && (s += " (separately built, likely a bundler configuration issue)"), t.add(s);
      }
    }
  let r = ` Detected on the page: ${e} compatible editor(s) with version ${n}`;
  return t.size && (r += ` and incompatible editors with versions ${Array.from(t).join(", ")}`), r;
}
function N_() {
  return at;
}
function wp(e, t, n) {
  const r = t.__type,
    i = (function (l, a) {
      const u = l._nodes.get(a);
      return u === void 0 && K(30, a), u;
    })(e, r);
  let o = n.get(r);
  o === void 0 && ((o = Array.from(i.transforms)), n.set(r, o));
  const s = o.length;
  for (let l = 0; l < s && (o[l](t), t.isAttached()); l++);
}
function Ep(e, t) {
  return e !== void 0 && e.__key !== t && e.isAttached();
}
function f0(e, t) {
  if (!t) return;
  const n = e._updateTags;
  let r = t;
  Array.isArray(t) || (r = [t]);
  for (const i of r) n.add(i);
}
function L_(e) {
  return Xd(e, Ge()._nodes);
}
function Xd(e, t) {
  const n = e.type,
    r = t.get(n);
  r === void 0 && K(17, n);
  const i = r.klass;
  e.type !== i.getType() && K(18, i.name);
  const o = i.importJSON(e),
    s = e.children;
  if (P(o) && Array.isArray(s))
    for (let l = 0; l < s.length; l++) {
      const a = Xd(s[l], t);
      o.append(a);
    }
  return o;
}
function kp(e, t, n) {
  const r = lt,
    i = Lt,
    o = at;
  (lt = t), (Lt = !0), (at = e);
  try {
    return n();
  } finally {
    (lt = r), (Lt = i), (at = o);
  }
}
function jn(e, t) {
  const n = e._pendingEditorState,
    r = e._rootElement,
    i = e._headless || r === null;
  if (n === null) return;
  const o = e._editorState,
    s = o._selection,
    l = n._selection,
    a = e._dirtyType !== Wr,
    u = lt,
    c = Lt,
    d = at,
    f = e._updating,
    h = e._observer;
  let p = null;
  if (((e._pendingEditorState = null), (e._editorState = n), !i && a && h !== null)) {
    (at = e), (lt = n), (Lt = !1), (e._updating = !0);
    try {
      const w = e._dirtyType,
        y = e._dirtyElements,
        S = e._dirtyLeaves;
      h.disconnect(), (p = c_(o, n, e, w, y, S));
    } catch (w) {
      if ((w instanceof Error && e._onError(w), au)) throw w;
      return m0(e, null, r, n), B1(e), (e._dirtyType = Mi), (au = !0), jn(e, o), void (au = !1);
    } finally {
      h.observe(r, _p), (e._updating = f), (lt = u), (Lt = c), (at = d);
    }
  }
  n._readOnly || (n._readOnly = !0);
  const g = e._dirtyLeaves,
    x = e._dirtyElements,
    b = e._normalizedNodes,
    m = e._updateTags,
    v = e._deferred;
  a &&
    ((e._dirtyType = Wr),
    e._cloneNotNeeded.clear(),
    (e._dirtyLeaves = new Set()),
    (e._dirtyElements = new Map()),
    (e._normalizedNodes = new Set()),
    (e._updateTags = new Set())),
    (function (w, y) {
      const S = w._decorators;
      let T = w._pendingDecorators || S;
      const A = y._nodeMap;
      let F;
      for (F in T) A.has(F) || (T === S && (T = y0(w)), delete T[F]);
    })(e, n);
  const _ = i ? null : ln(Jt(e));
  if (e._editable && _ !== null && (a || l === null || l.dirty) && r !== null && !m.has(R_)) {
    (at = e), (lt = n);
    try {
      if ((h !== null && h.disconnect(), a || l === null || l.dirty)) {
        const w = e._blockCursorElement;
        w !== null && yc(w, e, r), A_(s, l, e, _, m, r);
      }
      (function (w, y, S) {
        let T = w._blockCursorElement;
        if (H(S) && S.isCollapsed() && S.anchor.type === "element" && y.contains(document.activeElement)) {
          const A = S.anchor,
            F = A.getNode(),
            R = A.offset;
          let V = !1,
            B = null;
          if (R === F.getChildrenSize()) cu(F.getChildAtIndex(R - 1)) && (V = !0);
          else {
            const N = F.getChildAtIndex(R);
            if (N !== null && cu(N)) {
              const G = N.getPreviousSibling();
              (G === null || cu(G)) && ((V = !0), (B = w.getElementByKey(N.__key)));
            }
          }
          if (V) {
            const N = w.getElementByKey(F.__key);
            return (
              T === null &&
                (w._blockCursorElement = T =
                  (function (G) {
                    const U = G.theme,
                      X = document.createElement("div");
                    (X.contentEditable = "false"), X.setAttribute("data-lexical-cursor", "true");
                    let te = U.blockCursor;
                    if (te !== void 0) {
                      if (typeof te == "string") {
                        const L = dl(te);
                        te = U.blockCursor = L;
                      }
                      te !== void 0 && X.classList.add(...te);
                    }
                    return X;
                  })(w._config)),
              (y.style.caretColor = "transparent"),
              void (B === null ? N.appendChild(T) : N.insertBefore(T, B))
            );
          }
        }
        T !== null && yc(T, w, y);
      })(e, r, l);
    } finally {
      h !== null && h.observe(r, _p), (at = d), (lt = u);
    }
  }
  p !== null &&
    (function (w, y, S, T, A) {
      const F = Array.from(w._listeners.mutation),
        R = F.length;
      for (let V = 0; V < R; V++) {
        const [B, N] = F[V],
          G = y.get(N);
        G !== void 0 && B(G, { dirtyLeaves: T, prevEditorState: A, updateTags: S });
      }
    })(e, p, m, g, o),
    H(l) || l === null || (s !== null && s.is(l)) || e.dispatchCommand(os, void 0);
  const k = e._pendingDecorators;
  k !== null && ((e._decorators = k), (e._pendingDecorators = null), Ao("decorator", e, !0, k)),
    (function (w, y, S) {
      const T = Np(y),
        A = Np(S);
      T !== A && Ao("textcontent", w, !0, A);
    })(e, t || o, n),
    Ao("update", e, !0, {
      dirtyElements: x,
      dirtyLeaves: g,
      editorState: n,
      mutatedNodes: p,
      normalizedNodes: b,
      prevEditorState: t || o,
      tags: m,
    }),
    (function (w, y) {
      if (((w._deferred = []), y.length !== 0)) {
        const S = w._updating;
        w._updating = !0;
        try {
          for (let T = 0; T < y.length; T++) y[T]();
        } finally {
          w._updating = S;
        }
      }
    })(e, v),
    (function (w) {
      const y = w._updates;
      if (y.length !== 0) {
        const S = y.shift();
        if (S) {
          const [T, A] = S;
          Qd(w, T, A);
        }
      }
    })(e);
}
function Ao(e, t, n, ...r) {
  const i = t._updating;
  t._updating = n;
  try {
    const o = Array.from(t._listeners[e]);
    for (let s = 0; s < o.length; s++) o[s].apply(null, r);
  } finally {
    t._updating = i;
  }
}
function Sp(e, t) {
  const n = e._updates;
  let r = t || !1;
  for (; n.length !== 0; ) {
    const i = n.shift();
    if (i) {
      const [o, s] = i;
      let l;
      if (s !== void 0) {
        if (((l = s.onUpdate), s.skipTransforms && (r = !0), s.discrete)) {
          const a = e._pendingEditorState;
          a === null && K(191), (a._flushSync = !0);
        }
        l && e._deferred.push(l), f0(e, s.tag);
      }
      o();
    }
  }
  return r;
}
function Qd(e, t, n) {
  const r = e._updateTags;
  let i,
    o = !1,
    s = !1;
  n !== void 0 && ((i = n.onUpdate), f0(e, n.tag), (o = n.skipTransforms || !1), (s = n.discrete || !1)),
    i && e._deferred.push(i);
  const l = e._editorState;
  let a = e._pendingEditorState,
    u = !1;
  (a === null || a._readOnly) && ((a = e._pendingEditorState = h0(a || l)), (u = !0)), (a._flushSync = s);
  const c = lt,
    d = Lt,
    f = at,
    h = e._updating;
  (lt = a), (Lt = !1), (e._updating = !0), (at = e);
  const p = e._headless || e.getRootElement() === null;
  try {
    u &&
      (p
        ? l._selection !== null && (a._selection = l._selection.clone())
        : (a._selection = (function (m, v) {
            const _ = m.getEditorState()._selection,
              k = ln(Jt(m));
            return H(_) || _ == null ? Yd(_, k, m, v) : _.clone();
          })(e, (n && n.event) || null)));
    const x = e._compositionKey;
    t(),
      (o = Sp(e, o)),
      (function (m, v) {
        const _ = v.getEditorState()._selection,
          k = m._selection;
        if (H(k)) {
          const w = k.anchor,
            y = k.focus;
          let S;
          if ((w.type === "text" && ((S = w.getNode()), S.selectionTransform(_, k)), y.type === "text")) {
            const T = y.getNode();
            S !== T && T.selectionTransform(_, k);
          }
        }
      })(a, e),
      e._dirtyType !== Wr &&
        (o
          ? (function (m, v) {
              const _ = v._dirtyLeaves,
                k = m._nodeMap;
              for (const w of _) {
                const y = k.get(w);
                Z(y) && y.isAttached() && y.isSimpleText() && !y.isUnmergeable() && rp(y);
              }
            })(a, e)
          : (function (m, v) {
              const _ = v._dirtyLeaves,
                k = v._dirtyElements,
                w = m._nodeMap,
                y = cr(),
                S = new Map();
              let T = _,
                A = T.size,
                F = k,
                R = F.size;
              for (; A > 0 || R > 0; ) {
                if (A > 0) {
                  v._dirtyLeaves = new Set();
                  for (const V of T) {
                    const B = w.get(V);
                    Z(B) && B.isAttached() && B.isSimpleText() && !B.isUnmergeable() && rp(B),
                      B !== void 0 && Ep(B, y) && wp(v, B, S),
                      _.add(V);
                  }
                  if (((T = v._dirtyLeaves), (A = T.size), A > 0)) {
                    Xs++;
                    continue;
                  }
                }
                (v._dirtyLeaves = new Set()), (v._dirtyElements = new Map()), F.delete("root") && F.set("root", !0);
                for (const V of F) {
                  const B = V[0],
                    N = V[1];
                  if ((k.set(B, N), !N)) continue;
                  const G = w.get(B);
                  G !== void 0 && Ep(G, y) && wp(v, G, S);
                }
                (T = v._dirtyLeaves), (A = T.size), (F = v._dirtyElements), (R = F.size), Xs++;
              }
              (v._dirtyLeaves = _), (v._dirtyElements = k);
            })(a, e),
        Sp(e),
        (function (m, v, _, k) {
          const w = m._nodeMap,
            y = v._nodeMap,
            S = [];
          for (const [T] of k) {
            const A = y.get(T);
            A !== void 0 && (A.isAttached() || (P(A) && P1(A, T, w, y, S, k), w.has(T) || k.delete(T), S.push(T)));
          }
          for (const T of S) y.delete(T);
          for (const T of _) {
            const A = y.get(T);
            A === void 0 || A.isAttached() || (w.has(T) || _.delete(T), y.delete(T));
          }
        })(l, a, e._dirtyLeaves, e._dirtyElements)),
      x !== e._compositionKey && (a._flushSync = !0);
    const b = a._selection;
    if (H(b)) {
      const m = a._nodeMap,
        v = b.anchor.key,
        _ = b.focus.key;
      (m.get(v) !== void 0 && m.get(_) !== void 0) || K(19);
    } else Je(b) && b._nodes.size === 0 && (a._selection = null);
  } catch (x) {
    return (
      x instanceof Error && e._onError(x),
      (e._pendingEditorState = l),
      (e._dirtyType = Mi),
      e._cloneNotNeeded.clear(),
      (e._dirtyLeaves = new Set()),
      e._dirtyElements.clear(),
      void jn(e)
    );
  } finally {
    (lt = c), (Lt = d), (at = f), (e._updating = h), (Xs = 0);
  }
  e._dirtyType !== Wr ||
  e._deferred.length > 0 ||
  (function (x, b) {
    const m = b.getEditorState()._selection,
      v = x._selection;
    if (v !== null) {
      if (v.dirty || !v.is(m)) return !0;
    } else if (m !== null) return !0;
    return !1;
  })(a, e)
    ? a._flushSync
      ? ((a._flushSync = !1), jn(e))
      : u &&
        $_(() => {
          jn(e);
        })
    : ((a._flushSync = !1), u && (r.clear(), (e._deferred = []), (e._pendingEditorState = null)));
}
function Rt(e, t, n) {
  at === e && n === void 0 ? t() : Qd(e, t, n);
}
class Io {
  constructor(t, n, r) {
    (this.element = t), (this.before = n || null), (this.after = r || null);
  }
  withBefore(t) {
    return new Io(this.element, t, this.after);
  }
  withAfter(t) {
    return new Io(this.element, this.before, t);
  }
  withElement(t) {
    return this.element === t ? this : new Io(t, this.before, this.after);
  }
  insertChild(t) {
    const n = this.before || this.getManagedLineBreak();
    return n !== null && n.parentElement !== this.element && K(222), this.element.insertBefore(t, n), this;
  }
  removeChild(t) {
    return t.parentElement !== this.element && K(223), this.element.removeChild(t), this;
  }
  replaceChild(t, n) {
    return n.parentElement !== this.element && K(224), this.element.replaceChild(t, n), this;
  }
  getFirstChild() {
    const t = this.after ? this.after.nextSibling : this.element.firstChild;
    return t === this.before || t === this.getManagedLineBreak() ? null : t;
  }
  getManagedLineBreak() {
    return this.element.__lexicalLineBreak || null;
  }
  setManagedLineBreak(t) {
    if (t === null) this.removeManagedLineBreak();
    else {
      const n = t === "decorator" && (Li || Bo);
      this.insertManagedLineBreak(n);
    }
  }
  removeManagedLineBreak() {
    const t = this.getManagedLineBreak();
    if (t) {
      const n = this.element,
        r = t.nodeName === "IMG" ? t.nextSibling : null;
      r && n.removeChild(r), n.removeChild(t), (n.__lexicalLineBreak = void 0);
    }
  }
  insertManagedLineBreak(t) {
    const n = this.getManagedLineBreak();
    if (n) {
      if (t === (n.nodeName === "IMG")) return;
      this.removeManagedLineBreak();
    }
    const r = this.element,
      i = this.before,
      o = document.createElement("br");
    if ((r.insertBefore(o, i), t)) {
      const s = document.createElement("img");
      s.setAttribute("data-lexical-linebreak", "true"),
        (s.style.cssText = "display: inline !important; border: 0px !important; margin: 0px !important;"),
        (s.alt = ""),
        r.insertBefore(s, o),
        (r.__lexicalLineBreak = s);
    } else r.__lexicalLineBreak = o;
  }
  getFirstChildOffset() {
    let t = 0;
    for (let n = this.after; n !== null; n = n.previousSibling) t++;
    return t;
  }
  resolveChildIndex(t, n, r, i) {
    if (r === this.element) {
      const a = this.getFirstChildOffset();
      return [t, Math.min(a + t.getChildrenSize(), Math.max(a, i))];
    }
    const o = Tp(n, r);
    o.push(i);
    const s = Tp(n, this.element);
    let l = t.getIndexWithinParent();
    for (let a = 0; a < s.length; a++) {
      const u = o[a],
        c = s[a];
      if (u === void 0 || u < c) break;
      if (u > c) {
        l += 1;
        break;
      }
    }
    return [t.getParentOrThrow(), l];
  }
}
function Tp(e, t) {
  const n = [];
  let r = t;
  for (; r !== e && r !== null; r = r.parentNode) {
    let i = 0;
    for (let o = r.previousSibling; o !== null; o = o.previousSibling) i++;
    n.push(i);
  }
  return r !== e && K(225), n.reverse();
}
class dn extends aa {
  constructor(t) {
    super(t),
      (this.__first = null),
      (this.__last = null),
      (this.__size = 0),
      (this.__format = 0),
      (this.__style = ""),
      (this.__indent = 0),
      (this.__dir = null),
      (this.__textFormat = 0),
      (this.__textStyle = "");
  }
  afterCloneFrom(t) {
    super.afterCloneFrom(t),
      (this.__first = t.__first),
      (this.__last = t.__last),
      (this.__size = t.__size),
      (this.__indent = t.__indent),
      (this.__format = t.__format),
      (this.__style = t.__style),
      (this.__dir = t.__dir),
      (this.__textFormat = t.__textFormat),
      (this.__textStyle = t.__textStyle);
  }
  getFormat() {
    return this.getLatest().__format;
  }
  getFormatType() {
    const t = this.getFormat();
    return YC[t] || "";
  }
  getStyle() {
    return this.getLatest().__style;
  }
  getIndent() {
    return this.getLatest().__indent;
  }
  getChildren() {
    const t = [];
    let n = this.getFirstChild();
    for (; n !== null; ) t.push(n), (n = n.getNextSibling());
    return t;
  }
  getChildrenKeys() {
    const t = [];
    let n = this.getFirstChild();
    for (; n !== null; ) t.push(n.__key), (n = n.getNextSibling());
    return t;
  }
  getChildrenSize() {
    return this.getLatest().__size;
  }
  isEmpty() {
    return this.getChildrenSize() === 0;
  }
  isDirty() {
    const t = Ge()._dirtyElements;
    return t !== null && t.has(this.__key);
  }
  isLastChild() {
    const t = this.getLatest(),
      n = this.getParentOrThrow().getLastChild();
    return n !== null && n.is(t);
  }
  getAllTextNodes() {
    const t = [];
    let n = this.getFirstChild();
    for (; n !== null; ) {
      if ((Z(n) && t.push(n), P(n))) {
        const r = n.getAllTextNodes();
        t.push(...r);
      }
      n = n.getNextSibling();
    }
    return t;
  }
  getFirstDescendant() {
    let t = this.getFirstChild();
    for (; P(t); ) {
      const n = t.getFirstChild();
      if (n === null) break;
      t = n;
    }
    return t;
  }
  getLastDescendant() {
    let t = this.getLastChild();
    for (; P(t); ) {
      const n = t.getLastChild();
      if (n === null) break;
      t = n;
    }
    return t;
  }
  getDescendantByIndex(t) {
    const n = this.getChildren(),
      r = n.length;
    if (t >= r) {
      const o = n[r - 1];
      return (P(o) && o.getLastDescendant()) || o || null;
    }
    const i = n[t];
    return (P(i) && i.getFirstDescendant()) || i || null;
  }
  getFirstChild() {
    const t = this.getLatest().__first;
    return t === null ? null : Oe(t);
  }
  getFirstChildOrThrow() {
    const t = this.getFirstChild();
    return t === null && K(45, this.__key), t;
  }
  getLastChild() {
    const t = this.getLatest().__last;
    return t === null ? null : Oe(t);
  }
  getLastChildOrThrow() {
    const t = this.getLastChild();
    return t === null && K(96, this.__key), t;
  }
  getChildAtIndex(t) {
    const n = this.getChildrenSize();
    let r, i;
    if (t < n / 2) {
      for (r = this.getFirstChild(), i = 0; r !== null && i <= t; ) {
        if (i === t) return r;
        (r = r.getNextSibling()), i++;
      }
      return null;
    }
    for (r = this.getLastChild(), i = n - 1; r !== null && i >= t; ) {
      if (i === t) return r;
      (r = r.getPreviousSibling()), i--;
    }
    return null;
  }
  getTextContent() {
    let t = "";
    const n = this.getChildren(),
      r = n.length;
    for (let i = 0; i < r; i++) {
      const o = n[i];
      (t += o.getTextContent()), P(o) && i !== r - 1 && !o.isInline() && (t += qn);
    }
    return t;
  }
  getTextContentSize() {
    let t = 0;
    const n = this.getChildren(),
      r = n.length;
    for (let i = 0; i < r; i++) {
      const o = n[i];
      (t += o.getTextContentSize()), P(o) && i !== r - 1 && !o.isInline() && (t += qn.length);
    }
    return t;
  }
  getDirection() {
    return this.getLatest().__dir;
  }
  getTextFormat() {
    return this.getLatest().__textFormat;
  }
  hasFormat(t) {
    if (t !== "") {
      const n = ep[t];
      return !!(this.getFormat() & n);
    }
    return !1;
  }
  hasTextFormat(t) {
    const n = Et[t];
    return !!(this.getTextFormat() & n);
  }
  getFormatFlags(t, n) {
    return El(this.getLatest().__textFormat, t, n);
  }
  getTextStyle() {
    return this.getLatest().__textStyle;
  }
  select(t, n) {
    pt();
    const r = J();
    let i = t,
      o = n;
    const s = this.getChildrenSize();
    if (!this.canBeEmpty()) {
      if (t === 0 && n === 0) {
        const a = this.getFirstChild();
        if (Z(a) || P(a)) return a.select(0, 0);
      } else if (!((t !== void 0 && t !== s) || (n !== void 0 && n !== s))) {
        const a = this.getLastChild();
        if (Z(a) || P(a)) return a.select();
      }
    }
    i === void 0 && (i = s), o === void 0 && (o = s);
    const l = this.__key;
    return H(r)
      ? (r.anchor.set(l, i, "element"), r.focus.set(l, o, "element"), (r.dirty = !0), r)
      : a0(l, i, l, o, "element", "element");
  }
  selectStart() {
    const t = this.getFirstDescendant();
    return t ? t.selectStart() : this.select();
  }
  selectEnd() {
    const t = this.getLastDescendant();
    return t ? t.selectEnd() : this.select();
  }
  clear() {
    const t = this.getWritable();
    return this.getChildren().forEach((n) => n.remove()), t;
  }
  append(...t) {
    return this.splice(this.getChildrenSize(), 0, t);
  }
  setDirection(t) {
    const n = this.getWritable();
    return (n.__dir = t), n;
  }
  setFormat(t) {
    return (this.getWritable().__format = t !== "" ? ep[t] : 0), this;
  }
  setStyle(t) {
    return (this.getWritable().__style = t || ""), this;
  }
  setTextFormat(t) {
    const n = this.getWritable();
    return (n.__textFormat = t), n;
  }
  setTextStyle(t) {
    const n = this.getWritable();
    return (n.__textStyle = t), n;
  }
  setIndent(t) {
    return (this.getWritable().__indent = t), this;
  }
  splice(t, n, r) {
    const i = r.length,
      o = this.getChildrenSize(),
      s = this.getWritable();
    t + n <= o || K(226, String(t), String(n), String(o));
    const l = s.__key,
      a = [],
      u = [],
      c = this.getChildAtIndex(t + n);
    let d = null,
      f = o - n + i;
    if (t !== 0)
      if (t === o) d = this.getLastChild();
      else {
        const p = this.getChildAtIndex(t);
        p !== null && (d = p.getPreviousSibling());
      }
    if (n > 0) {
      let p = d === null ? this.getFirstChild() : d.getNextSibling();
      for (let g = 0; g < n; g++) {
        p === null && K(100);
        const x = p.getNextSibling(),
          b = p.__key;
        Br(p.getWritable()), u.push(b), (p = x);
      }
    }
    let h = d;
    for (let p = 0; p < i; p++) {
      const g = r[p];
      h !== null && g.is(h) && (d = h = h.getPreviousSibling());
      const x = g.getWritable();
      x.__parent === l && f--, Br(x);
      const b = g.__key;
      if (h === null) (s.__first = b), (x.__prev = null);
      else {
        const m = h.getWritable();
        (m.__next = b), (x.__prev = m.__key);
      }
      g.__key === l && K(76), (x.__parent = l), a.push(b), (h = g);
    }
    if (t + n === o) h !== null && ((h.getWritable().__next = null), (s.__last = h.__key));
    else if (c !== null) {
      const p = c.getWritable();
      if (h !== null) {
        const g = h.getWritable();
        (p.__prev = h.__key), (g.__next = c.__key);
      } else p.__prev = null;
    }
    if (((s.__size = f), u.length)) {
      const p = J();
      if (H(p)) {
        const g = new Set(u),
          x = new Set(a),
          { anchor: b, focus: m } = p;
        Ap(b, g, x) && Cl(b, b.getNode(), this, d, c),
          Ap(m, g, x) && Cl(m, m.getNode(), this, d, c),
          f !== 0 || this.canBeEmpty() || tt(this) || this.remove();
      }
    }
    return s;
  }
  getDOMSlot(t) {
    return new Io(t);
  }
  exportDOM(t) {
    const { element: n } = super.exportDOM(t);
    if (We(n)) {
      const r = this.getIndent();
      r > 0 && (n.style.paddingInlineStart = 40 * r + "px");
      const i = this.getDirection();
      i && (n.dir = i);
    }
    return { element: n };
  }
  exportJSON() {
    const t = {
        children: [],
        direction: this.getDirection(),
        format: this.getFormatType(),
        indent: this.getIndent(),
        ...super.exportJSON(),
      },
      n = this.getTextFormat(),
      r = this.getTextStyle();
    return n !== 0 && (t.textFormat = n), r !== "" && (t.textStyle = r), t;
  }
  updateFromJSON(t) {
    return super
      .updateFromJSON(t)
      .setFormat(t.format)
      .setIndent(t.indent)
      .setDirection(t.direction)
      .setTextFormat(t.textFormat || 0)
      .setTextStyle(t.textStyle || "");
  }
  insertNewAfter(t, n) {
    return null;
  }
  canIndent() {
    return !0;
  }
  collapseAtStart(t) {
    return !1;
  }
  excludeFromCopy(t) {
    return !1;
  }
  canReplaceWith(t) {
    return !0;
  }
  canInsertAfter(t) {
    return !0;
  }
  canBeEmpty() {
    return !0;
  }
  canInsertTextBefore() {
    return !0;
  }
  canInsertTextAfter() {
    return !0;
  }
  isInline() {
    return !1;
  }
  isShadowRoot() {
    return !1;
  }
  canMergeWith(t) {
    return !1;
  }
  extractWithChild(t, n, r) {
    return !1;
  }
  canMergeWhenEmpty() {
    return !1;
  }
  reconcileObservedMutation(t, n) {
    const r = this.getDOMSlot(t);
    let i = r.getFirstChild();
    for (let o = this.getFirstChild(); o; o = o.getNextSibling()) {
      const s = n.getElementByKey(o.getKey());
      s !== null && (i == null ? (r.insertChild(s), (i = s)) : i !== s && r.replaceChild(s, i), (i = i.nextSibling));
    }
  }
}
function P(e) {
  return e instanceof dn;
}
function Ap(e, t, n) {
  let r = e.getNode();
  for (; r; ) {
    const i = r.__key;
    if (t.has(i) && !n.has(i)) return !0;
    r = r.getParent();
  }
  return !1;
}
class Cr extends aa {
  decorate(t, n) {
    K(47);
  }
  isIsolated() {
    return !1;
  }
  isInline() {
    return !0;
  }
  isKeyboardSelectable() {
    return !0;
  }
}
function Te(e) {
  return e instanceof Cr;
}
class ds extends dn {
  static getType() {
    return "root";
  }
  static clone() {
    return new ds();
  }
  constructor() {
    super("root"), (this.__cachedText = null);
  }
  getTopLevelElementOrThrow() {
    K(51);
  }
  getTextContent() {
    const t = this.__cachedText;
    return (!cs() && Ge()._dirtyType !== Wr) || t === null ? super.getTextContent() : t;
  }
  remove() {
    K(52);
  }
  replace(t) {
    K(53);
  }
  insertBefore(t) {
    K(54);
  }
  insertAfter(t) {
    K(55);
  }
  updateDOM(t, n) {
    return !1;
  }
  splice(t, n, r) {
    for (const i of r) P(i) || Te(i) || K(282);
    return super.splice(t, n, r);
  }
  static importJSON(t) {
    return Ce().updateFromJSON(t);
  }
  collapseAtStart() {
    return !0;
  }
}
function ut(e) {
  return e instanceof ds;
}
function h0(e) {
  return new da(new Map(e._nodeMap));
}
function ef() {
  return new da(new Map([["root", new ds()]]));
}
function p0(e) {
  const t = e.exportJSON(),
    n = e.constructor;
  if ((t.type !== n.getType() && K(130, n.name), P(e))) {
    const r = t.children;
    Array.isArray(r) || K(59, n.name);
    const i = e.getChildren();
    for (let o = 0; o < i.length; o++) {
      const s = p0(i[o]);
      r.push(s);
    }
  }
  return t;
}
class da {
  constructor(t, n) {
    (this._nodeMap = t), (this._selection = n || null), (this._flushSync = !1), (this._readOnly = !1);
  }
  isEmpty() {
    return this._nodeMap.size === 1 && this._selection === null;
  }
  read(t, n) {
    return kp((n && n.editor) || null, this, t);
  }
  clone(t) {
    const n = new da(this._nodeMap, t === void 0 ? this._selection : t);
    return (n._readOnly = !0), n;
  }
  toJSON() {
    return kp(null, this, () => ({ root: p0(Ce()) }));
  }
}
const _l = "historic",
  M_ = "history-push",
  Qs = "history-merge",
  O_ = "paste",
  g0 = "collaboration",
  F_ = "skip-scroll-into-view",
  R_ = "skip-dom-selection";
class tf extends dn {
  static getType() {
    return "artificial";
  }
  createDOM(t) {
    return document.createElement("div");
  }
}
class Xi extends dn {
  static getType() {
    return "paragraph";
  }
  static clone(t) {
    return new Xi(t.__key);
  }
  createDOM(t) {
    const n = document.createElement("p"),
      r = Ai(t.theme, "paragraph");
    return r !== void 0 && n.classList.add(...r), n;
  }
  updateDOM(t, n, r) {
    return !1;
  }
  static importDOM() {
    return { p: (t) => ({ conversion: P_, priority: 0 }) };
  }
  exportDOM(t) {
    const { element: n } = super.exportDOM(t);
    if (We(n)) {
      this.isEmpty() && n.append(document.createElement("br"));
      const r = this.getFormatType();
      r && (n.style.textAlign = r);
    }
    return { element: n };
  }
  static importJSON(t) {
    return Se().updateFromJSON(t);
  }
  exportJSON() {
    return { ...super.exportJSON(), textFormat: this.getTextFormat(), textStyle: this.getTextStyle() };
  }
  insertNewAfter(t, n) {
    const r = Se();
    r.setTextFormat(t.format), r.setTextStyle(t.style);
    const i = this.getDirection();
    return r.setDirection(i), r.setFormat(this.getFormatType()), r.setStyle(this.getStyle()), this.insertAfter(r, n), r;
  }
  collapseAtStart() {
    const t = this.getChildren();
    if (t.length === 0 || (Z(t[0]) && t[0].getTextContent().trim() === "")) {
      if (this.getNextSibling() !== null) return this.selectNext(), this.remove(), !0;
      if (this.getPreviousSibling() !== null) return this.selectPrevious(), this.remove(), !0;
    }
    return !1;
  }
}
function P_(e) {
  const t = Se();
  return e.style && (t.setFormat(e.style.textAlign), pf(e, t)), { node: t };
}
function Se() {
  return Mt(new Xi());
}
function nf(e) {
  return e instanceof Xi;
}
const be = 0,
  He = 1,
  wl = 3,
  Bt = 4;
function m0(e, t, n, r) {
  const i = e._keyToDOMMap;
  i.clear(),
    (e._editorState = ef()),
    (e._pendingEditorState = r),
    (e._compositionKey = null),
    (e._dirtyType = Wr),
    e._cloneNotNeeded.clear(),
    (e._dirtyLeaves = new Set()),
    e._dirtyElements.clear(),
    (e._normalizedNodes = new Set()),
    (e._updateTags = new Set()),
    (e._updates = []),
    (e._blockCursorElement = null);
  const o = e._observer;
  o !== null && (o.disconnect(), (e._observer = null)),
    t !== null && (t.textContent = ""),
    n !== null && ((n.textContent = ""), i.set("root", n));
}
function rf(e) {
  const t = e || {},
    n = N_(),
    r = t.theme || {},
    i = e === void 0 ? n : t.parentEditor || null,
    o = t.disableEvents || !1,
    s = ef(),
    l = t.namespace || (i !== null ? i._config.namespace : w0()),
    a = t.editorState,
    u = [ds, Ln, as, us, Xi, tf, ...(t.nodes || [])],
    { onError: c, html: d } = t,
    f = t.editable === void 0 || t.editable;
  let h;
  if (e === void 0 && n !== null) h = n._nodes;
  else {
    h = new Map();
    for (let g = 0; g < u.length; g++) {
      let x = u[g],
        b = null,
        m = null;
      if (typeof x != "function") {
        const w = x;
        (x = w.replace), (b = w.with), (m = w.withKlass || null);
      }
      const v = x.getType(),
        _ = x.transform(),
        k = new Set();
      _ !== null && k.add(_),
        h.set(v, {
          exportDOM: d && d.export ? d.export.get(x) : void 0,
          klass: x,
          replace: b,
          replaceWithKlass: m,
          transforms: k,
        });
    }
  }
  const p = new fa(
    s,
    i,
    h,
    { disableEvents: o, namespace: l, theme: r },
    c || console.error,
    (function (g, x) {
      const b = new Map(),
        m = new Set(),
        v = (_) => {
          Object.keys(_).forEach((k) => {
            let w = b.get(k);
            w === void 0 && ((w = []), b.set(k, w)), w.push(_[k]);
          });
        };
      return (
        g.forEach((_) => {
          const k = _.klass.importDOM;
          if (k == null || m.has(k)) return;
          m.add(k);
          const w = k.call(_.klass);
          w !== null && v(w);
        }),
        x && v(x),
        b
      );
    })(h, d ? d.import : void 0),
    f,
    e,
  );
  return a !== void 0 && ((p._pendingEditorState = a), (p._dirtyType = Mi)), p;
}
class fa {
  constructor(t, n, r, i, o, s, l, a) {
    (this._createEditorArgs = a),
      (this._parentEditor = n),
      (this._rootElement = null),
      (this._editorState = t),
      (this._pendingEditorState = null),
      (this._compositionKey = null),
      (this._deferred = []),
      (this._keyToDOMMap = new Map()),
      (this._updates = []),
      (this._updating = !1),
      (this._listeners = {
        decorator: new Set(),
        editable: new Set(),
        mutation: new Map(),
        root: new Set(),
        textcontent: new Set(),
        update: new Set(),
      }),
      (this._commands = new Map()),
      (this._config = i),
      (this._nodes = r),
      (this._decorators = {}),
      (this._pendingDecorators = null),
      (this._dirtyType = Wr),
      (this._cloneNotNeeded = new Set()),
      (this._dirtyLeaves = new Set()),
      (this._dirtyElements = new Map()),
      (this._normalizedNodes = new Set()),
      (this._updateTags = new Set()),
      (this._observer = null),
      (this._key = w0()),
      (this._onError = o),
      (this._htmlConversions = s),
      (this._editable = l),
      (this._headless = n !== null && n._headless),
      (this._window = null),
      (this._blockCursorElement = null);
  }
  isComposing() {
    return this._compositionKey != null;
  }
  registerUpdateListener(t) {
    const n = this._listeners.update;
    return (
      n.add(t),
      () => {
        n.delete(t);
      }
    );
  }
  registerEditableListener(t) {
    const n = this._listeners.editable;
    return (
      n.add(t),
      () => {
        n.delete(t);
      }
    );
  }
  registerDecoratorListener(t) {
    const n = this._listeners.decorator;
    return (
      n.add(t),
      () => {
        n.delete(t);
      }
    );
  }
  registerTextContentListener(t) {
    const n = this._listeners.textcontent;
    return (
      n.add(t),
      () => {
        n.delete(t);
      }
    );
  }
  registerRootListener(t) {
    const n = this._listeners.root;
    return (
      t(this._rootElement, null),
      n.add(t),
      () => {
        t(null, this._rootElement), n.delete(t);
      }
    );
  }
  registerCommand(t, n, r) {
    r === void 0 && K(35);
    const i = this._commands;
    i.has(t) || i.set(t, [new Set(), new Set(), new Set(), new Set(), new Set()]);
    const o = i.get(t);
    o === void 0 && K(36, String(t));
    const s = o[r];
    return (
      s.add(n),
      () => {
        s.delete(n), o.every((l) => l.size === 0) && i.delete(t);
      }
    );
  }
  registerMutationListener(t, n, r) {
    const i = this.resolveRegisteredNodeAfterReplacements(this.getRegisteredNode(t)).klass,
      o = this._listeners.mutation;
    o.set(n, i);
    const s = r && r.skipInitialization;
    return (
      (s !== void 0 && s) || this.initializeMutationListener(n, i),
      () => {
        o.delete(n);
      }
    );
  }
  getRegisteredNode(t) {
    const n = this._nodes.get(t.getType());
    return n === void 0 && K(37, t.name), n;
  }
  resolveRegisteredNodeAfterReplacements(t) {
    for (; t.replaceWithKlass; ) t = this.getRegisteredNode(t.replaceWithKlass);
    return t;
  }
  initializeMutationListener(t, n) {
    const r = this._editorState,
      i = Dp(r).get(n.getType());
    if (!i) return;
    const o = new Map();
    for (const s of i.keys()) o.set(s, "created");
    o.size > 0 &&
      t(o, { dirtyLeaves: new Set(), prevEditorState: r, updateTags: new Set(["registerMutationListener"]) });
  }
  registerNodeTransformToKlass(t, n) {
    const r = this.getRegisteredNode(t);
    return r.transforms.add(n), r;
  }
  registerNodeTransform(t, n) {
    const r = this.registerNodeTransformToKlass(t, n),
      i = [r],
      o = r.replaceWithKlass;
    if (o != null) {
      const s = this.registerNodeTransformToKlass(o, n);
      i.push(s);
    }
    return (
      (function (s, l) {
        const a = Dp(s.getEditorState()),
          u = [];
        for (const c of l) {
          const d = a.get(c);
          d && u.push(d);
        }
        u.length !== 0 &&
          s.update(
            () => {
              for (const c of u)
                for (const d of c.keys()) {
                  const f = Oe(d);
                  f && f.markDirty();
                }
            },
            s._pendingEditorState === null ? { tag: Qs } : void 0,
          );
      })(
        this,
        i.map((s) => s.klass.getType()),
      ),
      () => {
        i.forEach((s) => s.transforms.delete(n));
      }
    );
  }
  hasNode(t) {
    return this._nodes.has(t.getType());
  }
  hasNodes(t) {
    return t.every(this.hasNode.bind(this));
  }
  dispatchCommand(t, n) {
    return re(this, t, n);
  }
  getDecorators() {
    return this._decorators;
  }
  getRootElement() {
    return this._rootElement;
  }
  getKey() {
    return this._key;
  }
  setRootElement(t) {
    const n = this._rootElement;
    if (t !== n) {
      const r = Ai(this._config.theme, "root"),
        i = this._pendingEditorState || this._editorState;
      if (
        ((this._rootElement = t),
        m0(this, n, t, i),
        n !== null && (this._config.disableEvents || b_(n), r != null && n.classList.remove(...r)),
        t !== null)
      ) {
        const o = ff(t),
          s = t.style;
        (s.userSelect = "text"),
          (s.whiteSpace = "pre-wrap"),
          (s.wordBreak = "break-word"),
          t.setAttribute("data-lexical-editor", "true"),
          (this._window = o),
          (this._dirtyType = Mi),
          B1(this),
          this._updateTags.add(Qs),
          jn(this),
          this._config.disableEvents ||
            (function (l, a) {
              const u = l.ownerDocument,
                c = vl.get(u);
              (c === void 0 || c < 1) && u.addEventListener("selectionchange", r0),
                vl.set(u, (c || 0) + 1),
                (l.__lexicalEditor = a);
              const d = n0(l);
              for (let f = 0; f < hc.length; f++) {
                const [h, p] = hc[f],
                  g =
                    typeof p == "function"
                      ? (x) => {
                          up(x) || (ap(x), (a.isEditable() || h === "click") && p(x, a));
                        }
                      : (x) => {
                          if (up(x)) return;
                          ap(x);
                          const b = a.isEditable();
                          switch (h) {
                            case "cut":
                              return b && re(a, Gd, x);
                            case "copy":
                              return re(a, oa, x);
                            case "paste":
                              return b && re(a, ss, x);
                            case "dragstart":
                              return b && re(a, ia, x);
                            case "dragover":
                              return b && re(a, Jd, x);
                            case "dragend":
                              return b && re(a, g_, x);
                            case "focus":
                              return b && re(a, sa, x);
                            case "blur":
                              return b && re(a, la, x);
                            case "drop":
                              return b && re(a, Kd, x);
                          }
                        };
                l.addEventListener(h, g),
                  d.push(() => {
                    l.removeEventListener(h, g);
                  });
              }
            })(t, this),
          r != null && t.classList.add(...r);
      } else (this._window = null), this._updateTags.add(Qs), jn(this);
      Ao("root", this, !1, t, n);
    }
  }
  getElementByKey(t) {
    return this._keyToDOMMap.get(t) || null;
  }
  getEditorState() {
    return this._editorState;
  }
  setEditorState(t, n) {
    t.isEmpty() && K(38);
    let r = t;
    r._readOnly && ((r = h0(t)), (r._selection = t._selection ? t._selection.clone() : null)), $1(this);
    const i = this._pendingEditorState,
      o = this._updateTags,
      s = n !== void 0 ? n.tag : null;
    i === null || i.isEmpty() || (s != null && o.add(s), jn(this)),
      (this._pendingEditorState = r),
      (this._dirtyType = Mi),
      this._dirtyElements.set("root", !1),
      (this._compositionKey = null),
      s != null && o.add(s),
      this._updating || jn(this);
  }
  parseEditorState(t, n) {
    return (function (r, i, o) {
      const s = ef(),
        l = lt,
        a = Lt,
        u = at,
        c = i._dirtyElements,
        d = i._dirtyLeaves,
        f = i._cloneNotNeeded,
        h = i._dirtyType;
      (i._dirtyElements = new Map()),
        (i._dirtyLeaves = new Set()),
        (i._cloneNotNeeded = new Set()),
        (i._dirtyType = 0),
        (lt = s),
        (Lt = !1),
        (at = i);
      try {
        const p = i._nodes;
        Xd(r.root, p), o && o(), (s._readOnly = !0);
      } catch (p) {
        p instanceof Error && i._onError(p);
      } finally {
        (i._dirtyElements = c),
          (i._dirtyLeaves = d),
          (i._cloneNotNeeded = f),
          (i._dirtyType = h),
          (lt = l),
          (Lt = a),
          (at = u);
      }
      return s;
    })(typeof t == "string" ? JSON.parse(t) : t, this, n);
  }
  read(t) {
    return jn(this), this.getEditorState().read(t, { editor: this });
  }
  update(t, n) {
    (function (r, i, o) {
      r._updating ? r._updates.push([i, o]) : Qd(r, i, o);
    })(this, t, n);
  }
  focus(t, n = {}) {
    const r = this._rootElement;
    r !== null &&
      (r.setAttribute("autocapitalize", "off"),
      Rt(this, () => {
        const i = J(),
          o = Ce();
        i !== null
          ? i.dirty || Ye(i.clone())
          : o.getChildrenSize() !== 0 && (n.defaultSelection === "rootStart" ? o.selectStart() : o.selectEnd()),
          T0("focus"),
          z_(() => {
            r.removeAttribute("autocapitalize"), t && t();
          });
      }),
      this._pendingEditorState === null && r.removeAttribute("autocapitalize"));
  }
  blur() {
    const t = this._rootElement;
    t !== null && t.blur();
    const n = ln(this._window);
    n !== null && n.removeAllRanges();
  }
  isEditable() {
    return this._editable;
  }
  setEditable(t) {
    this._editable !== t && ((this._editable = t), Ao("editable", this, !0, t));
  }
  toJSON() {
    return { editorState: this._editorState.toJSON() };
  }
}
fa.version = "0.32.1+prod.esm";
let D_ = 1;
const $_ =
  typeof queueMicrotask == "function"
    ? queueMicrotask
    : (e) => {
        Promise.resolve().then(e);
      };
function Ip(e) {
  return Te(An(e));
}
function of(e) {
  const t = document.activeElement;
  if (!We(t)) return !1;
  const n = t.nodeName;
  return Te(An(e)) && (n === "INPUT" || n === "TEXTAREA" || (t.contentEditable === "true" && ha(t) == null));
}
function fs(e, t, n) {
  const r = e.getRootElement();
  try {
    return r !== null && r.contains(t) && r.contains(n) && t !== null && !of(t) && lf(t) === e;
  } catch {
    return !1;
  }
}
function sf(e) {
  return e instanceof fa;
}
function lf(e) {
  let t = e;
  for (; t != null; ) {
    const n = ha(t);
    if (sf(n)) return n;
    t = hs(t);
  }
  return null;
}
function ha(e) {
  return e ? e.__lexicalEditor : null;
}
function $r(e) {
  return ua(e) || e.isToken();
}
function Vn(e) {
  return $r(e) || e.isSegmented();
}
function tr(e) {
  return Qi(e) && e.nodeType === HC;
}
function B_(e) {
  return Qi(e) && e.nodeType === VC;
}
function Fi(e) {
  let t = e;
  for (; t != null; ) {
    if (tr(t)) return t;
    t = t.firstChild;
  }
  return null;
}
function El(e, t, n) {
  const r = Et[t];
  if (n !== null && (e & r) == (n & r)) return e;
  let i = e ^ r;
  return (
    t === "subscript"
      ? (i &= ~Et.superscript)
      : t === "superscript"
        ? (i &= ~Et.subscript)
        : t === "lowercase"
          ? ((i &= ~Et.uppercase), (i &= ~Et.capitalize))
          : t === "uppercase"
            ? ((i &= ~Et.lowercase), (i &= ~Et.capitalize))
            : t === "capitalize" && ((i &= ~Et.lowercase), (i &= ~Et.uppercase)),
    i
  );
}
function x0(e) {
  return Z(e) || rn(e) || Te(e);
}
function v0(e, t) {
  if (t != null) return void (e.__key = t);
  pt(), c0();
  const n = Ge(),
    r = yr(),
    i = "" + D_++;
  r._nodeMap.set(i, e),
    P(e) ? n._dirtyElements.set(i, !0) : n._dirtyLeaves.add(i),
    n._cloneNotNeeded.add(i),
    (n._dirtyType = O1),
    (e.__key = i);
}
function Br(e) {
  const t = e.getParent();
  if (t !== null) {
    const n = e.getWritable(),
      r = t.getWritable(),
      i = e.getPreviousSibling(),
      o = e.getNextSibling(),
      s = o !== null ? o.__key : null,
      l = i !== null ? i.__key : null,
      a = i !== null ? i.getWritable() : null,
      u = o !== null ? o.getWritable() : null;
    i === null && (r.__first = s),
      o === null && (r.__last = l),
      a !== null && (a.__next = s),
      u !== null && (u.__prev = l),
      (n.__prev = null),
      (n.__next = null),
      (n.__parent = null),
      r.__size--;
  }
}
function kl(e) {
  c0();
  const t = e.getLatest(),
    n = t.__parent,
    r = yr(),
    i = Ge(),
    o = r._nodeMap,
    s = i._dirtyElements;
  n !== null &&
    (function (a, u, c) {
      let d = a;
      for (; d !== null; ) {
        if (c.has(d)) return;
        const f = u.get(d);
        if (f === void 0) break;
        c.set(d, !1), (d = f.__parent);
      }
    })(n, o, s);
  const l = t.__key;
  (i._dirtyType = O1), P(e) ? s.set(l, !0) : i._dirtyLeaves.add(l);
}
function ft(e) {
  pt();
  const t = Ge(),
    n = t._compositionKey;
  if (e !== n) {
    if (((t._compositionKey = e), n !== null)) {
      const r = Oe(n);
      r !== null && r.getWritable();
    }
    if (e !== null) {
      const r = Oe(e);
      r !== null && r.getWritable();
    }
  }
}
function cr() {
  return cs() ? null : Ge()._compositionKey;
}
function Oe(e, t) {
  const n = (t || yr())._nodeMap.get(e);
  return n === void 0 ? null : n;
}
function b0(e, t) {
  const n = pa(e, Ge());
  return n !== void 0 ? Oe(n, t) : null;
}
function pa(e, t) {
  return e[`__lexicalKey_${t._key}`];
}
function An(e, t) {
  let n = e;
  for (; n != null; ) {
    const r = b0(n, t);
    if (r !== null) return r;
    n = hs(n);
  }
  return null;
}
function y0(e) {
  const t = e._decorators,
    n = Object.assign({}, t);
  return (e._pendingDecorators = n), n;
}
function Np(e) {
  return e.read(() => Ce().getTextContent());
}
function Ce() {
  return C0(yr());
}
function C0(e) {
  return e._nodeMap.get("root");
}
function Ye(e) {
  pt();
  const t = yr();
  e !== null && ((e.dirty = !0), e.setCachedNodes(null)), (t._selection = e);
}
function Ci(e) {
  const t = Ge(),
    n = (function (r, i) {
      let o = r;
      for (; o != null; ) {
        const s = pa(o, i);
        if (s !== void 0) return s;
        o = hs(o);
      }
      return null;
    })(e, t);
  return n === null ? (e === t.getRootElement() ? Oe("root") : null) : Oe(n);
}
function Lp(e, t) {
  return t ? e.getTextContentSize() : 0;
}
function _0(e) {
  return /[\uD800-\uDBFF][\uDC00-\uDFFF]/g.test(e);
}
function af(e) {
  const t = [];
  let n = e;
  for (; n !== null; ) t.push(n), (n = n._parentEditor);
  return t;
}
function w0() {
  return Math.random()
    .toString(36)
    .replace(/[^a-z]+/g, "")
    .substring(0, 5);
}
function E0(e) {
  return tr(e) ? e.nodeValue : null;
}
function uf(e, t, n) {
  const r = ln(Jt(t));
  if (r === null) return;
  const i = r.anchorNode;
  let { anchorOffset: o, focusOffset: s } = r;
  if (i !== null) {
    let l = E0(i);
    const a = An(i);
    if (l !== null && Z(a)) {
      if (l === Yl && n) {
        const u = n.length;
        (l = n), (o = u), (s = u);
      }
      l !== null && cf(a, l, o, s, e);
    }
  }
}
function cf(e, t, n, r, i) {
  let o = e;
  if (o.isAttached() && (i || !o.isDirty())) {
    const s = o.isComposing();
    let l = t;
    (s || i) && t[t.length - 1] === Yl && (l = t.slice(0, -1));
    const a = o.getTextContent();
    if (i || l !== a) {
      if (l === "") {
        if ((ft(null), Bo || Li || cl)) o.remove();
        else {
          const g = Ge();
          setTimeout(() => {
            g.update(() => {
              o.isAttached() && o.remove();
            });
          }, 20);
        }
        return;
      }
      const u = o.getParent(),
        c = oi(),
        d = o.getTextContentSize(),
        f = cr(),
        h = o.getKey();
      if (
        o.isToken() ||
        (f !== null && h === f && !s) ||
        (H(c) &&
          ((u !== null && !u.canInsertTextBefore() && c.anchor.offset === 0) ||
            (c.anchor.key === e.__key && c.anchor.offset === 0 && !o.canInsertTextBefore() && !s) ||
            (c.focus.key === e.__key && c.focus.offset === d && !o.canInsertTextAfter() && !s)))
      )
        return void o.markDirty();
      const p = J();
      if (!H(p) || n === null || r === null) return void o.setTextContent(l);
      if ((p.setTextNodeRange(o, n, o, r), o.isSegmented())) {
        const g = Be(o.getTextContent());
        o.replace(g), (o = g);
      }
      o.setTextContent(l);
    }
  }
}
function Rs(e, t, n) {
  const r = t[n] || !1;
  return r === "any" || r === e[n];
}
function H_(e, t) {
  return Rs(e, t, "altKey") && Rs(e, t, "ctrlKey") && Rs(e, t, "shiftKey") && Rs(e, t, "metaKey");
}
function Ne(e, t, n) {
  return H_(e, n) && e.key.toLowerCase() === t.toLowerCase();
}
const Bn = { ctrlKey: !bn, metaKey: bn },
  Mp = { altKey: bn, ctrlKey: !bn };
function Op(e) {
  return e.key === "Backspace";
}
function Fp(e) {
  return Ne(e, "a", Bn);
}
function V_(e) {
  const t = Ce();
  if (H(e)) {
    const n = e.anchor,
      r = e.focus,
      i = n.getNode().getTopLevelElementOrThrow().getParentOrThrow();
    return n.set(i.getKey(), 0, "element"), r.set(i.getKey(), i.getChildrenSize(), "element"), Kr(e), e;
  }
  {
    const n = t.select(0, t.getChildrenSize());
    return Ye(Kr(n)), n;
  }
}
function Ai(e, t) {
  e.__lexicalClassNameCache === void 0 && (e.__lexicalClassNameCache = {});
  const n = e.__lexicalClassNameCache,
    r = n[t];
  if (r !== void 0) return r;
  const i = e[t];
  if (typeof i == "string") {
    const o = dl(i);
    return (n[t] = o), o;
  }
  return i;
}
function df(e, t, n, r, i) {
  if (n.size === 0) return;
  const o = r.__type,
    s = r.__key,
    l = t.get(o);
  l === void 0 && K(33, o);
  const a = l.klass;
  let u = e.get(a);
  u === void 0 && ((u = new Map()), e.set(a, u));
  const c = u.get(s),
    d = c === "destroyed" && i === "created";
  (c === void 0 || d) && u.set(s, d ? "updated" : i);
}
function Rp(e, t, n) {
  const r = e.getParent();
  let i = n,
    o = e;
  return (
    r !== null &&
      (t && n === 0
        ? ((i = o.getIndexWithinParent()), (o = r))
        : t || n !== o.getChildrenSize() || ((i = o.getIndexWithinParent() + 1), (o = r))),
    o.getChildAtIndex(t ? i - 1 : i)
  );
}
function vc(e, t) {
  const n = e.offset;
  if (e.type === "element") return Rp(e.getNode(), t, n);
  {
    const r = e.getNode();
    if ((t && n === 0) || (!t && n === r.getTextContentSize())) {
      const i = t ? r.getPreviousSibling() : r.getNextSibling();
      return i === null ? Rp(r.getParentOrThrow(), t, r.getIndexWithinParent() + (t ? 0 : 1)) : i;
    }
  }
  return null;
}
function k0(e) {
  const t = Jt(e).event,
    n = t && t.inputType;
  return n === "insertFromPaste" || n === "insertFromPasteAsQuotation";
}
function re(e, t, n) {
  return (function (r, i, o) {
    const s = af(r);
    for (let l = 4; l >= 0; l--)
      for (let a = 0; a < s.length; a++) {
        const u = s[a],
          c = u._commands.get(i);
        if (c !== void 0) {
          const d = c[l];
          if (d !== void 0) {
            const f = Array.from(d),
              h = f.length;
            let p = !1;
            if (
              (Rt(u, () => {
                for (let g = 0; g < h; g++) if (f[g](o, r)) return void (p = !0);
              }),
              p)
            )
              return p;
          }
        }
      }
    return !1;
  })(e, t, n);
}
function ga(e) {
  return !ut(e) && !e.isLastChild() && !e.isInline();
}
function Ri(e, t) {
  const n = e._keyToDOMMap.get(t);
  return n === void 0 && K(75, t), n;
}
function hs(e) {
  const t = e.assignedSlot || e.parentElement;
  return Cc(t) ? t.host : t;
}
function S0(e) {
  return B_(e) ? e : We(e) ? e.ownerDocument : null;
}
function T0(e) {
  pt(), Ge()._updateTags.add(e);
}
function z_(e) {
  pt(), Ge()._deferred.push(e);
}
function bc(e, t) {
  let n = e.getParent();
  for (; n !== null; ) {
    if (n.is(t)) return !0;
    n = n.getParent();
  }
  return !1;
}
function ff(e) {
  const t = S0(e);
  return t ? t.defaultView : null;
}
function Jt(e) {
  const t = e._window;
  return t === null && K(78), t;
}
function j_(e) {
  let t = e.getParentOrThrow();
  for (; t !== null; ) {
    if (tt(t)) return t;
    t = t.getParentOrThrow();
  }
  return t;
}
function tt(e) {
  return ut(e) || (P(e) && e.isShadowRoot());
}
function U_(e) {
  const t = e.constructor.clone(e);
  return v0(t, null), t;
}
function Mt(e) {
  const t = Ge(),
    n = e.constructor.getType(),
    r = t._nodes.get(n);
  r === void 0 && K(200, e.constructor.name, n);
  const { replace: i, replaceWithKlass: o } = r;
  if (i !== null) {
    const s = i(e),
      l = s.constructor;
    return (
      o !== null
        ? s instanceof o || K(201, o.name, o.getType(), l.name, l.getType(), e.constructor.name, n)
        : (s instanceof e.constructor && l !== e.constructor) || K(202, l.name, l.getType(), e.constructor.name, n),
      s.__key === e.__key && K(203, e.constructor.name, n, l.name, l.getType()),
      s
    );
  }
  return e;
}
function uu(e, t) {
  !ut(e.getParent()) || P(t) || Te(t) || K(99);
}
function W_(e) {
  const t = Oe(e);
  return t === null && K(63, e), t;
}
function cu(e) {
  return (Te(e) || (P(e) && !e.canBeEmpty())) && !e.isInline();
}
function yc(e, t, n) {
  n.style.removeProperty("caret-color"), (t._blockCursorElement = null);
  const r = e.parentElement;
  r !== null && r.removeChild(e);
}
function ln(e) {
  return cn ? (e || window).getSelection() : null;
}
function K_(e) {
  const t = ff(e);
  return t ? t.getSelection() : null;
}
function A0(e) {
  return We(e) && e.tagName === "A";
}
function We(e) {
  return Qi(e) && e.nodeType === BC;
}
function Qi(e) {
  return typeof e == "object" && e !== null && "nodeType" in e && typeof e.nodeType == "number";
}
function Cc(e) {
  return Qi(e) && e.nodeType === zC;
}
function _c(e) {
  const t = new RegExp(
    /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|mark|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var|#text)$/,
    "i",
  );
  return e.nodeName.match(t) !== null;
}
function Sl(e) {
  const t = new RegExp(
    /^(address|article|aside|blockquote|canvas|dd|div|dl|dt|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hr|li|main|nav|noscript|ol|p|pre|section|table|td|tfoot|ul|video)$/,
    "i",
  );
  return e.nodeName.match(t) !== null;
}
function Ut(e) {
  if (Te(e) && !e.isInline()) return !0;
  if (!P(e) || tt(e)) return !1;
  const t = e.getFirstChild(),
    n = t === null || rn(t) || Z(t) || t.isInline();
  return !e.isInline() && e.canBeEmpty() !== !1 && n;
}
function du(e, t) {
  let n = e;
  for (; n !== null && n.getParent() !== null && !t(n); ) n = n.getParentOrThrow();
  return t(n) ? n : null;
}
function I0() {
  return Ge();
}
const Pp = new WeakMap(),
  J_ = new Map();
function Dp(e) {
  if (!e._readOnly && e.isEmpty()) return J_;
  e._readOnly || K(192);
  let t = Pp.get(e);
  return (
    t ||
      ((t = (function (n) {
        const r = new Map();
        for (const [i, o] of n._nodeMap) {
          const s = o.__type;
          let l = r.get(s);
          l || ((l = new Map()), r.set(s, l)), l.set(i, o);
        }
        return r;
      })(e)),
      Pp.set(e, t)),
    t
  );
}
function hf(e) {
  const t = e.constructor.clone(e);
  return t.afterCloneFrom(e), t;
}
function pf(e, t) {
  const n = parseInt(e.style.paddingInlineStart, 10) || 0,
    r = Math.round(n / 40);
  t.setIndent(r);
}
function G_(e) {
  return e.__lexicalUnmanaged === !0;
}
const Z_ = { next: "previous", previous: "next" };
class gf {
  constructor(t) {
    this.origin = t;
  }
  [Symbol.iterator]() {
    return L0({ hasNext: Pi, initial: this.getAdjacentCaret(), map: (t) => t, step: (t) => t.getAdjacentCaret() });
  }
  getAdjacentCaret() {
    return nt(this.getNodeAtCaret(), this.direction);
  }
  getSiblingCaret() {
    return nt(this.origin, this.direction);
  }
  remove() {
    const t = this.getNodeAtCaret();
    return t && t.remove(), this;
  }
  replaceOrInsert(t, n) {
    const r = this.getNodeAtCaret();
    return t.is(this.origin) || t.is(r) || (r === null ? this.insert(t) : r.replace(t, n)), this;
  }
  splice(t, n, r = "next") {
    const i = r === this.direction ? n : Array.from(n).reverse();
    let o = this;
    const s = this.getParentAtCaret(),
      l = new Map();
    for (let a = o.getAdjacentCaret(); a !== null && l.size < t; a = a.getAdjacentCaret()) {
      const u = a.origin.getWritable();
      l.set(u.getKey(), u);
    }
    for (const a of i) {
      if (l.size > 0) {
        const u = o.getNodeAtCaret();
        if (u) {
          if ((l.delete(u.getKey()), l.delete(a.getKey()), !(u.is(a) || o.origin.is(a)))) {
            const c = a.getParent();
            c && c.is(s) && a.remove(), u.replace(a);
          }
        } else u === null && K(263, Array.from(l).join(" "));
      } else o.insert(a);
      o = nt(a, this.direction);
    }
    for (const a of l.values()) a.remove();
    return this;
  }
}
class Ko extends gf {
  constructor() {
    super(...arguments);
    Vt(this, "type", "child");
  }
  getLatest() {
    const n = this.origin.getLatest();
    return n === this.origin ? this : an(n, this.direction);
  }
  getParentCaret(n = "root") {
    return nt(mf(this.getParentAtCaret(), n), this.direction);
  }
  getFlipped() {
    const n = si(this.direction);
    return nt(this.getNodeAtCaret(), n) || an(this.origin, n);
  }
  getParentAtCaret() {
    return this.origin;
  }
  getChildCaret() {
    return this;
  }
  isSameNodeCaret(n) {
    return n instanceof Ko && this.direction === n.direction && this.origin.is(n.origin);
  }
  isSamePointCaret(n) {
    return this.isSameNodeCaret(n);
  }
}
const q_ = { root: ut, shadowRoot: tt };
function si(e) {
  return Z_[e];
}
function mf(e, t = "root") {
  return q_[t](e) ? null : e;
}
class Gr extends gf {
  constructor() {
    super(...arguments);
    Vt(this, "type", "sibling");
  }
  getLatest() {
    const n = this.origin.getLatest();
    return n === this.origin ? this : nt(n, this.direction);
  }
  getSiblingCaret() {
    return this;
  }
  getParentAtCaret() {
    return this.origin.getParent();
  }
  getChildCaret() {
    return P(this.origin) ? an(this.origin, this.direction) : null;
  }
  getParentCaret(n = "root") {
    return nt(mf(this.getParentAtCaret(), n), this.direction);
  }
  getFlipped() {
    const n = si(this.direction);
    return nt(this.getNodeAtCaret(), n) || an(this.origin.getParentOrThrow(), n);
  }
  isSamePointCaret(n) {
    return n instanceof Gr && this.direction === n.direction && this.origin.is(n.origin);
  }
  isSameNodeCaret(n) {
    return (n instanceof Gr || n instanceof Zr) && this.direction === n.direction && this.origin.is(n.origin);
  }
}
class Zr extends gf {
  constructor(n, r) {
    super(n);
    Vt(this, "type", "text");
    this.offset = r;
  }
  getLatest() {
    const n = this.origin.getLatest();
    return n === this.origin ? this : qr(n, this.direction, this.offset);
  }
  getParentAtCaret() {
    return this.origin.getParent();
  }
  getChildCaret() {
    return null;
  }
  getParentCaret(n = "root") {
    return nt(mf(this.getParentAtCaret(), n), this.direction);
  }
  getFlipped() {
    return qr(this.origin, si(this.direction), this.offset);
  }
  isSamePointCaret(n) {
    return n instanceof Zr && this.direction === n.direction && this.origin.is(n.origin) && this.offset === n.offset;
  }
  isSameNodeCaret(n) {
    return (n instanceof Gr || n instanceof Zr) && this.direction === n.direction && this.origin.is(n.origin);
  }
  getSiblingCaret() {
    return nt(this.origin, this.direction);
  }
}
function Gn(e) {
  return e instanceof Zr;
}
function Pi(e) {
  return e instanceof Gr;
}
function Kt(e) {
  return e instanceof Ko;
}
const Y_ = {
    next: class extends Zr {
      constructor() {
        super(...arguments);
        Vt(this, "direction", "next");
      }
      getNodeAtCaret() {
        return this.origin.getNextSibling();
      }
      insert(t) {
        return this.origin.insertAfter(t), this;
      }
    },
    previous: class extends Zr {
      constructor() {
        super(...arguments);
        Vt(this, "direction", "previous");
      }
      getNodeAtCaret() {
        return this.origin.getPreviousSibling();
      }
      insert(t) {
        return this.origin.insertBefore(t), this;
      }
    },
  },
  X_ = {
    next: class extends Gr {
      constructor() {
        super(...arguments);
        Vt(this, "direction", "next");
      }
      getNodeAtCaret() {
        return this.origin.getNextSibling();
      }
      insert(t) {
        return this.origin.insertAfter(t), this;
      }
    },
    previous: class extends Gr {
      constructor() {
        super(...arguments);
        Vt(this, "direction", "previous");
      }
      getNodeAtCaret() {
        return this.origin.getPreviousSibling();
      }
      insert(t) {
        return this.origin.insertBefore(t), this;
      }
    },
  },
  Q_ = {
    next: class extends Ko {
      constructor() {
        super(...arguments);
        Vt(this, "direction", "next");
      }
      getNodeAtCaret() {
        return this.origin.getFirstChild();
      }
      insert(t) {
        return this.origin.splice(0, 0, [t]), this;
      }
    },
    previous: class extends Ko {
      constructor() {
        super(...arguments);
        Vt(this, "direction", "previous");
      }
      getNodeAtCaret() {
        return this.origin.getLastChild();
      }
      insert(t) {
        return this.origin.splice(this.origin.getChildrenSize(), 0, [t]), this;
      }
    },
  };
function nt(e, t) {
  return e ? new X_[t](e) : null;
}
function qr(e, t, n) {
  return e ? new Y_[t](e, Di(e, n)) : null;
}
function Di(e, t) {
  const n = e.getTextContentSize();
  let r = t === "next" ? n : t === "previous" ? 0 : t;
  return (
    (r < 0 || r > n) &&
      ((function (i, ...o) {
        const s = new URL("https://lexical.dev/docs/error"),
          l = new URLSearchParams();
        l.append("code", i);
        for (const a of o) l.append("v", a);
        (s.search = l.toString()),
          console.warn(
            `Minified Lexical warning #${i}; visit ${s.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`,
          );
      })(284, String(t), String(n), e.getKey()),
      (r = r < 0 ? 0 : n)),
    r
  );
}
function $p(e, t) {
  return new tw(e, t);
}
function an(e, t) {
  return P(e) ? new Q_[t](e) : null;
}
function ew(e) {
  return (e && e.getChildCaret()) || e;
}
function ma(e) {
  return e && ew(e.getAdjacentCaret());
}
class xf {
  constructor(t, n, r) {
    Vt(this, "type", "node-caret-range");
    (this.anchor = t), (this.focus = n), (this.direction = r);
  }
  getLatest() {
    const t = this.anchor.getLatest(),
      n = this.focus.getLatest();
    return t === this.anchor && n === this.focus ? this : new xf(t, n, this.direction);
  }
  isCollapsed() {
    return this.anchor.isSamePointCaret(this.focus);
  }
  getTextSlices() {
    const t = (i) => {
        const o = this[i].getLatest();
        return Gn(o)
          ? (function (s, l) {
              const { direction: a, origin: u } = s,
                c = Di(u, l === "focus" ? si(a) : a);
              return $p(s, c - s.offset);
            })(o, i)
          : null;
      },
      n = t("anchor"),
      r = t("focus");
    if (n && r) {
      const { caret: i } = n,
        { caret: o } = r;
      if (i.isSameNodeCaret(o)) return [$p(i, o.offset - i.offset), null];
    }
    return [n, r];
  }
  iterNodeCarets(t = "root") {
    const n = Gn(this.anchor) ? this.anchor.getSiblingCaret() : this.anchor.getLatest(),
      r = this.focus.getLatest(),
      i = Gn(r),
      o = (s) => (s.isSameNodeCaret(r) ? null : ma(s) || s.getParentCaret(t));
    return L0({
      hasNext: (s) => s !== null && !(i && r.isSameNodeCaret(s)),
      initial: n.isSameNodeCaret(r) ? null : o(n),
      map: (s) => s,
      step: o,
    });
  }
  [Symbol.iterator]() {
    return this.iterNodeCarets("root");
  }
}
class tw {
  constructor(t, n) {
    Vt(this, "type", "slice");
    (this.caret = t), (this.distance = n);
  }
  getSliceIndices() {
    const {
        distance: t,
        caret: { offset: n },
      } = this,
      r = n + t;
    return r < n ? [r, n] : [n, r];
  }
  getTextContent() {
    const [t, n] = this.getSliceIndices();
    return this.caret.origin.getTextContent().slice(t, n);
  }
  getTextContentSize() {
    return Math.abs(this.distance);
  }
  removeTextSlice() {
    const {
        caret: { origin: t, direction: n },
      } = this,
      [r, i] = this.getSliceIndices(),
      o = t.getTextContent();
    return qr(t.setTextContent(o.slice(0, r) + o.slice(i)), n, r);
  }
}
function vf(e) {
  return Yr(e, nt(Ce(), e.direction));
}
function N0(e) {
  return Yr(e, e);
}
function Yr(e, t) {
  return e.direction !== t.direction && K(265), new xf(e, t, e.direction);
}
function L0(e) {
  const { initial: t, hasNext: n, step: r, map: i } = e;
  let o = t;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next() {
      if (!n(o)) return { done: !0, value: void 0 };
      const s = { done: !1, value: i(o) };
      return (o = r(o)), s;
    },
  };
}
function M0(e, t) {
  const n = el(e.origin, t.origin);
  switch ((n === null && K(275, e.origin.getKey(), t.origin.getKey()), n.type)) {
    case "same": {
      const r = e.type === "text",
        i = t.type === "text";
      return r && i
        ? (function (o, s) {
            return Math.sign(o - s);
          })(e.offset, t.offset)
        : e.type === t.type
          ? 0
          : r
            ? -1
            : i
              ? 1
              : e.type === "child"
                ? -1
                : 1;
    }
    case "ancestor":
      return e.type === "child" ? -1 : 1;
    case "descendant":
      return t.type === "child" ? 1 : -1;
    case "branch":
      return O0(n);
  }
}
function O0(e) {
  const { a: t, b: n } = e,
    r = t.__key,
    i = n.__key;
  let o = t,
    s = n;
  for (; o && s; o = o.getNextSibling(), s = s.getNextSibling()) {
    if (o.__key === i) return -1;
    if (s.__key === r) return 1;
  }
  return o === null ? 1 : -1;
}
function Ps(e, t) {
  return t.is(e);
}
function Bp(e) {
  return P(e) ? [e.getLatest(), null] : [e.getParent(), e.getLatest()];
}
function el(e, t) {
  if (e.is(t)) return { commonAncestor: e, type: "same" };
  const n = new Map();
  for (let [r, i] = Bp(e); r; i = r, r = r.getParent()) n.set(r, i);
  for (let [r, i] = Bp(t); r; i = r, r = r.getParent()) {
    const o = n.get(r);
    if (o !== void 0)
      return o === null
        ? (Ps(e, r) || K(276), { commonAncestor: r, type: "ancestor" })
        : i === null
          ? (Ps(t, r) || K(277), { commonAncestor: r, type: "descendant" })
          : (((P(o) || Ps(e, o)) && (P(i) || Ps(t, i)) && r.is(o.getParent()) && r.is(i.getParent())) || K(278),
            { a: o, b: i, commonAncestor: r, type: "branch" });
  }
  return null;
}
function Yn(e, t) {
  const { type: n, key: r, offset: i } = e,
    o = W_(e.key);
  return n === "text"
    ? (Z(o) || K(266, o.getType(), r), qr(o, t, i))
    : (P(o) || K(267, o.getType(), r), rw(o, e.offset, t));
}
function Xr(e, t) {
  const { origin: n, direction: r } = t,
    i = r === "next";
  Gn(t)
    ? e.set(n.getKey(), t.offset, "text")
    : Pi(t)
      ? Z(n)
        ? e.set(n.getKey(), Di(n, r), "text")
        : e.set(n.getParentOrThrow().getKey(), n.getIndexWithinParent() + (i ? 1 : 0), "element")
      : ((Kt(t) && P(n)) || K(268), e.set(n.getKey(), i ? 0 : n.getChildrenSize(), "element"));
}
function F0(e) {
  const t = J(),
    n = H(t) ? t : qi();
  return tl(n, e), Ye(n), n;
}
function tl(e, t) {
  Xr(e.anchor, t.anchor), Xr(e.focus, t.focus);
}
function Hp(e) {
  const { anchor: t, focus: n } = e,
    r = Yn(t, "next"),
    i = Yn(n, "next"),
    o = M0(r, i) <= 0 ? "next" : "previous";
  return Yr(Xn(r, o), Xn(i, o));
}
function ps(e) {
  const { direction: t, origin: n } = e,
    r = nt(n, si(t)).getNodeAtCaret();
  return r ? nt(r, t) : an(n.getParentOrThrow(), t);
}
function Vp(e, t = "root") {
  const n = [e];
  for (let r = Kt(e) ? e.getParentCaret(t) : e.getSiblingCaret(); r !== null; r = r.getParentCaret(t)) n.push(ps(r));
  return n;
}
function fu(e) {
  return !!e && e.origin.isAttached();
}
function nw(e, t = "removeEmptySlices") {
  if (e.isCollapsed()) return e;
  const n = "root",
    r = "next";
  let i = t;
  const o = P0(e, r),
    s = Vp(o.anchor, n),
    l = Vp(o.focus.getFlipped(), n),
    a = new Set(),
    u = [];
  for (const p of o.iterNodeCarets(n))
    if (Kt(p)) a.add(p.origin.getKey());
    else if (Pi(p)) {
      const { origin: g } = p;
      (P(g) && !a.has(g.getKey())) || u.push(g);
    }
  for (const p of u) p.remove();
  for (const p of o.getTextSlices()) {
    if (!p) continue;
    const { origin: g } = p.caret,
      x = g.getTextContentSize(),
      b = ps(nt(g, r)),
      m = g.getMode();
    if ((Math.abs(p.distance) === x && i === "removeEmptySlices") || (m === "token" && p.distance !== 0)) b.remove();
    else if (p.distance !== 0) {
      i = "removeEmptySlices";
      let v = p.removeTextSlice();
      const _ = p.caret.origin;
      if (m === "segmented") {
        const k = v.origin,
          w = Be(k.getTextContent()).setStyle(k.getStyle()).setFormat(k.getFormat());
        b.replaceOrInsert(w), (v = qr(w, r, v.offset));
      }
      _.is(s[0].origin) && (s[0] = v), _.is(l[0].origin) && (l[0] = v.getFlipped());
    }
  }
  let c, d;
  for (const p of s)
    if (fu(p)) {
      c = Pt(p);
      break;
    }
  for (const p of l)
    if (fu(p)) {
      d = Pt(p);
      break;
    }
  const f = (function (p, g, x) {
    if (!p || !g) return null;
    const b = p.getParentAtCaret(),
      m = g.getParentAtCaret();
    if (!b || !m) return null;
    const v = b.getParents().reverse();
    v.push(b);
    const _ = m.getParents().reverse();
    _.push(m);
    const k = Math.min(v.length, _.length);
    let w;
    for (w = 0; w < k && v[w] === _[w]; w++);
    const y = (A, F) => {
        let R;
        for (let V = w; V < A.length; V++) {
          const B = A[V];
          if (tt(B)) return;
          !R && F(B) && (R = B);
        }
        return R;
      },
      S = y(v, Ut),
      T = S && y(_, (A) => x.has(A.getKey()) && Ut(A));
    return S && T ? [S, T] : null;
  })(c, d, a);
  if (f) {
    const [p, g] = f;
    an(p, "previous").splice(0, g.getChildren()), g.remove();
  }
  const h = [c, d, ...s, ...l].find(fu);
  if (h) return N0(Xn(Pt(h), e.direction));
  K(269, JSON.stringify(s.map((p) => p.origin.__key)));
}
function Pt(e) {
  const t = (function (i) {
      let o = i;
      for (; Kt(o); ) {
        const s = ma(o);
        if (!Kt(s)) break;
        o = s;
      }
      return o;
    })(e.getLatest()),
    { direction: n } = t;
  if (Z(t.origin)) return Gn(t) ? t : qr(t.origin, n, n);
  const r = t.getAdjacentCaret();
  return Pi(r) && Z(r.origin) ? qr(r.origin, n, si(n)) : t;
}
function R0(e) {
  return Gn(e) && e.offset !== Di(e.origin, e.direction);
}
function Xn(e, t) {
  return e.direction === t ? e : e.getFlipped();
}
function P0(e, t) {
  return e.direction === t ? e : Yr(Xn(e.focus, t), Xn(e.anchor, t));
}
function rw(e, t, n) {
  let r = an(e, "next");
  for (let i = 0; i < t; i++) {
    const o = r.getAdjacentCaret();
    if (o === null) break;
    r = o;
  }
  return Xn(r, n);
}
function iw(e) {
  const { origin: t, offset: n, direction: r } = e;
  if (n === Di(t, r)) return e.getSiblingCaret();
  if (n === Di(t, si(r))) return ps(e.getSiblingCaret());
  const [i] = t.splitText(n);
  return Z(i) || K(281), Xn(nt(i, "next"), r);
}
function ow(e, t) {
  return !0;
}
function sw(
  e,
  { $copyElementNode: t = U_, $splitTextPointCaretNext: n = iw, rootMode: r = "shadowRoot", $shouldSplit: i = ow } = {},
) {
  if (Gn(e)) return n(e);
  const o = e.getParentCaret(r);
  if (o) {
    const { origin: s } = o;
    if (Kt(e) && (!s.canBeEmpty() || !i(s, "first"))) return ps(o);
    const l = (function (a) {
      const u = [];
      for (let c = a.getAdjacentCaret(); c; c = c.getAdjacentCaret()) u.push(c.origin);
      return u;
    })(e);
    (l.length > 0 || (s.canBeEmpty() && i(s, "last"))) && o.insert(t(s).splice(0, 0, l));
  }
  return o;
}
function lw(e, ...t) {
  const n = new URL("https://lexical.dev/docs/error"),
    r = new URLSearchParams();
  r.append("code", e);
  for (const i of t) r.append("v", i);
  throw (
    ((n.search = r.toString()),
    Error(
      `Minified Lexical error #${e}; visit ${n.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`,
    ))
  );
}
const wc = new Map();
function D0(e) {
  const t = {};
  if (!e) return t;
  const n = e.split(";");
  for (const r of n)
    if (r !== "") {
      const [i, o] = r.split(/:([^]+)/);
      i && o && (t[i.trim()] = o.trim());
    }
  return t;
}
function zp(e) {
  let t = wc.get(e);
  return t === void 0 && ((t = D0(e)), wc.set(e, t)), t;
}
function $0(e, t) {
  const n = e.getStartEndPoints();
  if (t.isSelected(e) && !Vn(t) && n !== null) {
    const [r, i] = n,
      o = e.isBackward(),
      s = r.getNode(),
      l = i.getNode(),
      a = t.is(s),
      u = t.is(l);
    if (a || u) {
      const [c, d] = xc(e),
        f = s.is(l),
        h = t.is(o ? l : s),
        p = t.is(o ? s : l);
      let g,
        x = 0;
      f
        ? ((x = c > d ? d : c), (g = c > d ? c : d))
        : h
          ? ((x = o ? d : c), (g = void 0))
          : p && ((x = 0), (g = o ? c : d)),
        (t.__text = t.__text.slice(x, g));
    }
  }
  return t;
}
function jp(e) {
  if (e.type === "text") return e.offset === e.getNode().getTextContentSize();
  const t = e.getNode();
  return P(t) || lw(177), e.offset === t.getChildrenSize();
}
function aw(e) {
  const t = e.getStyle(),
    n = D0(t);
  wc.set(t, n);
}
function uw(e, t) {
  const n = e.getFormatType(),
    r = e.getIndent();
  n !== t.getFormatType() && t.setFormat(n), r !== t.getIndent() && t.setIndent(r);
}
function cw(e, t, n = uw) {
  if (e === null) return;
  const r = e.getStartEndPoints(),
    i = new Map();
  let o = null;
  if (r) {
    const [s, l] = r;
    (o = qi()), o.anchor.set(s.key, s.offset, s.type), o.focus.set(l.key, l.offset, l.type);
    const a = hu(s.getNode(), Ut),
      u = hu(l.getNode(), Ut);
    P(a) && i.set(a.getKey(), a), P(u) && i.set(u.getKey(), u);
  }
  for (const s of e.getNodes())
    if (P(s) && Ut(s)) i.set(s.getKey(), s);
    else if (r === null) {
      const l = hu(s, Ut);
      P(l) && i.set(l.getKey(), l);
    }
  for (const [s, l] of i) {
    const a = t();
    n(l, a),
      l.replace(a, !0),
      o &&
        (s === o.anchor.key && o.anchor.set(a.getKey(), o.anchor.offset, o.anchor.type),
        s === o.focus.key && o.focus.set(a.getKey(), o.focus.offset, o.focus.type));
  }
  o && e.is(J()) && Ye(o);
}
function B0(e) {
  const t = e.anchor.getNode(),
    n = ut(t) ? t : t.getParentOrThrow(),
    r = I0().getElementByKey(n.getKey());
  if (r === null) return !1;
  const i = r.ownerDocument.defaultView;
  return i === null ? !1 : i.getComputedStyle(r).writingMode === "vertical-rl";
}
function Up(e, t) {
  const n = B0(e) ? !t : t,
    r = Yn(e.focus, n ? "previous" : "next");
  if (R0(r)) return !1;
  for (const i of vf(r)) {
    if (Kt(i)) return !i.origin.isInline();
    if (!P(i.origin)) {
      if (Te(i.origin)) return !0;
      break;
    }
  }
  return !1;
}
function dw(e, t, n, r) {
  e.modify(t ? "extend" : "move", n, r);
}
function fw(e) {
  const t = e.anchor.getNode();
  return (ut(t) ? t : t.getParentOrThrow()).getDirection() === "rtl";
}
function Wp(e, t, n) {
  const r = fw(e);
  let i;
  (i = B0(e) || r ? !n : n), dw(e, t, i, "character");
}
function hu(e, t) {
  let n = e;
  for (; n !== null && n.getParent() !== null && !t(n); ) n = n.getParentOrThrow();
  return t(n) ? n : null;
}
function H0(e, ...t) {
  const n = new URL("https://lexical.dev/docs/error"),
    r = new URLSearchParams();
  r.append("code", e);
  for (const i of t) r.append("v", i);
  throw (
    ((n.search = r.toString()),
    Error(
      `Minified Lexical error #${e}; visit ${n.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`,
    ))
  );
}
const xa = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0,
  hw = xa && "documentMode" in document ? document.documentMode : null,
  pw = xa && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
!(!xa || !("InputEvent" in window) || hw) && "getTargetRanges" in new window.InputEvent("input");
function V0(...e) {
  const t = [];
  for (const n of e) if (n && typeof n == "string") for (const [r] of n.matchAll(/\S+/g)) t.push(r);
  return t;
}
function yt(...e) {
  return () => {
    for (let t = e.length - 1; t >= 0; t--) e[t]();
    e.length = 0;
  };
}
const gw = xa,
  mw = pw;
function un(e, ...t) {
  const n = V0(...t);
  n.length > 0 && e.classList.add(...n);
}
function va(e, ...t) {
  const n = V0(...t);
  n.length > 0 && e.classList.remove(...n);
}
function xw(e) {
  return e ? e.getAdjacentCaret() : null;
}
function z0(e, t) {
  let n = e;
  for (; n != null; ) {
    if (n instanceof t) return n;
    n = n.getParent();
  }
  return null;
}
function Ec(e) {
  const t = on(e, (n) => P(n) && !n.isInline());
  return P(t) || H0(4, e.__key), t;
}
const on = (e, t) => {
  let n = e;
  for (; n !== Ce() && n != null; ) {
    if (t(n)) return n;
    n = n.getParent();
  }
  return null;
};
function j0(e) {
  const t = J() || oi();
  let n;
  if (H(t)) n = Yn(t.focus, "next");
  else {
    if (t != null) {
      const s = t.getNodes(),
        l = s[s.length - 1];
      l && (n = nt(l, "next"));
    }
    n = n || an(Ce(), "previous").getFlipped().insert(Se());
  }
  const r = vw(e, n),
    i = ma(r),
    o = Kt(i) ? Pt(i) : r;
  return F0(N0(o)), e.getLatest();
}
function vw(e, t, n) {
  let r = Xn(t, "next");
  for (let i = r; i; i = sw(i, n)) r = i;
  return Gn(r) && H0(283), r.insert(e.isInline() ? Se().append(e) : e), Xn(nt(e.getLatest(), "next"), t.direction);
}
function bf(e, t) {
  const n = t();
  return e.replace(n), n.append(e), n;
}
function dr(e, t) {
  return e !== null && Object.getPrototypeOf(e).constructor.name === t.name;
}
function bw(e, t) {
  const n = [];
  for (let r = 0; r < e.length; r++) {
    const i = t(e[r]);
    i !== null && n.push(i);
  }
  return n;
}
let pu = !(mw || !gw) && void 0;
function yw(e) {
  let t = 1;
  if (
    (function () {
      if (pu === void 0) {
        const n = document.createElement("div");
        (n.style.cssText = "position: absolute; opacity: 0; width: 100px; left: -1000px;"),
          document.body.appendChild(n);
        const r = n.getBoundingClientRect();
        n.style.setProperty("zoom", "2"),
          (pu = n.getBoundingClientRect().width === r.width),
          document.body.removeChild(n);
      }
      return pu;
    })()
  )
    for (; e; ) (t *= Number(window.getComputedStyle(e).getPropertyValue("zoom"))), (e = e.parentElement);
  return t;
}
const Ds = 0,
  kc = 1,
  Sc = 2,
  en = 0,
  Cw = 1,
  Kp = 2,
  _w = 3,
  ww = 4;
function Ew(e, t, n, r, i) {
  if (e === null || (n.size === 0 && r.size === 0 && !i)) return en;
  const o = t._selection,
    s = e._selection;
  if (i) return Cw;
  if (!(H(o) && H(s) && s.isCollapsed() && o.isCollapsed())) return en;
  const l = (function (b, m, v) {
    const _ = b._nodeMap,
      k = [];
    for (const w of m) {
      const y = _.get(w);
      y !== void 0 && k.push(y);
    }
    for (const [w, y] of v) {
      if (!y) continue;
      const S = _.get(w);
      S === void 0 || ut(S) || k.push(S);
    }
    return k;
  })(t, n, r);
  if (l.length === 0) return en;
  if (l.length > 1) {
    const b = t._nodeMap,
      m = b.get(o.anchor.key),
      v = b.get(s.anchor.key);
    return m && v && !e._nodeMap.has(m.__key) && Z(m) && m.__text.length === 1 && o.anchor.offset === 1 ? Kp : en;
  }
  const a = l[0],
    u = e._nodeMap.get(a.__key);
  if (!Z(u) || !Z(a) || u.__mode !== a.__mode) return en;
  const c = u.__text,
    d = a.__text;
  if (c === d) return en;
  const f = o.anchor,
    h = s.anchor;
  if (f.key !== h.key || f.type !== "text") return en;
  const p = f.offset,
    g = h.offset,
    x = d.length - c.length;
  return x === 1 && g === p - 1 ? Kp : x === -1 && g === p + 1 ? _w : x === -1 && g === p ? ww : en;
}
function kw(e, t) {
  let n = Date.now(),
    r = en;
  return (i, o, s, l, a, u) => {
    const c = Date.now();
    if (u.has(_l)) return (r = en), (n = c), Sc;
    const d = Ew(i, o, l, a, e.isComposing()),
      f = (() => {
        const h = s === null || s.editor === e,
          p = u.has(M_);
        if (!p && h && u.has(Qs)) return Ds;
        if (i === null) return kc;
        const g = o._selection;
        return l.size > 0 || a.size > 0
          ? (p === !1 && d !== en && d === r && c < n + t && h) ||
            (l.size === 1 &&
              (function (x, b, m) {
                const v = b._nodeMap.get(x),
                  _ = m._nodeMap.get(x),
                  k = b._selection,
                  w = m._selection;
                return (
                  !(
                    (H(k) &&
                      H(w) &&
                      k.anchor.type === "element" &&
                      k.focus.type === "element" &&
                      w.anchor.type === "text" &&
                      w.focus.type === "text") ||
                    !Z(v) ||
                    !Z(_) ||
                    v.__parent !== _.__parent
                  ) && JSON.stringify(b.read(() => v.exportJSON())) === JSON.stringify(m.read(() => _.exportJSON()))
                );
              })(Array.from(l)[0], i, o))
            ? Ds
            : kc
          : g !== null
            ? Ds
            : Sc;
      })();
    return (n = c), (r = d), f;
  };
}
function Jp(e) {
  (e.undoStack = []), (e.redoStack = []), (e.current = null);
}
function Sw(e, t, n) {
  const r = kw(e, n);
  return yt(
    e.registerCommand(
      ea,
      () => (
        (function (o, s) {
          const l = s.redoStack,
            a = s.undoStack;
          if (a.length !== 0) {
            const u = s.current,
              c = a.pop();
            u !== null && (l.push(u), o.dispatchCommand(yo, !0)),
              a.length === 0 && o.dispatchCommand(Co, !1),
              (s.current = c || null),
              c && c.editor.setEditorState(c.editorState, { tag: _l });
          }
        })(e, t),
        !0
      ),
      be,
    ),
    e.registerCommand(
      ta,
      () => (
        (function (o, s) {
          const l = s.redoStack,
            a = s.undoStack;
          if (l.length !== 0) {
            const u = s.current;
            u !== null && (a.push(u), o.dispatchCommand(Co, !0));
            const c = l.pop();
            l.length === 0 && o.dispatchCommand(yo, !1),
              (s.current = c || null),
              c && c.editor.setEditorState(c.editorState, { tag: _l });
          }
        })(e, t),
        !0
      ),
      be,
    ),
    e.registerCommand(m_, () => (Jp(t), !1), be),
    e.registerCommand(x_, () => (Jp(t), e.dispatchCommand(yo, !1), e.dispatchCommand(Co, !1), !0), be),
    e.registerUpdateListener(({ editorState: o, prevEditorState: s, dirtyLeaves: l, dirtyElements: a, tags: u }) => {
      const c = t.current,
        d = t.redoStack,
        f = t.undoStack,
        h = c === null ? null : c.editorState;
      if (c !== null && o === h) return;
      const p = r(s, o, c, l, a, u);
      if (p === kc)
        d.length !== 0 && ((t.redoStack = []), e.dispatchCommand(yo, !1)),
          c !== null && (f.push({ ...c }), e.dispatchCommand(Co, !0));
      else if (p === Sc) return;
      t.current = { editor: e, editorState: o };
    }),
  );
}
function U0() {
  return { current: null, redoStack: [], undoStack: [] };
}
function W0({ delay: e, externalHistoryState: t }) {
  const [n] = bt();
  return (
    (function (r, i, o = 1e3) {
      const s = E.useMemo(() => i || U0(), [i]);
      E.useEffect(() => Sw(r, s, o), [o, r, s]);
    })(n, t, e),
    null
  );
}
function Tw(e, t) {
  const n = t.body ? t.body.childNodes : [];
  let r = [];
  const i = [];
  for (let o = 0; o < n.length; o++) {
    const s = n[o];
    if (!J0.has(s.nodeName)) {
      const l = G0(s, e, i, !1);
      l !== null && (r = r.concat(l));
    }
  }
  return (
    (function (o) {
      for (const s of o) s.getNextSibling() instanceof tf && s.insertAfter(sn());
      for (const s of o) {
        const l = s.getChildren();
        for (const a of l) s.insertBefore(a);
        s.remove();
      }
    })(i),
    r
  );
}
function Aw(e, t) {
  if (typeof document > "u" || (typeof window > "u" && global.window === void 0))
    throw new Error(
      "To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.",
    );
  const n = document.createElement("div"),
    r = Ce().getChildren();
  for (let i = 0; i < r.length; i++) K0(e, r[i], n, t);
  return n.innerHTML;
}
function K0(e, t, n, r = null) {
  let i = r === null || t.isSelected(r);
  const o = P(t) && t.excludeFromCopy("html");
  let s = t;
  if (r !== null) {
    let h = hf(t);
    (h = Z(h) && r !== null ? $0(r, h) : h), (s = h);
  }
  const l = P(s) ? s.getChildren() : [],
    a = e._nodes.get(s.getType());
  let u;
  u = a && a.exportDOM !== void 0 ? a.exportDOM(e, s) : s.exportDOM(e);
  const { element: c, after: d } = u;
  if (!c) return !1;
  const f = document.createDocumentFragment();
  for (let h = 0; h < l.length; h++) {
    const p = l[h],
      g = K0(e, p, f, r);
    !i && P(t) && g && t.extractWithChild(p, r, "html") && (i = !0);
  }
  if (i && !o) {
    if (((We(c) || Cc(c)) && c.append(f), n.append(c), d)) {
      const h = d.call(s, c);
      h && (Cc(c) ? c.replaceChildren(h) : c.replaceWith(h));
    }
  } else n.append(f);
  return i;
}
const J0 = new Set(["STYLE", "SCRIPT"]);
function G0(e, t, n, r, i = new Map(), o) {
  let s = [];
  if (J0.has(e.nodeName)) return s;
  let l = null;
  const a = (function (p, g) {
      const { nodeName: x } = p,
        b = g._htmlConversions.get(x.toLowerCase());
      let m = null;
      if (b !== void 0)
        for (const v of b) {
          const _ = v(p);
          _ !== null && (m === null || (m.priority || 0) <= (_.priority || 0)) && (m = _);
        }
      return m !== null ? m.conversion : null;
    })(e, t),
    u = a ? a(e) : null;
  let c = null;
  if (u !== null) {
    c = u.after;
    const p = u.node;
    if (((l = Array.isArray(p) ? p[p.length - 1] : p), l !== null)) {
      for (const [, g] of i) if (((l = g(l, o)), !l)) break;
      l && s.push(...(Array.isArray(p) ? p : [l]));
    }
    u.forChild != null && i.set(e.nodeName, u.forChild);
  }
  const d = e.childNodes;
  let f = [];
  const h = (l == null || !tt(l)) && ((l != null && bl(l)) || r);
  for (let p = 0; p < d.length; p++) f.push(...G0(d[p], t, n, h, new Map(i), l));
  return (
    c != null && (f = c(f)),
    Sl(e) &&
      (f = Iw(
        e,
        f,
        h
          ? () => {
              const p = new tf();
              return n.push(p), p;
            }
          : Se,
      )),
    l == null
      ? f.length > 0
        ? (s = s.concat(f))
        : Sl(e) &&
          (function (p) {
            return p.nextSibling == null || p.previousSibling == null ? !1 : _c(p.nextSibling) && _c(p.previousSibling);
          })(e) &&
          (s = s.concat(sn()))
      : P(l) && l.append(...f),
    s
  );
}
function Iw(e, t, n) {
  const r = e.style.textAlign,
    i = [];
  let o = [];
  for (let s = 0; s < t.length; s++) {
    const l = t[s];
    if (bl(l)) r && !l.getFormat() && l.setFormat(r), i.push(l);
    else if ((o.push(l), s === t.length - 1 || (s < t.length - 1 && bl(t[s + 1])))) {
      const a = n();
      a.setFormat(r), a.append(...o), i.push(a), (o = []);
    }
  }
  return i;
}
function Tl(e, ...t) {
  const n = new URL("https://lexical.dev/docs/error"),
    r = new URLSearchParams();
  r.append("code", e);
  for (const i of t) r.append("v", i);
  throw (
    ((n.search = r.toString()),
    Error(
      `Minified Lexical error #${e}; visit ${n.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`,
    ))
  );
}
function Nw(e, t = J()) {
  return t == null && Tl(166), (H(t) && t.isCollapsed()) || t.getNodes().length === 0 ? "" : Aw(e, t);
}
function Lw(e, t = J()) {
  return t == null && Tl(166), (H(t) && t.isCollapsed()) || t.getNodes().length === 0 ? null : JSON.stringify(Mw(e, t));
}
function Gp(e, t, n) {
  const r = e.getData("application/x-lexical-editor");
  if (r)
    try {
      const l = JSON.parse(r);
      if (l.namespace === n._config.namespace && Array.isArray(l.nodes)) return Zp(n, Ow(l.nodes), t);
    } catch {}
  const i = e.getData("text/html"),
    o = e.getData("text/plain");
  if (i && o !== i)
    try {
      const l = new DOMParser().parseFromString(
        (function (a) {
          return window.trustedTypes && window.trustedTypes.createPolicy
            ? window.trustedTypes.createPolicy("lexical", { createHTML: (u) => u }).createHTML(a)
            : a;
        })(i),
        "text/html",
      );
      return Zp(n, Tw(n, l), t);
    } catch {}
  const s = o || e.getData("text/uri-list");
  if (s != null)
    if (H(t)) {
      const l = s.split(/(\r?\n|\t)/);
      l[l.length - 1] === "" && l.pop();
      for (let a = 0; a < l.length; a++) {
        const u = J();
        if (H(u)) {
          const c = l[a];
          c ===
            `
` ||
          c ===
            `\r
`
            ? u.insertParagraph()
            : c === "	"
              ? u.insertNodes([Zi()])
              : u.insertText(c);
        }
      }
    } else t.insertRawText(s);
}
function Zp(e, t, n) {
  e.dispatchCommand(d_, { nodes: t, selection: n }) || n.insertNodes(t);
}
function Z0(e, t, n, r = []) {
  let i = t === null || n.isSelected(t);
  const o = P(n) && n.excludeFromCopy("html");
  let s = n;
  if (t !== null) {
    let u = hf(n);
    (u = Z(u) && t !== null ? $0(t, u) : u), (s = u);
  }
  const l = P(s) ? s.getChildren() : [],
    a = (function (u) {
      const c = u.exportJSON(),
        d = u.constructor;
      if ((c.type !== d.getType() && Tl(58, d.name), P(u))) {
        const f = c.children;
        Array.isArray(f) || Tl(59, d.name);
      }
      return c;
    })(s);
  if (Z(s)) {
    const u = s.__text;
    u.length > 0 ? (a.text = u) : (i = !1);
  }
  for (let u = 0; u < l.length; u++) {
    const c = l[u],
      d = Z0(e, t, c, a.children);
    !i && P(n) && d && n.extractWithChild(c, t, "clone") && (i = !0);
  }
  if (i && !o) r.push(a);
  else if (Array.isArray(a.children))
    for (let u = 0; u < a.children.length; u++) {
      const c = a.children[u];
      r.push(c);
    }
  return i;
}
function Mw(e, t) {
  const n = [],
    r = Ce().getChildren();
  for (let i = 0; i < r.length; i++) Z0(e, t, r[i], n);
  return { namespace: e._config.namespace, nodes: n };
}
function Ow(e) {
  const t = [];
  for (let n = 0; n < e.length; n++) {
    const r = e[n],
      i = L_(r);
    Z(i) && aw(i), t.push(i);
  }
  return t;
}
let fi = null;
async function qp(e, t, n) {
  if (fi !== null) return !1;
  if (t !== null)
    return new Promise((u, c) => {
      e.update(() => {
        u(Yp(e, t, n));
      });
    });
  const r = e.getRootElement(),
    i = e._window || window,
    o = window.document,
    s = ln(i);
  if (r === null || s === null) return !1;
  const l = o.createElement("span");
  (l.style.cssText = "position: fixed; top: -1000px;"), l.append(o.createTextNode("#")), r.append(l);
  const a = new Range();
  return (
    a.setStart(l, 0),
    a.setEnd(l, 1),
    s.removeAllRanges(),
    s.addRange(a),
    new Promise((u, c) => {
      const d = e.registerCommand(
        oa,
        (f) => (
          dr(f, ClipboardEvent) && (d(), fi !== null && (window.clearTimeout(fi), (fi = null)), u(Yp(e, f, n))), !0
        ),
        Bt,
      );
      (fi = window.setTimeout(() => {
        d(), (fi = null), u(!1);
      }, 50)),
        o.execCommand("copy"),
        l.remove();
    })
  );
}
function Yp(e, t, n) {
  if (n === void 0) {
    const i = ln(e._window);
    if (!i) return !1;
    const o = i.anchorNode,
      s = i.focusNode;
    if (o !== null && s !== null && !fs(e, o, s)) return !1;
    const l = J();
    if (l === null) return !1;
    n = Rw(l);
  }
  t.preventDefault();
  const r = t.clipboardData;
  return r !== null && (Pw(r, n), !0);
}
const Fw = [
  ["text/html", Nw],
  ["application/x-lexical-editor", Lw],
];
function Rw(e = J()) {
  const t = { "text/plain": e ? e.getTextContent() : "" };
  if (e) {
    const n = I0();
    for (const [r, i] of Fw) {
      const o = i(n, e);
      o !== null && (t[r] = o);
    }
  }
  return t;
}
function Pw(e, t) {
  for (const n in t) {
    const r = t[n];
    r !== void 0 && e.setData(n, r);
  }
}
function Xp(e, t) {
  if (document.caretRangeFromPoint !== void 0) {
    const n = document.caretRangeFromPoint(e, t);
    return n === null ? null : { node: n.startContainer, offset: n.startOffset };
  }
  if (document.caretPositionFromPoint !== "undefined") {
    const n = document.caretPositionFromPoint(e, t);
    return n === null ? null : { node: n.offsetNode, offset: n.offset };
  }
  return null;
}
const eo = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0,
  Dw = eo && "documentMode" in document ? document.documentMode : null,
  $w = !(!eo || !("InputEvent" in window) || Dw) && "getTargetRanges" in new window.InputEvent("input"),
  Bw = eo && /Version\/[\d.]+.*Safari/.test(navigator.userAgent),
  Qp = eo && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream,
  Hw = eo && /^(?=.*Chrome).*/i.test(navigator.userAgent),
  Vw = eo && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !Hw,
  eg = ae("DRAG_DROP_PASTE_FILE");
class to extends dn {
  static getType() {
    return "quote";
  }
  static clone(t) {
    return new to(t.__key);
  }
  createDOM(t) {
    const n = document.createElement("blockquote");
    return un(n, t.theme.quote), n;
  }
  updateDOM(t, n) {
    return !1;
  }
  static importDOM() {
    return { blockquote: (t) => ({ conversion: zw, priority: 0 }) };
  }
  exportDOM(t) {
    const { element: n } = super.exportDOM(t);
    if (We(n)) {
      this.isEmpty() && n.append(document.createElement("br"));
      const r = this.getFormatType();
      r && (n.style.textAlign = r);
      const i = this.getDirection();
      i && (n.dir = i);
    }
    return { element: n };
  }
  static importJSON(t) {
    return gs().updateFromJSON(t);
  }
  insertNewAfter(t, n) {
    const r = Se(),
      i = this.getDirection();
    return r.setDirection(i), this.insertAfter(r, n), r;
  }
  collapseAtStart() {
    const t = Se();
    return this.getChildren().forEach((n) => t.append(n)), this.replace(t), !0;
  }
  canMergeWhenEmpty() {
    return !0;
  }
}
function gs() {
  return Mt(new to());
}
function Tc(e) {
  return e instanceof to;
}
let ms = class q0 extends dn {
  static getType() {
    return "heading";
  }
  static clone(t) {
    return new q0(t.__tag, t.__key);
  }
  constructor(t, n) {
    super(n), (this.__tag = t);
  }
  getTag() {
    return this.__tag;
  }
  setTag(t) {
    const n = this.getWritable();
    return (this.__tag = t), n;
  }
  createDOM(t) {
    const n = this.__tag,
      r = document.createElement(n),
      i = t.theme.heading;
    if (i !== void 0) {
      const o = i[n];
      un(r, o);
    }
    return r;
  }
  updateDOM(t, n, r) {
    return t.__tag !== this.__tag;
  }
  static importDOM() {
    return {
      h1: (t) => ({ conversion: hi, priority: 0 }),
      h2: (t) => ({ conversion: hi, priority: 0 }),
      h3: (t) => ({ conversion: hi, priority: 0 }),
      h4: (t) => ({ conversion: hi, priority: 0 }),
      h5: (t) => ({ conversion: hi, priority: 0 }),
      h6: (t) => ({ conversion: hi, priority: 0 }),
      p: (t) => {
        const n = t.firstChild;
        return n !== null && tg(n) ? { conversion: () => ({ node: null }), priority: 3 } : null;
      },
      span: (t) => (tg(t) ? { conversion: (n) => ({ node: wn("h1") }), priority: 3 } : null),
    };
  }
  exportDOM(t) {
    const { element: n } = super.exportDOM(t);
    if (We(n)) {
      this.isEmpty() && n.append(document.createElement("br"));
      const r = this.getFormatType();
      r && (n.style.textAlign = r);
      const i = this.getDirection();
      i && (n.dir = i);
    }
    return { element: n };
  }
  static importJSON(t) {
    return wn(t.tag).updateFromJSON(t);
  }
  updateFromJSON(t) {
    return super.updateFromJSON(t).setTag(t.tag);
  }
  exportJSON() {
    return { ...super.exportJSON(), tag: this.getTag() };
  }
  insertNewAfter(t, n = !0) {
    const r = t ? t.anchor.offset : 0,
      i = this.getLastDescendant(),
      o = !i || (t && t.anchor.key === i.getKey() && r === i.getTextContentSize()) || !t ? Se() : wn(this.getTag()),
      s = this.getDirection();
    if ((o.setDirection(s), this.insertAfter(o, n), r === 0 && !this.isEmpty() && t)) {
      const l = Se();
      l.select(), this.replace(l, !0);
    }
    return o;
  }
  collapseAtStart() {
    const t = this.isEmpty() ? Se() : wn(this.getTag());
    return this.getChildren().forEach((n) => t.append(n)), this.replace(t), !0;
  }
  extractWithChild() {
    return !0;
  }
};
function tg(e) {
  return e.nodeName.toLowerCase() === "span" && e.style.fontSize === "26pt";
}
function hi(e) {
  const t = e.nodeName.toLowerCase();
  let n = null;
  return (
    (t !== "h1" && t !== "h2" && t !== "h3" && t !== "h4" && t !== "h5" && t !== "h6") ||
      ((n = wn(t)), e.style !== null && (pf(e, n), n.setFormat(e.style.textAlign))),
    { node: n }
  );
}
function zw(e) {
  const t = gs();
  return e.style !== null && (t.setFormat(e.style.textAlign), pf(e, t)), { node: t };
}
function wn(e = "h1") {
  return Mt(new ms(e));
}
function ba(e) {
  return e instanceof ms;
}
function $s(e) {
  let t = null;
  if ((dr(e, DragEvent) ? (t = e.dataTransfer) : dr(e, ClipboardEvent) && (t = e.clipboardData), t === null))
    return [!1, [], !1];
  const n = t.types,
    r = n.includes("Files"),
    i = n.includes("text/html") || n.includes("text/plain");
  return [r, Array.from(t.files), i];
}
function ng(e) {
  const t = J();
  if (!H(t)) return !1;
  const n = new Set(),
    r = t.getNodes();
  for (let i = 0; i < r.length; i++) {
    const o = r[i],
      s = o.getKey();
    if (n.has(s)) continue;
    const l = on(o, (u) => P(u) && !u.isInline());
    if (l === null) continue;
    const a = l.getKey();
    l.canIndent() && !n.has(a) && (n.add(a), e(l));
  }
  return n.size > 0;
}
function rg(e) {
  const t = An(e);
  return Te(t);
}
function gu(e) {
  for (const t of ["lowercase", "uppercase", "capitalize"]) e.hasFormat(t) && e.toggleFormat(t);
}
function jw(e) {
  return yt(
    e.registerCommand(
      Ql,
      (t) => {
        const n = J();
        return !!Je(n) && (n.clear(), !0);
      },
      be,
    ),
    e.registerCommand(
      Dr,
      (t) => {
        const n = J();
        return H(n) ? (n.deleteCharacter(t), !0) : !!Je(n) && (n.deleteNodes(), !0);
      },
      be,
    ),
    e.registerCommand(
      Uo,
      (t) => {
        const n = J();
        return !!H(n) && (n.deleteWord(t), !0);
      },
      be,
    ),
    e.registerCommand(
      Wo,
      (t) => {
        const n = J();
        return !!H(n) && (n.deleteLine(t), !0);
      },
      be,
    ),
    e.registerCommand(
      Si,
      (t) => {
        const n = J();
        if (typeof t == "string") n !== null && n.insertText(t);
        else {
          if (n === null) return !1;
          const r = t.dataTransfer;
          if (r != null) Gp(r, n, e);
          else if (H(n)) {
            const i = t.data;
            return i && n.insertText(i), !0;
          }
        }
        return !0;
      },
      be,
    ),
    e.registerCommand(
      uc,
      () => {
        const t = J();
        return !!H(t) && (t.removeText(), !0);
      },
      be,
    ),
    e.registerCommand(
      Un,
      (t) => {
        const n = J();
        return !!H(n) && (n.formatText(t), !0);
      },
      be,
    ),
    e.registerCommand(
      p_,
      (t) => {
        const n = J();
        if (!H(n) && !Je(n)) return !1;
        const r = n.getNodes();
        for (const i of r) {
          const o = on(i, (s) => P(s) && !s.isInline());
          o !== null && o.setFormat(t);
        }
        return !0;
      },
      be,
    ),
    e.registerCommand(
      ki,
      (t) => {
        const n = J();
        return !!H(n) && (n.insertLineBreak(t), !0);
      },
      be,
    ),
    e.registerCommand(
      jo,
      () => {
        const t = J();
        return !!H(t) && (t.insertParagraph(), !0);
      },
      be,
    ),
    e.registerCommand(G1, () => (Yi([Zi()]), !0), be),
    e.registerCommand(
      xl,
      () =>
        ng((t) => {
          const n = t.getIndent();
          t.setIndent(n + 1);
        }),
      be,
    ),
    e.registerCommand(
      cc,
      () =>
        ng((t) => {
          const n = t.getIndent();
          n > 0 && t.setIndent(Math.max(0, n - 1));
        }),
      be,
    ),
    e.registerCommand(
      zd,
      (t) => {
        const n = J();
        if (Je(n)) {
          const r = n.getNodes();
          if (r.length > 0) return r[0].selectPrevious(), !0;
        } else if (H(n)) {
          const r = vc(n.focus, !0);
          if (!t.shiftKey && Te(r) && !r.isIsolated() && !r.isInline())
            return r.selectPrevious(), t.preventDefault(), !0;
        }
        return !1;
      },
      be,
    ),
    e.registerCommand(
      jd,
      (t) => {
        const n = J();
        if (Je(n)) {
          const r = n.getNodes();
          if (r.length > 0) return r[0].selectNext(0, 0), !0;
        } else if (H(n)) {
          if (
            (function (i) {
              const o = i.focus;
              return o.key === "root" && o.offset === Ce().getChildrenSize();
            })(n)
          )
            return t.preventDefault(), !0;
          const r = vc(n.focus, !1);
          if (!t.shiftKey && Te(r) && !r.isIsolated() && !r.isInline()) return r.selectNext(), t.preventDefault(), !0;
        }
        return !1;
      },
      be,
    ),
    e.registerCommand(
      Vd,
      (t) => {
        const n = J();
        if (Je(n)) {
          const r = n.getNodes();
          if (r.length > 0) return t.preventDefault(), r[0].selectPrevious(), !0;
        }
        if (!H(n)) return !1;
        if (Up(n, !0)) {
          const r = t.shiftKey;
          return t.preventDefault(), Wp(n, r, !0), !0;
        }
        return !1;
      },
      be,
    ),
    e.registerCommand(
      J1,
      (t) => {
        const n = J();
        if (Je(n)) {
          const i = n.getNodes();
          if (i.length > 0) return t.preventDefault(), i[0].selectNext(0, 0), !0;
        }
        if (!H(n)) return !1;
        const r = t.shiftKey;
        return !!Up(n, !1) && (t.preventDefault(), Wp(n, r, !1), !0);
      },
      be,
    ),
    e.registerCommand(
      na,
      (t) => {
        if (rg(t.target)) return !1;
        const n = J();
        if (H(n)) {
          if (
            (function (r) {
              if (!r.isCollapsed()) return !1;
              const { anchor: i } = r;
              if (i.offset !== 0) return !1;
              const o = i.getNode();
              if (ut(o)) return !1;
              const s = Ec(o);
              return s.getIndent() > 0 && (s.is(o) || o.is(s.getFirstDescendant()));
            })(n)
          )
            return t.preventDefault(), e.dispatchCommand(cc, void 0);
          if (Qp && navigator.language === "ko-KR") return !1;
        } else if (!Je(n)) return !1;
        return t.preventDefault(), e.dispatchCommand(Dr, !0);
      },
      be,
    ),
    e.registerCommand(
      Wd,
      (t) => {
        if (rg(t.target)) return !1;
        const n = J();
        return !(!H(n) && !Je(n)) && (t.preventDefault(), e.dispatchCommand(Dr, !1));
      },
      be,
    ),
    e.registerCommand(
      Oi,
      (t) => {
        const n = J();
        if (!H(n)) return !1;
        if ((gu(n), t !== null)) {
          if ((Qp || Bw || Vw) && $w) return !1;
          if ((t.preventDefault(), t.shiftKey)) return e.dispatchCommand(ki, !1);
        }
        return e.dispatchCommand(jo, void 0);
      },
      be,
    ),
    e.registerCommand(
      ls,
      () => {
        const t = J();
        return !!H(t) && (e.blur(), !0);
      },
      be,
    ),
    e.registerCommand(
      Kd,
      (t) => {
        const [, n] = $s(t);
        if (n.length > 0) {
          const i = Xp(t.clientX, t.clientY);
          if (i !== null) {
            const { offset: o, node: s } = i,
              l = An(s);
            if (l !== null) {
              const a = qi();
              if (Z(l)) a.anchor.set(l.getKey(), o, "text"), a.focus.set(l.getKey(), o, "text");
              else {
                const c = l.getParentOrThrow().getKey(),
                  d = l.getIndexWithinParent() + 1;
                a.anchor.set(c, d, "element"), a.focus.set(c, d, "element");
              }
              const u = Kr(a);
              Ye(u);
            }
            e.dispatchCommand(eg, n);
          }
          return t.preventDefault(), !0;
        }
        const r = J();
        return !!H(r);
      },
      be,
    ),
    e.registerCommand(
      ia,
      (t) => {
        const [n] = $s(t),
          r = J();
        return !(n && !H(r));
      },
      be,
    ),
    e.registerCommand(
      Jd,
      (t) => {
        const [n] = $s(t),
          r = J();
        if (n && !H(r)) return !1;
        const i = Xp(t.clientX, t.clientY);
        if (i !== null) {
          const o = An(i.node);
          Te(o) && t.preventDefault();
        }
        return !0;
      },
      be,
    ),
    e.registerCommand(dc, () => (V_(), !0), be),
    e.registerCommand(oa, (t) => (qp(e, dr(t, ClipboardEvent) ? t : null), !0), be),
    e.registerCommand(
      Gd,
      (t) => (
        (async function (n, r) {
          await qp(r, dr(n, ClipboardEvent) ? n : null),
            r.update(() => {
              const i = J();
              H(i) ? i.removeText() : Je(i) && i.getNodes().forEach((o) => o.remove());
            });
        })(t, e),
        !0
      ),
      be,
    ),
    e.registerCommand(
      ss,
      (t) => {
        const [, n, r] = $s(t);
        return n.length > 0 && !r
          ? (e.dispatchCommand(eg, n), !0)
          : Qi(t.target) && of(t.target)
            ? !1
            : J() !== null &&
              ((function (i, o) {
                i.preventDefault(),
                  o.update(
                    () => {
                      const s = J(),
                        l = dr(i, InputEvent) || dr(i, KeyboardEvent) ? null : i.clipboardData;
                      l != null && s !== null && Gp(l, s, o);
                    },
                    { tag: O_ },
                  );
              })(t, e),
              !0);
      },
      be,
    ),
    e.registerCommand(
      Ud,
      (t) => {
        const n = J();
        return H(n) && gu(n), !1;
      },
      be,
    ),
    e.registerCommand(
      ra,
      (t) => {
        const n = J();
        return H(n) && gu(n), !1;
      },
      be,
    ),
  );
}
function $t(e, t, n, r) {
  const i = e.length;
  let o = 0,
    s;
  if ((t < 0 ? (t = -t > i ? 0 : i + t) : (t = t > i ? i : t), (n = n > 0 ? n : 0), r.length < 1e4))
    (s = Array.from(r)), s.unshift(t, n), e.splice(...s);
  else
    for (n && e.splice(t, n); o < r.length; )
      (s = r.slice(o, o + 1e4)), s.unshift(t, 0), e.splice(...s), (o += 1e4), (t += 1e4);
}
function jt(e, t) {
  return e.length > 0 ? ($t(e, e.length, 0, t), e) : t;
}
const Wt = _r(/[A-Za-z]/),
  Dt = _r(/[\dA-Za-z]/),
  Uw = _r(/[#-'*+\--9=?A-Z^-~]/);
function Ac(e) {
  return e !== null && (e < 32 || e === 127);
}
const Ic = _r(/\d/),
  Ww = _r(/[\dA-Fa-f]/),
  Kw = _r(/[!-/:-@[-`{-~]/);
function ee(e) {
  return e !== null && e < -2;
}
function Ae(e) {
  return e !== null && (e < 0 || e === 32);
}
function fe(e) {
  return e === -2 || e === -1 || e === 32;
}
const Jw = _r(new RegExp("\\p{P}|\\p{S}", "u")),
  Hn = _r(/\s/);
function _r(e) {
  return t;
  function t(n) {
    return n !== null && n > -1 && e.test(String.fromCharCode(n));
  }
}
function Al(e) {
  if (e === null || Ae(e) || Hn(e)) return 1;
  if (Jw(e)) return 2;
}
function ya(e, t, n) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; ) {
    const o = e[i].resolveAll;
    o && !r.includes(o) && ((t = o(t, n)), r.push(o));
  }
  return t;
}
function Gw(e) {
  let n = {}.singleTilde;
  const r = { name: "strikethrough", tokenize: o, resolveAll: i };
  return n == null && (n = !0), { text: { 126: r }, insideSpan: { null: [r] }, attentionMarkers: { null: [126] } };
  function i(s, l) {
    let a = -1;
    for (; ++a < s.length; )
      if (s[a][0] === "enter" && s[a][1].type === "strikethroughSequenceTemporary" && s[a][1]._close) {
        let u = a;
        for (; u--; )
          if (
            s[u][0] === "exit" &&
            s[u][1].type === "strikethroughSequenceTemporary" &&
            s[u][1]._open &&
            s[a][1].end.offset - s[a][1].start.offset === s[u][1].end.offset - s[u][1].start.offset
          ) {
            (s[a][1].type = "strikethroughSequence"), (s[u][1].type = "strikethroughSequence");
            const c = {
                type: "strikethrough",
                start: Object.assign({}, s[u][1].start),
                end: Object.assign({}, s[a][1].end),
              },
              d = {
                type: "strikethroughText",
                start: Object.assign({}, s[u][1].end),
                end: Object.assign({}, s[a][1].start),
              },
              f = [
                ["enter", c, l],
                ["enter", s[u][1], l],
                ["exit", s[u][1], l],
                ["enter", d, l],
              ],
              h = l.parser.constructs.insideSpan.null;
            h && $t(f, f.length, 0, ya(h, s.slice(u + 1, a), l)),
              $t(f, f.length, 0, [
                ["exit", d, l],
                ["enter", s[a][1], l],
                ["exit", s[a][1], l],
                ["exit", c, l],
              ]),
              $t(s, u - 1, a - u + 3, f),
              (a = u + f.length - 2);
            break;
          }
      }
    for (a = -1; ++a < s.length; ) s[a][1].type === "strikethroughSequenceTemporary" && (s[a][1].type = "data");
    return s;
  }
  function o(s, l, a) {
    const u = this.previous,
      c = this.events;
    let d = 0;
    return f;
    function f(p) {
      return u === 126 && c[c.length - 1][1].type !== "characterEscape"
        ? a(p)
        : (s.enter("strikethroughSequenceTemporary"), h(p));
    }
    function h(p) {
      const g = Al(u);
      if (p === 126) return d > 1 ? a(p) : (s.consume(p), d++, h);
      if (d < 2 && !n) return a(p);
      const x = s.exit("strikethroughSequenceTemporary"),
        b = Al(p);
      return (x._open = !b || (b === 2 && !!g)), (x._close = !g || (g === 2 && !!b)), l(p);
    }
  }
}
const Zw = ["autolink", "destinationLiteral", "destinationRaw", "reference", "titleQuote", "titleApostrophe"];
Y0.peek = eE;
function qw() {
  return { canContainEols: ["delete"], enter: { strikethrough: Xw }, exit: { strikethrough: Qw } };
}
function Yw() {
  return { unsafe: [{ character: "~", inConstruct: "phrasing", notInConstruct: Zw }], handlers: { delete: Y0 } };
}
function Xw(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function Qw(e) {
  this.exit(e);
}
function Y0(e, t, n, r) {
  const i = n.createTracker(r),
    o = n.enter("strikethrough");
  let s = i.move("~~");
  return (s += n.containerPhrasing(e, { ...i.current(), before: s, after: "~" })), (s += i.move("~~")), o(), s;
}
function eE() {
  return "~";
}
function ig(e, t) {
  const n = String(e);
  if (typeof t != "string") throw new TypeError("Expected character");
  let r = 0,
    i = n.indexOf(t);
  for (; i !== -1; ) r++, (i = n.indexOf(t, i + t.length));
  return r;
}
const tE = [
    "AElig",
    "AMP",
    "Aacute",
    "Acirc",
    "Agrave",
    "Aring",
    "Atilde",
    "Auml",
    "COPY",
    "Ccedil",
    "ETH",
    "Eacute",
    "Ecirc",
    "Egrave",
    "Euml",
    "GT",
    "Iacute",
    "Icirc",
    "Igrave",
    "Iuml",
    "LT",
    "Ntilde",
    "Oacute",
    "Ocirc",
    "Ograve",
    "Oslash",
    "Otilde",
    "Ouml",
    "QUOT",
    "REG",
    "THORN",
    "Uacute",
    "Ucirc",
    "Ugrave",
    "Uuml",
    "Yacute",
    "aacute",
    "acirc",
    "acute",
    "aelig",
    "agrave",
    "amp",
    "aring",
    "atilde",
    "auml",
    "brvbar",
    "ccedil",
    "cedil",
    "cent",
    "copy",
    "curren",
    "deg",
    "divide",
    "eacute",
    "ecirc",
    "egrave",
    "eth",
    "euml",
    "frac12",
    "frac14",
    "frac34",
    "gt",
    "iacute",
    "icirc",
    "iexcl",
    "igrave",
    "iquest",
    "iuml",
    "laquo",
    "lt",
    "macr",
    "micro",
    "middot",
    "nbsp",
    "not",
    "ntilde",
    "oacute",
    "ocirc",
    "ograve",
    "ordf",
    "ordm",
    "oslash",
    "otilde",
    "ouml",
    "para",
    "plusmn",
    "pound",
    "quot",
    "raquo",
    "reg",
    "sect",
    "shy",
    "sup1",
    "sup2",
    "sup3",
    "szlig",
    "thorn",
    "times",
    "uacute",
    "ucirc",
    "ugrave",
    "uml",
    "uuml",
    "yacute",
    "yen",
    "yuml",
  ],
  og = {
    0: "�",
    128: "€",
    130: "‚",
    131: "ƒ",
    132: "„",
    133: "…",
    134: "†",
    135: "‡",
    136: "ˆ",
    137: "‰",
    138: "Š",
    139: "‹",
    140: "Œ",
    142: "Ž",
    145: "‘",
    146: "’",
    147: "“",
    148: "”",
    149: "•",
    150: "–",
    151: "—",
    152: "˜",
    153: "™",
    154: "š",
    155: "›",
    156: "œ",
    158: "ž",
    159: "Ÿ",
  };
function X0(e) {
  const t = typeof e == "string" ? e.charCodeAt(0) : e;
  return t >= 48 && t <= 57;
}
function nE(e) {
  const t = typeof e == "string" ? e.charCodeAt(0) : e;
  return (t >= 97 && t <= 102) || (t >= 65 && t <= 70) || (t >= 48 && t <= 57);
}
function rE(e) {
  const t = typeof e == "string" ? e.charCodeAt(0) : e;
  return (t >= 97 && t <= 122) || (t >= 65 && t <= 90);
}
function sg(e) {
  return rE(e) || X0(e);
}
const pi = String.fromCharCode,
  iE = [
    "",
    "Named character references must be terminated by a semicolon",
    "Numeric character references must be terminated by a semicolon",
    "Named character references cannot be empty",
    "Numeric character references cannot be empty",
    "Named character references must be known",
    "Numeric character references cannot be disallowed",
    "Numeric character references cannot be outside the permissible Unicode range",
  ];
function Ca(e, t = {}) {
  const n = typeof t.additional == "string" ? t.additional.charCodeAt(0) : t.additional,
    r = [];
  let i = 0,
    o = -1,
    s = "",
    l,
    a;
  t.position &&
    ("start" in t.position || "indent" in t.position
      ? ((a = t.position.indent), (l = t.position.start))
      : (l = t.position));
  let u = (l ? l.line : 0) || 1,
    c = (l ? l.column : 0) || 1,
    d = h(),
    f;
  for (i--; ++i <= e.length; )
    if ((f === 10 && (c = (a ? a[o] : 0) || 1), (f = e.charCodeAt(i)), f === 38)) {
      const x = e.charCodeAt(i + 1);
      if (x === 9 || x === 10 || x === 12 || x === 32 || x === 38 || x === 60 || Number.isNaN(x) || (n && x === n)) {
        (s += pi(f)), c++;
        continue;
      }
      const b = i + 1;
      let m = b,
        v = b,
        _;
      if (x === 35) {
        v = ++m;
        const R = e.charCodeAt(v);
        R === 88 || R === 120 ? ((_ = "hexadecimal"), (v = ++m)) : (_ = "decimal");
      } else _ = "named";
      let k = "",
        w = "",
        y = "";
      const S = _ === "named" ? sg : _ === "decimal" ? X0 : nE;
      for (v--; ++v <= e.length; ) {
        const R = e.charCodeAt(v);
        if (!S(R)) break;
        (y += pi(R)), _ === "named" && tE.includes(y) && ((k = y), (w = $o(y)));
      }
      let T = e.charCodeAt(v) === 59;
      if (T) {
        v++;
        const R = _ === "named" ? $o(y) : !1;
        R && ((k = y), (w = R));
      }
      let A = 1 + v - b,
        F = "";
      if (!(!T && t.nonTerminated === !1))
        if (!y) _ !== "named" && p(4, A);
        else if (_ === "named") {
          if (T && !w) p(5, 1);
          else if ((k !== y && ((v = m + k.length), (A = 1 + v - m), (T = !1)), !T)) {
            const R = k ? 1 : 3;
            if (t.attribute) {
              const V = e.charCodeAt(v);
              V === 61 ? (p(R, A), (w = "")) : sg(V) ? (w = "") : p(R, A);
            } else p(R, A);
          }
          F = w;
        } else {
          T || p(2, A);
          let R = Number.parseInt(y, _ === "hexadecimal" ? 16 : 10);
          if (oE(R)) p(7, A), (F = pi(65533));
          else if (R in og) p(6, A), (F = og[R]);
          else {
            let V = "";
            sE(R) && p(6, A),
              R > 65535 && ((R -= 65536), (V += pi((R >>> 10) | 55296)), (R = 56320 | (R & 1023))),
              (F = V + pi(R));
          }
        }
      if (F) {
        g(), (d = h()), (i = v - 1), (c += v - b + 1), r.push(F);
        const R = h();
        R.offset++,
          t.reference && t.reference.call(t.referenceContext, F, { start: d, end: R }, e.slice(b - 1, v)),
          (d = R);
      } else (y = e.slice(b - 1, v)), (s += y), (c += y.length), (i = v - 1);
    } else f === 10 && (u++, o++, (c = 0)), Number.isNaN(f) ? g() : ((s += pi(f)), c++);
  return r.join("");
  function h() {
    return { line: u, column: c, offset: i + ((l ? l.offset : 0) || 0) };
  }
  function p(x, b) {
    let m;
    t.warning && ((m = h()), (m.column += b), (m.offset += b), t.warning.call(t.warningContext, iE[x], m, x));
  }
  function g() {
    s && (r.push(s), t.text && t.text.call(t.textContext, s, { start: d, end: h() }), (s = ""));
  }
}
function oE(e) {
  return (e >= 55296 && e <= 57343) || e > 1114111;
}
function sE(e) {
  return (
    (e >= 1 && e <= 8) ||
    e === 11 ||
    (e >= 13 && e <= 31) ||
    (e >= 127 && e <= 159) ||
    (e >= 64976 && e <= 65007) ||
    (e & 65535) === 65535 ||
    (e & 65535) === 65534
  );
}
const lE = /["&'<>`]/g,
  aE = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
  uE = /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g,
  cE = /[|\\{}()[\]^$+*?.]/g,
  lg = new WeakMap();
function dE(e, t) {
  if (((e = e.replace(t.subset ? fE(t.subset) : lE, r)), t.subset || t.escapeOnly)) return e;
  return e.replace(aE, n).replace(uE, r);
  function n(i, o, s) {
    return t.format((i.charCodeAt(0) - 55296) * 1024 + i.charCodeAt(1) - 56320 + 65536, s.charCodeAt(o + 2), t);
  }
  function r(i, o, s) {
    return t.format(i.charCodeAt(0), s.charCodeAt(o + 1), t);
  }
}
function fE(e) {
  let t = lg.get(e);
  return t || ((t = hE(e)), lg.set(e, t)), t;
}
function hE(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; ) t.push(e[n].replace(cE, "\\$&"));
  return new RegExp("(?:" + t.join("|") + ")", "g");
}
function pE(e) {
  return "&#x" + e.toString(16).toUpperCase() + ";";
}
function Q0(e, t) {
  return dE(e, Object.assign({ format: pE }, t));
}
function Wn(e) {
  return !e || typeof e != "object"
    ? ""
    : "position" in e || "type" in e
      ? ag(e.position)
      : "start" in e || "end" in e
        ? ag(e)
        : "line" in e || "column" in e
          ? Nc(e)
          : "";
}
function Nc(e) {
  return ug(e && e.line) + ":" + ug(e && e.column);
}
function ag(e) {
  return Nc(e && e.start) + "-" + Nc(e && e.end);
}
function ug(e) {
  return e && typeof e == "number" ? e : 1;
}
class Me extends Error {
  constructor(t, n, r) {
    super(), typeof n == "string" && ((r = n), (n = void 0));
    let i = "",
      o = {},
      s = !1;
    if (
      (n &&
        ("line" in n && "column" in n
          ? (o = { place: n })
          : "start" in n && "end" in n
            ? (o = { place: n })
            : "type" in n
              ? (o = { ancestors: [n], place: n.position })
              : (o = { ...n })),
      typeof t == "string" ? (i = t) : !o.cause && t && ((s = !0), (i = t.message), (o.cause = t)),
      !o.ruleId && !o.source && typeof r == "string")
    ) {
      const a = r.indexOf(":");
      a === -1 ? (o.ruleId = r) : ((o.source = r.slice(0, a)), (o.ruleId = r.slice(a + 1)));
    }
    if (!o.place && o.ancestors && o.ancestors) {
      const a = o.ancestors[o.ancestors.length - 1];
      a && (o.place = a.position);
    }
    const l = o.place && "start" in o.place ? o.place.start : o.place;
    (this.ancestors = o.ancestors || void 0),
      (this.cause = o.cause || void 0),
      (this.column = l ? l.column : void 0),
      (this.fatal = void 0),
      this.file,
      (this.message = i),
      (this.line = l ? l.line : void 0),
      (this.name = Wn(o.place) || "1:1"),
      (this.place = o.place || void 0),
      (this.reason = this.message),
      (this.ruleId = o.ruleId || void 0),
      (this.source = o.source || void 0),
      (this.stack = s && o.cause && typeof o.cause.stack == "string" ? o.cause.stack : ""),
      this.actual,
      this.expected,
      this.note,
      this.url;
  }
}
Me.prototype.file = "";
Me.prototype.name = "";
Me.prototype.reason = "";
Me.prototype.message = "";
Me.prototype.stack = "";
Me.prototype.column = void 0;
Me.prototype.line = void 0;
Me.prototype.ancestors = void 0;
Me.prototype.cause = void 0;
Me.prototype.fatal = void 0;
Me.prototype.place = void 0;
Me.prototype.ruleId = void 0;
Me.prototype.source = void 0;
const ex = "  ";
function gE() {
  return {
    canContainEols: ["mdxJsxTextElement"],
    enter: {
      mdxJsxFlowTag: r,
      mdxJsxFlowTagClosingMarker: i,
      mdxJsxFlowTagAttribute: d,
      mdxJsxFlowTagExpressionAttribute: f,
      mdxJsxFlowTagAttributeValueLiteral: e,
      mdxJsxFlowTagAttributeValueExpression: e,
      mdxJsxFlowTagSelfClosingMarker: s,
      mdxJsxTextTag: r,
      mdxJsxTextTagClosingMarker: i,
      mdxJsxTextTagAttribute: d,
      mdxJsxTextTagExpressionAttribute: f,
      mdxJsxTextTagAttributeValueLiteral: e,
      mdxJsxTextTagAttributeValueExpression: e,
      mdxJsxTextTagSelfClosingMarker: s,
    },
    exit: {
      mdxJsxFlowTagClosingMarker: l,
      mdxJsxFlowTagNamePrimary: a,
      mdxJsxFlowTagNameMember: u,
      mdxJsxFlowTagNameLocal: c,
      mdxJsxFlowTagExpressionAttribute: h,
      mdxJsxFlowTagExpressionAttributeValue: n,
      mdxJsxFlowTagAttributeNamePrimary: p,
      mdxJsxFlowTagAttributeNameLocal: g,
      mdxJsxFlowTagAttributeValueLiteral: x,
      mdxJsxFlowTagAttributeValueLiteralValue: n,
      mdxJsxFlowTagAttributeValueExpression: b,
      mdxJsxFlowTagAttributeValueExpressionValue: n,
      mdxJsxFlowTagSelfClosingMarker: m,
      mdxJsxFlowTag: v,
      mdxJsxTextTagClosingMarker: l,
      mdxJsxTextTagNamePrimary: a,
      mdxJsxTextTagNameMember: u,
      mdxJsxTextTagNameLocal: c,
      mdxJsxTextTagExpressionAttribute: h,
      mdxJsxTextTagExpressionAttributeValue: n,
      mdxJsxTextTagAttributeNamePrimary: p,
      mdxJsxTextTagAttributeNameLocal: g,
      mdxJsxTextTagAttributeValueLiteral: x,
      mdxJsxTextTagAttributeValueLiteralValue: n,
      mdxJsxTextTagAttributeValueExpression: b,
      mdxJsxTextTagAttributeValueExpressionValue: n,
      mdxJsxTextTagSelfClosingMarker: m,
      mdxJsxTextTag: v,
    },
  };
  function e() {
    this.buffer();
  }
  function t(y) {
    return { line: y.line, column: y.column, offset: y.offset };
  }
  function n(y) {
    this.config.enter.data.call(this, y), this.config.exit.data.call(this, y);
  }
  function r(y) {
    const S = { name: void 0, attributes: [], close: !1, selfClosing: !1, start: y.start, end: y.end };
    this.data.mdxJsxTagStack || (this.data.mdxJsxTagStack = []), (this.data.mdxJsxTag = S), this.buffer();
  }
  function i(y) {
    if (this.data.mdxJsxTagStack.length === 0)
      throw new Me(
        "Unexpected closing slash `/` in tag, expected an open tag first",
        { start: y.start, end: y.end },
        "mdast-util-mdx-jsx:unexpected-closing-slash",
      );
  }
  function o(y) {
    if (this.data.mdxJsxTag.close)
      throw new Me(
        "Unexpected attribute in closing tag, expected the end of the tag",
        { start: y.start, end: y.end },
        "mdast-util-mdx-jsx:unexpected-attribute",
      );
  }
  function s(y) {
    if (this.data.mdxJsxTag.close)
      throw new Me(
        "Unexpected self-closing slash `/` in closing tag, expected the end of the tag",
        { start: y.start, end: y.end },
        "mdast-util-mdx-jsx:unexpected-self-closing-slash",
      );
  }
  function l() {
    const y = this.data.mdxJsxTag;
    y.close = !0;
  }
  function a(y) {
    const S = this.data.mdxJsxTag;
    S.name = this.sliceSerialize(y);
  }
  function u(y) {
    const S = this.data.mdxJsxTag;
    S.name += "." + this.sliceSerialize(y);
  }
  function c(y) {
    const S = this.data.mdxJsxTag;
    S.name += ":" + this.sliceSerialize(y);
  }
  function d(y) {
    const S = this.data.mdxJsxTag;
    o.call(this, y),
      S.attributes.push({
        type: "mdxJsxAttribute",
        name: "",
        value: null,
        position: { start: t(y.start), end: void 0 },
      });
  }
  function f(y) {
    const S = this.data.mdxJsxTag;
    o.call(this, y), S.attributes.push({ type: "mdxJsxExpressionAttribute", value: "" }), this.buffer();
  }
  function h(y) {
    const S = this.data.mdxJsxTag,
      T = S.attributes[S.attributes.length - 1];
    T.type;
    const A = y.estree;
    (T.value = this.resume()), A && (T.data = { estree: A });
  }
  function p(y) {
    const S = this.data.mdxJsxTag,
      T = S.attributes[S.attributes.length - 1];
    T.type, (T.name = this.sliceSerialize(y)), T.position, (T.position.end = t(y.end));
  }
  function g(y) {
    const S = this.data.mdxJsxTag,
      T = S.attributes[S.attributes.length - 1];
    T.type, (T.name += ":" + this.sliceSerialize(y)), T.position, (T.position.end = t(y.end));
  }
  function x(y) {
    const S = this.data.mdxJsxTag,
      T = S.attributes[S.attributes.length - 1];
    (T.value = Ca(this.resume(), { nonTerminated: !1 })), T.position, (T.position.end = t(y.end));
  }
  function b(y) {
    const S = this.data.mdxJsxTag,
      T = S.attributes[S.attributes.length - 1];
    T.type;
    const A = { type: "mdxJsxAttributeValueExpression", value: this.resume() },
      F = y.estree;
    F && (A.data = { estree: F }), (T.value = A), T.position, (T.position.end = t(y.end));
  }
  function m() {
    const y = this.data.mdxJsxTag;
    y.selfClosing = !0;
  }
  function v(y) {
    const S = this.data.mdxJsxTag,
      T = this.data.mdxJsxTagStack,
      A = T[T.length - 1];
    if (S.close && A.name !== S.name)
      throw new Me(
        "Unexpected closing tag `" + w(S) + "`, expected corresponding closing tag for `" + w(A) + "` (" + Wn(A) + ")",
        { start: y.start, end: y.end },
        "mdast-util-mdx-jsx:end-tag-mismatch",
      );
    this.resume(),
      S.close
        ? T.pop()
        : this.enter(
            {
              type: y.type === "mdxJsxTextTag" ? "mdxJsxTextElement" : "mdxJsxFlowElement",
              name: S.name || null,
              attributes: S.attributes,
              children: [],
            },
            y,
            _,
          ),
      S.selfClosing || S.close ? this.exit(y, k) : T.push(S);
  }
  function _(y, S) {
    const T = this.data.mdxJsxTagStack,
      A = T[T.length - 1],
      F = y ? " before the end of `" + y.type + "`" : "",
      R = y ? { start: y.start, end: y.end } : void 0;
    throw new Me(
      "Expected a closing tag for `" + w(A) + "` (" + Wn({ start: S.start, end: S.end }) + ")" + F,
      R,
      "mdast-util-mdx-jsx:end-tag-mismatch",
    );
  }
  function k(y, S) {
    const T = this.data.mdxJsxTag;
    throw new Me(
      "Expected the closing tag `" +
        w(T) +
        "` either after the end of `" +
        S.type +
        "` (" +
        Wn(S.end) +
        ") or another opening tag after the start of `" +
        S.type +
        "` (" +
        Wn(S.start) +
        ")",
      { start: y.start, end: y.end },
      "mdast-util-mdx-jsx:end-tag-mismatch",
    );
  }
  function w(y) {
    return "<" + (y.close ? "/" : "") + (y.name || "") + ">";
  }
}
function mE(e) {
  const t = {},
    n = t.quote || '"',
    r = t.quoteSmart || !1,
    i = t.tightSelfClosing || !1,
    o = t.printWidth || Number.POSITIVE_INFINITY,
    s = n === '"' ? "'" : '"';
  if (n !== '"' && n !== "'")
    throw new Error("Cannot serialize attribute values with `" + n + "` for `options.quote`, expected `\"`, or `'`");
  return (
    (l.peek = vE),
    {
      handlers: { mdxJsxFlowElement: l, mdxJsxTextElement: l },
      unsafe: [
        { character: "<", inConstruct: ["phrasing"] },
        { atBreak: !0, character: "<" },
      ],
      fences: !0,
      resourceLink: !0,
    }
  );
  function l(a, u, c, d) {
    const f = a.type === "mdxJsxFlowElement",
      h = a.name ? !a.children || a.children.length === 0 : !1,
      p = tx(c),
      g = nx(p),
      x = c.createTracker(d),
      b = c.createTracker(d),
      m = [],
      v = (f ? g : "") + "<" + (a.name || ""),
      _ = c.enter(a.type);
    if ((x.move(v), b.move(v), a.attributes && a.attributes.length > 0)) {
      if (!a.name) throw new Error("Cannot serialize fragment w/ attributes");
      let T = -1;
      for (; ++T < a.attributes.length; ) {
        const A = a.attributes[T];
        let F;
        if (A.type === "mdxJsxExpressionAttribute") F = "{" + (A.value || "") + "}";
        else {
          if (!A.name) throw new Error("Cannot serialize attribute w/o name");
          const R = A.value,
            V = A.name;
          let B = "";
          if (R != null)
            if (typeof R == "object") B = "{" + (R.value || "") + "}";
            else {
              const N = r && ig(R, n) > ig(R, s) ? s : n;
              B = N + Q0(R, { subset: [N] }) + N;
            }
          F = V + (B ? "=" : "") + B;
        }
        m.push(F);
      }
    }
    let k = !1;
    const w = m.join(" ");
    f && (/\r?\n|\r/.test(w) || x.current().now.column + w.length + (h ? (i ? 2 : 3) : 1) > o) && (k = !0);
    let y = x,
      S = v;
    if (k) {
      y = b;
      let T = -1;
      for (; ++T < m.length; ) m[T] = g + ex + m[T];
      S += y.move(
        `
` +
          m.join(`
`) +
          `
` +
          g,
      );
    } else w && (S += y.move(" " + w));
    return (
      h && (S += y.move((i || k ? "" : " ") + "/")),
      (S += y.move(">")),
      a.children &&
        a.children.length > 0 &&
        (a.type === "mdxJsxTextElement"
          ? (S += y.move(c.containerPhrasing(a, { ...y.current(), before: ">", after: "<" })))
          : (y.shift(2),
            (S += y.move(`
`)),
            (S += y.move(xE(a, c, y.current()))),
            (S += y.move(`
`)))),
      h || (S += y.move((f ? g : "") + "</" + (a.name || "") + ">")),
      _(),
      S
    );
  }
}
function xE(e, t, n) {
  const r = t.indexStack,
    i = e.children,
    o = t.createTracker(n),
    s = nx(tx(t)),
    l = [];
  let a = -1;
  for (r.push(-1); ++a < i.length; ) {
    const u = i[a];
    r[r.length - 1] = a;
    const c = {
        before: `
`,
        after: `
`,
        ...o.current(),
      },
      d = t.handle(u, e, t, c),
      f =
        u.type === "mdxJsxFlowElement"
          ? d
          : t.indentLines(d, function (h, p, g) {
              return (g ? "" : s) + h;
            });
    l.push(o.move(f)),
      u.type !== "list" && (t.bulletLastUsed = void 0),
      a < i.length - 1 &&
        l.push(
          o.move(`

`),
        );
  }
  return r.pop(), l.join("");
}
function tx(e) {
  let t = 0,
    n = e.stack.length;
  for (; --n > -1; ) {
    const r = e.stack[n];
    if (r === "blockquote" || r === "listItem") break;
    r === "mdxJsxFlowElement" && t++;
  }
  return t;
}
function nx(e) {
  return ex.repeat(e);
}
function vE() {
  return "<";
}
const bE = /[$_\p{ID_Start}]/u,
  yE = /[$_\u{200C}\u{200D}\p{ID_Continue}]/u,
  CE = /[-$_\u{200C}\u{200D}\p{ID_Continue}]/u,
  _E = {};
function qt(e) {
  return e ? bE.test(String.fromCodePoint(e)) : !1;
}
function po(e, t) {
  const r = (t || _E).jsx ? CE : yE;
  return e ? r.test(String.fromCodePoint(e)) : !1;
}
const wE = {}.hasOwnProperty,
  EE = Symbol("continue"),
  mu = Symbol("exit"),
  kE = Symbol("skip");
function SE(e, t) {
  let n, r;
  typeof t == "function" ? (n = t) : t && typeof t == "object" && (t.enter && (n = t.enter), t.leave && (r = t.leave)),
    i(e, void 0, void 0, [])();
  function i(o, s, l, a) {
    return xu(o) && (u.displayName = "node (" + o.type + ")"), u;
    function u() {
      const c = n ? cg(n(o, s, l, a)) : [];
      if (c[0] === mu) return c;
      if (c[0] !== kE) {
        let d;
        for (d in o)
          if (wE.call(o, d) && o[d] && typeof o[d] == "object" && d !== "data" && d !== "position") {
            const f = a.concat(o),
              h = o[d];
            if (Array.isArray(h)) {
              const p = h;
              let g = 0;
              for (; g > -1 && g < p.length; ) {
                const x = p[g];
                if (xu(x)) {
                  const b = i(x, d, g, f)();
                  if (b[0] === mu) return b;
                  g = typeof b[1] == "number" ? b[1] : g + 1;
                } else g++;
              }
            } else if (xu(h)) {
              const p = i(h, d, void 0, f)();
              if (p[0] === mu) return p;
            }
          }
      }
      return r ? cg(r(o, s, l, a)) : c;
    }
  }
}
function cg(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [EE, e] : [e];
}
function xu(e) {
  return !!(e && typeof e == "object" && "type" in e && typeof e.type == "string" && e.type.length > 0);
}
function TE(e, t) {
  const n = t.prefix || "",
    r = t.suffix || "",
    i = Object.assign({}, t.acornOptions),
    o = [],
    s = [],
    l = i.onComment,
    a = i.onToken;
  let u = !1,
    c,
    d;
  const f = Object.assign({}, i, { onComment: o, preserveParens: !0 });
  a && (f.onToken = s);
  const h = AE(e, t.tokenTypes),
    p = h.value,
    g = n + p + r,
    x = dg(p);
  if (x && !t.allowEmpty)
    throw new Me("Unexpected empty expression", {
      place: m(0),
      ruleId: "unexpected-empty-expression",
      source: "micromark-extension-mdx-expression",
    });
  try {
    c = t.expression && !x ? t.acorn.parseExpressionAt(g, 0, f) : t.acorn.parse(g, f);
  } catch (v) {
    const _ = v,
      k = m(_.pos);
    (_.message = String(_.message).replace(/ \(\d+:\d+\)$/, "")),
      (_.pos = k.offset),
      (_.loc = { line: k.line, column: k.column - 1 }),
      (d = _),
      (u = _.raisedAt >= n.length + p.length || _.message === "Unterminated comment");
  }
  if (c && t.expression && !x)
    if (dg(g.slice(c.end, g.length - r.length)))
      c = {
        type: "Program",
        start: 0,
        end: n.length + p.length,
        body: [{ type: "ExpressionStatement", expression: c, start: 0, end: n.length + p.length }],
        sourceType: "module",
        comments: [],
      };
    else {
      const v = m(c.end),
        _ = new Error("Unexpected content after expression");
      (_.pos = v.offset), (_.loc = { line: v.line, column: v.column - 1 }), (d = _), (c = void 0);
    }
  if (c) {
    if (
      ((c.comments = o),
      SE(c, function (v, _, k, w) {
        let y = w[w.length - 1],
          S = _;
        v.type === "ParenthesizedExpression" &&
          y &&
          S &&
          (typeof k == "number" && ((y = y[S]), (S = k)), (y[S] = v.expression)),
          b(v);
      }),
      Array.isArray(l))
    )
      l.push(...o);
    else if (typeof l == "function")
      for (const v of o) l(v.type === "Block", v.value, v.start, v.end, v.loc.start, v.loc.end);
    for (const v of s)
      v.end <= n.length || v.start - n.length >= p.length || (b(v), Array.isArray(a) ? a.push(v) : a(v));
  }
  return { estree: c, error: d, swallow: u };
  function b(v) {
    const _ = m(v.start),
      k = m(v.end);
    (v.start = _.offset),
      (v.end = k.offset),
      (v.loc = {
        start: { line: _.line, column: _.column - 1, offset: _.offset },
        end: { line: k.line, column: k.column - 1, offset: k.offset },
      }),
      (v.range = [v.start, v.end]);
  }
  function m(v) {
    let _ = v - n.length;
    _ < 0 ? (_ = 0) : _ > p.length && (_ = p.length);
    let k = IE(h.stops, _);
    return k || (k = { line: t.start.line, column: t.start.column, offset: t.start.offset }), k;
  }
}
function dg(e) {
  return /^\s*$/.test(e.replace(/\/\*[\s\S]*?\*\//g, "").replace(/\/\/[^\r\n]*(\r\n|\n|\r)/g, ""));
}
function AE(e, t) {
  const n = { value: "", stops: [] };
  let r = -1;
  for (; ++r < e.length; ) {
    const i = e[r];
    if (i[0] === "enter") {
      const o = i[1].type;
      if (o === "lineEnding" || t.includes(o)) {
        const s = i[2].sliceStream(i[1]);
        for (; s.length > 0 && s[0] === -1; ) s.shift();
        const l = NE(s);
        n.stops.push([n.value.length, i[1].start]), (n.value += l), n.stops.push([n.value.length, i[1].end]);
      }
    }
  }
  return n;
}
function IE(e, t) {
  let n = 0;
  for (; n < e.length && e[n][0] <= t; ) n += 1;
  if (n === 0) return;
  const [r, i] = e[n - 1],
    o = t - r;
  return { line: i.line, column: i.column + o, offset: i.offset + o };
}
function NE(e) {
  let t = -1;
  const n = [];
  let r;
  for (; ++t < e.length; ) {
    const i = e[t];
    let o;
    if (typeof i == "string") o = i;
    else
      switch (i) {
        case -5: {
          o = "\r";
          break;
        }
        case -4: {
          o = `
`;
          break;
        }
        case -3: {
          o = `\r
`;
          break;
        }
        case -2: {
          o = "	";
          break;
        }
        case -1: {
          if (r) continue;
          o = " ";
          break;
        }
        default:
          o = String.fromCharCode(i);
      }
    (r = i === -2), n.push(o);
  }
  return n.join("");
}
function vu(e) {
  const t = e || {},
    n = t.loc || {},
    r = t.range || [void 0, void 0],
    i = fg(n.start, r[0] || t.start),
    o = fg(n.end, r[1] || t.end);
  if (i && o) return { start: i, end: o };
}
function fg(e, t) {
  if (e && typeof e == "object") {
    const n = "line" in e ? bu(e.line) : void 0,
      r = "column" in e ? bu(e.column) : void 0;
    if (n && r !== void 0) return { line: n, column: r + 1, offset: bu(t) };
  }
}
function bu(e) {
  return typeof e == "number" && e > -1 ? e : void 0;
}
const _i =
    "https://github.com/micromark/micromark-extension-mdx-expression/tree/main/packages/micromark-extension-mdx-expression",
  LE = "#unexpected-end-of-file-in-expression-expected-a-corresponding-closing-brace-for-",
  ME = "#unexpected-lazy-line-in-expression-in-container-expected-line-to-be-prefixed",
  hg = "#unexpected-type-in-code-expected-an-object-spread-spread",
  OE = "#unexpected-extra-content-in-spread-only-a-single-spread-is-supported",
  FE = "#could-not-parse-expression-with-acorn";
function pg(e, t, n, r, i, o, s, l, a, u, c) {
  const d = this,
    f = this.events.length + 3;
  let h = 0,
    p,
    g;
  return x;
  function x(_) {
    return e.enter(n), e.enter(r), e.consume(_), e.exit(r), (p = d.now()), b;
  }
  function b(_) {
    if (_ === null) {
      if (g) throw g;
      const k = new Me("Unexpected end of file in expression, expected a corresponding closing brace for `{`", {
        place: d.now(),
        ruleId: "unexpected-eof",
        source: "micromark-extension-mdx-expression",
      });
      throw ((k.url = _i + LE), k);
    }
    if (ee(_)) return e.enter("lineEnding"), e.consume(_), e.exit("lineEnding"), v;
    if (_ === 125 && h === 0) {
      const k = o ? RE.call(d, o, s, i, f, p, u || !1, a || !1) : { type: "ok", estree: void 0 };
      if (k.type === "ok") {
        e.enter(r), e.consume(_), e.exit(r);
        const w = e.exit(n);
        return l && k.estree && Object.assign(w, { estree: k.estree }), t;
      }
      return (g = k.message), e.enter(i), e.consume(_), m;
    }
    return e.enter(i), m(_);
  }
  function m(_) {
    return (_ === 125 && h === 0) || _ === null || ee(_)
      ? (e.exit(i), b(_))
      : (_ === 123 && !o ? (h += 1) : _ === 125 && (h -= 1), e.consume(_), m);
  }
  function v(_) {
    const k = d.now();
    if (k.line !== p.line && !c && d.parser.lazy[k.line]) {
      const w = new Me(
        "Unexpected lazy line in expression in container, expected line to be prefixed with `>` when in a block quote, whitespace when in a list, etc",
        { place: d.now(), ruleId: "unexpected-lazy", source: "micromark-extension-mdx-expression" },
      );
      throw ((w.url = _i + ME), w);
    }
    return b(_);
  }
}
function RE(e, t, n, r, i, o, s) {
  const l = TE(this.events.slice(r), {
      acorn: e,
      tokenTypes: [n],
      acornOptions: t,
      start: i,
      expression: !0,
      allowEmpty: o,
      prefix: s ? "({" : "",
      suffix: s ? "})" : "",
    }),
    a = l.estree;
  if (s && a) {
    const u = a.body[0];
    if (u.type !== "ExpressionStatement" || u.expression.type !== "ObjectExpression") {
      const c = vu(u),
        d = new Me("Unexpected `" + u.type + "` in code: expected an object spread (`{...spread}`)", {
          place: c.start,
          ruleId: "non-spread",
          source: "micromark-extension-mdx-expression",
        });
      throw ((d.url = _i + hg), d);
    }
    if (u.expression.properties[1]) {
      const c = vu(u.expression.properties[1]),
        d = new Me("Unexpected extra content in spread: only a single spread is supported", {
          place: c.start,
          ruleId: "spread-extra",
          source: "micromark-extension-mdx-expression",
        });
      throw ((d.url = _i + OE), d);
    }
    if (u.expression.properties[0] && u.expression.properties[0].type !== "SpreadElement") {
      const c = vu(u.expression.properties[0]),
        d = new Me("Unexpected `" + u.expression.properties[0].type + "` in code: only spread elements are supported", {
          place: c.start,
          ruleId: "non-spread",
          source: "micromark-extension-mdx-expression",
        });
      throw ((d.url = _i + hg), d);
    }
  }
  if (l.error) {
    const u = new Me("Could not parse expression with acorn", {
      cause: l.error,
      place: { line: l.error.loc.line, column: l.error.loc.column + 1, offset: l.error.pos },
      ruleId: "acorn",
      source: "micromark-extension-mdx-expression",
    });
    return (u.url = _i + FE), { type: "nok", message: u };
  }
  return { type: "ok", estree: a };
}
const gg = "https://github.com/micromark/micromark-extension-mdx-jsx";
function rx(e, t, n, r, i, o, s, l, a, u, c, d, f, h, p, g, x, b, m, v, _, k, w, y, S, T, A, F, R, V, B, N) {
  const G = this;
  let U, X;
  return te;
  function te(I) {
    return e.enter(l), e.enter(a), e.consume(I), e.exit(a), L;
  }
  function L(I) {
    return Ae(I) ? n(I) : ((U = se), Re(I));
  }
  function se(I) {
    if (I === 47) return e.enter(u), e.consume(I), e.exit(u), (U = pe), Re;
    if (I === 62) return Zt(I);
    if (I !== null && I >= 0 && qt(I)) return e.enter(d), e.enter(f), e.consume(I), M;
    j(
      I,
      "before name",
      "a character that can start a name, such as a letter, `$`, or `_`" +
        (I === 33 ? " (note: to create a comment in MDX, use `{/* text */}`)" : ""),
    );
  }
  function pe(I) {
    if (I === 62) return Zt(I);
    if (I !== null && I >= 0 && qt(I)) return e.enter(d), e.enter(f), e.consume(I), M;
    j(
      I,
      "before name",
      "a character that can start a name, such as a letter, `$`, or `_`" +
        (I === 42 || I === 47 ? " (note: JS comments in JSX tags are not supported in MDX)" : ""),
    );
  }
  function M(I) {
    if (I !== null && I >= 0 && po(I, { jsx: !0 })) return e.consume(I), M;
    if (I === 46 || I === 47 || I === 58 || I === 62 || I === 123 || Ae(I) || Hn(I)) return e.exit(f), (U = me), Re(I);
    j(
      I,
      "in name",
      "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" +
        (I === 64 ? " (note: to create a link in MDX, use `[text](url)`)" : ""),
    );
  }
  function me(I) {
    if (I === 46) return e.enter(h), e.consume(I), e.exit(h), (U = Ee), Re;
    if (I === 58) return e.enter(g), e.consume(I), e.exit(g), (U = W), Re;
    if (I === 47 || I === 62 || I === 123 || (I !== null && I >= 0 && qt(I))) return e.exit(d), oe(I);
    j(
      I,
      "after name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag",
    );
  }
  function Ee(I) {
    if (I !== null && I >= 0 && qt(I)) return e.enter(p), e.consume(I), ce;
    j(
      I,
      "before member name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag",
    );
  }
  function ce(I) {
    if (I !== null && I >= 0 && po(I, { jsx: !0 })) return e.consume(I), ce;
    if (I === 46 || I === 47 || I === 62 || I === 123 || Ae(I) || Hn(I)) return e.exit(p), (U = z), Re(I);
    j(
      I,
      "in member name",
      "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" +
        (I === 64 ? " (note: to create a link in MDX, use `[text](url)`)" : ""),
    );
  }
  function z(I) {
    if (I === 46) return e.enter(h), e.consume(I), e.exit(h), (U = Ee), Re;
    if (I === 47 || I === 62 || I === 123 || (I !== null && I >= 0 && qt(I))) return e.exit(d), oe(I);
    j(
      I,
      "after member name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag",
    );
  }
  function W(I) {
    if (I !== null && I >= 0 && qt(I)) return e.enter(x), e.consume(I), Y;
    j(
      I,
      "before local name",
      "a character that can start a name, such as a letter, `$`, or `_`" +
        (I === 43 || (I !== null && I > 46 && I < 58) ? " (note: to create a link in MDX, use `[text](url)`)" : ""),
    );
  }
  function Y(I) {
    if (I !== null && I >= 0 && po(I, { jsx: !0 })) return e.consume(I), Y;
    if (I === 47 || I === 62 || I === 123 || Ae(I) || Hn(I)) return e.exit(x), (U = Q), Re(I);
    j(
      I,
      "in local name",
      "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag",
    );
  }
  function Q(I) {
    if (I === 47 || I === 62 || I === 123 || (I !== null && I >= 0 && qt(I))) return e.exit(d), oe(I);
    j(
      I,
      "after local name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag",
    );
  }
  function oe(I) {
    if (I === 47) return e.enter(c), e.consume(I), e.exit(c), (U = Ir), Re;
    if (I === 62) return Zt(I);
    if (I === 123) return pg.call(G, e, he, b, m, v, r, i, o, !0, !1, s)(I);
    if (I !== null && I >= 0 && qt(I)) return e.enter(_), e.enter(k), e.enter(w), e.consume(I), ke;
    j(
      I,
      "before attribute name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag",
    );
  }
  function he(I) {
    return (U = oe), Re(I);
  }
  function ke(I) {
    if (I !== null && I >= 0 && po(I, { jsx: !0 })) return e.consume(I), ke;
    if (I === 47 || I === 58 || I === 61 || I === 62 || I === 123 || Ae(I) || Hn(I)) return e.exit(w), (U = De), Re(I);
    j(
      I,
      "in attribute name",
      "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag",
    );
  }
  function De(I) {
    if (I === 58) return e.enter(y), e.consume(I), e.exit(y), (U = Xe), Re;
    if (I === 61) return e.exit(k), e.enter(T), e.consume(I), e.exit(T), (U = gn), Re;
    if (I === 47 || I === 62 || I === 123 || Ae(I) || Hn(I) || (I !== null && I >= 0 && qt(I)))
      return e.exit(k), e.exit(_), (U = oe), Re(I);
    j(
      I,
      "after attribute name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag",
    );
  }
  function Xe(I) {
    if (I !== null && I >= 0 && qt(I)) return e.enter(S), e.consume(I), Qe;
    j(
      I,
      "before local attribute name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag",
    );
  }
  function Qe(I) {
    if (I !== null && I >= 0 && po(I, { jsx: !0 })) return e.consume(I), Qe;
    if (I === 47 || I === 61 || I === 62 || I === 123 || Ae(I) || Hn(I)) return e.exit(S), e.exit(k), (U = rt), Re(I);
    j(
      I,
      "in local attribute name",
      "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag",
    );
  }
  function rt(I) {
    if (I === 61) return e.enter(T), e.consume(I), e.exit(T), (U = gn), Re;
    if (I === 47 || I === 62 || I === 123 || (I !== null && I >= 0 && qt(I))) return e.exit(_), oe(I);
    j(
      I,
      "after local attribute name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag",
    );
  }
  function gn(I) {
    if (I === 34 || I === 39) return e.enter(A), e.enter(F), e.consume(I), e.exit(F), (X = I), mn;
    if (I === 123) return pg.call(G, e, st, V, B, N, r, i, o, !1, !1, s)(I);
    j(
      I,
      "before attribute value",
      "a character that can start an attribute value, such as `\"`, `'`, or `{`" +
        (I === 60 ? " (note: to use an element or fragment as a prop value in MDX, use `{<element />}`)" : ""),
    );
  }
  function st(I) {
    return e.exit(_), (U = oe), Re(I);
  }
  function mn(I) {
    return (
      I === null && j(I, "in attribute value", "a corresponding closing quote `" + String.fromCodePoint(X) + "`"),
      I === X
        ? (e.enter(F), e.consume(I), e.exit(F), e.exit(A), e.exit(_), (X = void 0), (U = oe), Re)
        : ee(I)
          ? ((U = mn), Re(I))
          : (e.enter(R), _t(I))
    );
  }
  function _t(I) {
    return I === null || I === X || ee(I) ? (e.exit(R), mn(I)) : (e.consume(I), _t);
  }
  function Ir(I) {
    if (I === 62) return Zt(I);
    j(
      I,
      "after self-closing slash",
      "`>` to end the tag" + (I === 42 || I === 47 ? " (note: JS comments in JSX tags are not supported in MDX)" : ""),
    );
  }
  function Zt(I) {
    return e.enter(a), e.consume(I), e.exit(a), e.exit(l), t;
  }
  function Re(I) {
    return ee(I)
      ? (e.enter("lineEnding"), e.consume(I), e.exit("lineEnding"), $)
      : fe(I) || Hn(I)
        ? (e.enter("esWhitespace"), Ot(I))
        : U(I);
  }
  function Ot(I) {
    return ee(I)
      ? (e.exit("esWhitespace"), Re(I))
      : fe(I) || Hn(I)
        ? (e.consume(I), Ot)
        : (e.exit("esWhitespace"), U(I));
  }
  function $(I) {
    if (!s && G.parser.lazy[G.now().line]) {
      const de = new Me(
        "Unexpected lazy line in container, expected line to be prefixed with `>` when in a block quote, whitespace when in a list, etc",
        G.now(),
        "micromark-extension-mdx-jsx:unexpected-lazy",
      );
      throw ((de.url = gg + "#unexpected-lazy-line-in-container-expected-line-to-be"), de);
    }
    return Re(I);
  }
  function j(I, de, ye) {
    const $e = new Me(
      "Unexpected " +
        (I === null
          ? "end of file"
          : "character `" + (I === 96 ? "` ` `" : String.fromCodePoint(I)) + "` (" + PE(I) + ")") +
        " " +
        de +
        ", expected " +
        ye,
      G.now(),
      "micromark-extension-mdx-jsx:unexpected-" + (I === null ? "eof" : "character"),
    );
    throw (
      (($e.url =
        gg + (I === null ? "#unexpected-end-of-file-at-expected-expect" : "#unexpected-character-at-expected-expect")),
      $e)
    );
  }
}
function PE(e) {
  return "U+" + e.toString(16).toUpperCase().padStart(4, "0");
}
function DE(e, t) {
  return { name: "mdxJsxTextTag", tokenize: n };
  function n(r, i, o) {
    return rx.call(
      this,
      r,
      i,
      o,
      e,
      t.acornOptions,
      t.addResult,
      !0,
      "mdxJsxTextTag",
      "mdxJsxTextTagMarker",
      "mdxJsxTextTagClosingMarker",
      "mdxJsxTextTagSelfClosingMarker",
      "mdxJsxTextTagName",
      "mdxJsxTextTagNamePrimary",
      "mdxJsxTextTagNameMemberMarker",
      "mdxJsxTextTagNameMember",
      "mdxJsxTextTagNamePrefixMarker",
      "mdxJsxTextTagNameLocal",
      "mdxJsxTextTagExpressionAttribute",
      "mdxJsxTextTagExpressionAttributeMarker",
      "mdxJsxTextTagExpressionAttributeValue",
      "mdxJsxTextTagAttribute",
      "mdxJsxTextTagAttributeName",
      "mdxJsxTextTagAttributeNamePrimary",
      "mdxJsxTextTagAttributeNamePrefixMarker",
      "mdxJsxTextTagAttributeNameLocal",
      "mdxJsxTextTagAttributeInitializerMarker",
      "mdxJsxTextTagAttributeValueLiteral",
      "mdxJsxTextTagAttributeValueLiteralMarker",
      "mdxJsxTextTagAttributeValueLiteralValue",
      "mdxJsxTextTagAttributeValueExpression",
      "mdxJsxTextTagAttributeValueExpressionMarker",
      "mdxJsxTextTagAttributeValueExpressionValue",
    );
  }
}
function ve(e, t, n, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let o = 0;
  return s;
  function s(a) {
    return fe(a) ? (e.enter(n), l(a)) : t(a);
  }
  function l(a) {
    return fe(a) && o++ < i ? (e.consume(a), l) : (e.exit(n), t(a));
  }
}
function $E(e, t) {
  return { name: "mdxJsxFlowTag", tokenize: n, concrete: !0 };
  function n(r, i, o) {
    const s = this;
    return l;
    function l(d) {
      return a(d);
    }
    function a(d) {
      return rx.call(
        s,
        r,
        u,
        o,
        e,
        t.acornOptions,
        t.addResult,
        !1,
        "mdxJsxFlowTag",
        "mdxJsxFlowTagMarker",
        "mdxJsxFlowTagClosingMarker",
        "mdxJsxFlowTagSelfClosingMarker",
        "mdxJsxFlowTagName",
        "mdxJsxFlowTagNamePrimary",
        "mdxJsxFlowTagNameMemberMarker",
        "mdxJsxFlowTagNameMember",
        "mdxJsxFlowTagNamePrefixMarker",
        "mdxJsxFlowTagNameLocal",
        "mdxJsxFlowTagExpressionAttribute",
        "mdxJsxFlowTagExpressionAttributeMarker",
        "mdxJsxFlowTagExpressionAttributeValue",
        "mdxJsxFlowTagAttribute",
        "mdxJsxFlowTagAttributeName",
        "mdxJsxFlowTagAttributeNamePrimary",
        "mdxJsxFlowTagAttributeNamePrefixMarker",
        "mdxJsxFlowTagAttributeNameLocal",
        "mdxJsxFlowTagAttributeInitializerMarker",
        "mdxJsxFlowTagAttributeValueLiteral",
        "mdxJsxFlowTagAttributeValueLiteralMarker",
        "mdxJsxFlowTagAttributeValueLiteralValue",
        "mdxJsxFlowTagAttributeValueExpression",
        "mdxJsxFlowTagAttributeValueExpressionMarker",
        "mdxJsxFlowTagAttributeValueExpressionValue",
      )(d);
    }
    function u(d) {
      return fe(d) ? ve(r, c, "whitespace")(d) : c(d);
    }
    function c(d) {
      const f = s.parser.constructs.flow[123],
        p = (Array.isArray(f) ? f : f ? [f] : []).find((g) => g.name === "mdxFlowExpression");
      return d === 60 ? l(d) : d === 123 && p ? r.attempt(p, c, o)(d) : d === null || ee(d) ? i(d) : o(d);
    }
  }
}
function BE(e) {
  const t = {},
    n = t.acorn;
  let r;
  if (n) {
    if (!n.parse || !n.parseExpressionAt)
      throw new Error("Expected a proper `acorn` instance passed in as `options.acorn`");
    r = Object.assign({ ecmaVersion: 2024, sourceType: "module" }, t.acornOptions, { locations: !0 });
  } else if (t.acornOptions || t.addResult)
    throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
  return {
    flow: { 60: $E(n || void 0, { acornOptions: r, addResult: t.addResult || void 0 }) },
    text: { 60: DE(n || void 0, { acornOptions: r, addResult: t.addResult || void 0 }) },
  };
}
function HE() {
  return { disable: { null: ["autolink", "codeIndented", "htmlFlow", "htmlText"] } };
}
const mg = {}.hasOwnProperty;
function VE(e, t) {
  const n = t || {};
  function r(i, ...o) {
    let s = r.invalid;
    const l = r.handlers;
    if (i && mg.call(i, e)) {
      const a = String(i[e]);
      s = mg.call(l, a) ? l[a] : r.unknown;
    }
    if (s) return s.call(this, i, ...o);
  }
  return (r.handlers = n.handlers || {}), (r.invalid = n.invalid), (r.unknown = n.unknown), r;
}
const zE = {}.hasOwnProperty;
function ix(e, t) {
  let n = -1,
    r;
  if (t.extensions) for (; ++n < t.extensions.length; ) ix(e, t.extensions[n]);
  for (r in t)
    if (zE.call(t, r))
      switch (r) {
        case "extensions":
          break;
        case "unsafe": {
          xg(e[r], t[r]);
          break;
        }
        case "join": {
          xg(e[r], t[r]);
          break;
        }
        case "handlers": {
          jE(e[r], t[r]);
          break;
        }
        default:
          e.options[r] = t[r];
      }
  return e;
}
function xg(e, t) {
  t && e.push(...t);
}
function jE(e, t) {
  t && Object.assign(e, t);
}
function UE(e, t, n, r) {
  const i = n.enter("blockquote"),
    o = n.createTracker(r);
  o.move("> "), o.shift(2);
  const s = n.indentLines(n.containerFlow(e, o.current()), WE);
  return i(), s;
}
function WE(e, t, n) {
  return ">" + (n ? "" : " ") + e;
}
function ox(e, t) {
  return vg(e, t.inConstruct, !0) && !vg(e, t.notInConstruct, !1);
}
function vg(e, t, n) {
  if ((typeof t == "string" && (t = [t]), !t || t.length === 0)) return n;
  let r = -1;
  for (; ++r < t.length; ) if (e.includes(t[r])) return !0;
  return !1;
}
function bg(e, t, n, r) {
  let i = -1;
  for (; ++i < n.unsafe.length; )
    if (
      n.unsafe[i].character ===
        `
` &&
      ox(n.stack, n.unsafe[i])
    )
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function KE(e, t) {
  const n = String(e);
  let r = n.indexOf(t),
    i = r,
    o = 0,
    s = 0;
  if (typeof t != "string") throw new TypeError("Expected substring");
  for (; r !== -1; ) r === i ? ++o > s && (s = o) : (o = 1), (i = r + t.length), (r = n.indexOf(t, i));
  return s;
}
function Lc(e, t) {
  return !!(
    t.options.fences === !1 &&
    e.value &&
    !e.lang &&
    /[^ \r\n]/.test(e.value) &&
    !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value)
  );
}
function JE(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error("Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`");
  return t;
}
function GE(e, t, n, r) {
  const i = JE(n),
    o = e.value || "",
    s = i === "`" ? "GraveAccent" : "Tilde";
  if (Lc(e, n)) {
    const d = n.enter("codeIndented"),
      f = n.indentLines(o, ZE);
    return d(), f;
  }
  const l = n.createTracker(r),
    a = i.repeat(Math.max(KE(o, i) + 1, 3)),
    u = n.enter("codeFenced");
  let c = l.move(a);
  if (e.lang) {
    const d = n.enter(`codeFencedLang${s}`);
    (c += l.move(n.safe(e.lang, { before: c, after: " ", encode: ["`"], ...l.current() }))), d();
  }
  if (e.lang && e.meta) {
    const d = n.enter(`codeFencedMeta${s}`);
    (c += l.move(" ")),
      (c += l.move(
        n.safe(e.meta, {
          before: c,
          after: `
`,
          encode: ["`"],
          ...l.current(),
        }),
      )),
      d();
  }
  return (
    (c += l.move(`
`)),
    o &&
      (c += l.move(
        o +
          `
`,
      )),
    (c += l.move(a)),
    u(),
    c
  );
}
function ZE(e, t, n) {
  return (n ? "" : "    ") + e;
}
function yf(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error("Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`");
  return t;
}
function qE(e, t, n, r) {
  const i = yf(n),
    o = i === '"' ? "Quote" : "Apostrophe",
    s = n.enter("definition");
  let l = n.enter("label");
  const a = n.createTracker(r);
  let u = a.move("[");
  return (
    (u += a.move(n.safe(n.associationId(e), { before: u, after: "]", ...a.current() }))),
    (u += a.move("]: ")),
    l(),
    !e.url || /[\0- \u007F]/.test(e.url)
      ? ((l = n.enter("destinationLiteral")),
        (u += a.move("<")),
        (u += a.move(n.safe(e.url, { before: u, after: ">", ...a.current() }))),
        (u += a.move(">")))
      : ((l = n.enter("destinationRaw")),
        (u += a.move(
          n.safe(e.url, {
            before: u,
            after: e.title
              ? " "
              : `
`,
            ...a.current(),
          }),
        ))),
    l(),
    e.title &&
      ((l = n.enter(`title${o}`)),
      (u += a.move(" " + i)),
      (u += a.move(n.safe(e.title, { before: u, after: i, ...a.current() }))),
      (u += a.move(i)),
      l()),
    s(),
    u
  );
}
function YE(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error("Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`");
  return t;
}
sx.peek = XE;
function sx(e, t, n, r) {
  const i = YE(n),
    o = n.enter("emphasis"),
    s = n.createTracker(r);
  let l = s.move(i);
  return (l += s.move(n.containerPhrasing(e, { before: l, after: i, ...s.current() }))), (l += s.move(i)), o(), l;
}
function XE(e, t, n) {
  return n.options.emphasis || "*";
}
const Cf = function (e) {
  if (e == null) return nk;
  if (typeof e == "function") return _a(e);
  if (typeof e == "object") return Array.isArray(e) ? QE(e) : ek(e);
  if (typeof e == "string") return tk(e);
  throw new Error("Expected function, string, or object as test");
};
function QE(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; ) t[n] = Cf(e[n]);
  return _a(r);
  function r(...i) {
    let o = -1;
    for (; ++o < t.length; ) if (t[o].apply(this, i)) return !0;
    return !1;
  }
}
function ek(e) {
  const t = e;
  return _a(n);
  function n(r) {
    const i = r;
    let o;
    for (o in e) if (i[o] !== t[o]) return !1;
    return !0;
  }
}
function tk(e) {
  return _a(t);
  function t(n) {
    return n && n.type === e;
  }
}
function _a(e) {
  return t;
  function t(n, r, i) {
    return !!(rk(n) && e.call(this, n, typeof r == "number" ? r : void 0, i || void 0));
  }
}
function nk() {
  return !0;
}
function rk(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const lx = [],
  ik = !0,
  Mc = !1,
  ok = "skip";
function ax(e, t, n, r) {
  let i;
  typeof t == "function" && typeof n != "function" ? ((r = n), (n = t)) : (i = t);
  const o = Cf(i),
    s = r ? -1 : 1;
  l(e, void 0, [])();
  function l(a, u, c) {
    const d = a && typeof a == "object" ? a : {};
    if (typeof d.type == "string") {
      const h = typeof d.tagName == "string" ? d.tagName : typeof d.name == "string" ? d.name : void 0;
      Object.defineProperty(f, "name", { value: "node (" + (a.type + (h ? "<" + h + ">" : "")) + ")" });
    }
    return f;
    function f() {
      let h = lx,
        p,
        g,
        x;
      if ((!t || o(a, u, c[c.length - 1] || void 0)) && ((h = sk(n(a, c))), h[0] === Mc)) return h;
      if ("children" in a && a.children) {
        const b = a;
        if (b.children && h[0] !== ok)
          for (g = (r ? b.children.length : -1) + s, x = c.concat(b); g > -1 && g < b.children.length; ) {
            const m = b.children[g];
            if (((p = l(m, g, x)()), p[0] === Mc)) return p;
            g = typeof p[1] == "number" ? p[1] : g + s;
          }
      }
      return h;
    }
  }
}
function sk(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [ik, e] : e == null ? lx : [e];
}
function lk(e, t, n, r) {
  let i, o, s;
  typeof t == "function" && typeof n != "function" ? ((o = void 0), (s = t), (i = n)) : ((o = t), (s = n), (i = r)),
    ax(e, o, l, i);
  function l(a, u) {
    const c = u[u.length - 1],
      d = c ? c.children.indexOf(a) : void 0;
    return s(a, d, c);
  }
}
const ak = {};
function _f(e, t) {
  const n = ak,
    r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0,
    i = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return ux(e, r, i);
}
function ux(e, t, n) {
  if (uk(e)) {
    if ("value" in e) return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt) return e.alt;
    if ("children" in e) return yg(e.children, t, n);
  }
  return Array.isArray(e) ? yg(e, t, n) : "";
}
function yg(e, t, n) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; ) r[i] = ux(e[i], t, n);
  return r.join("");
}
function uk(e) {
  return !!(e && typeof e == "object");
}
function cx(e, t) {
  let n = !1;
  return (
    lk(e, function (r) {
      if (("value" in r && /\r?\n|\r/.test(r.value)) || r.type === "break") return (n = !0), Mc;
    }),
    !!((!e.depth || e.depth < 3) && _f(e) && (t.options.setext || n))
  );
}
function ck(e, t, n, r) {
  const i = Math.max(Math.min(6, e.depth || 1), 1),
    o = n.createTracker(r);
  if (cx(e, n)) {
    const c = n.enter("headingSetext"),
      d = n.enter("phrasing"),
      f = n.containerPhrasing(e, {
        ...o.current(),
        before: `
`,
        after: `
`,
      });
    return (
      d(),
      c(),
      f +
        `
` +
        (i === 1 ? "=" : "-").repeat(
          f.length -
            (Math.max(
              f.lastIndexOf("\r"),
              f.lastIndexOf(`
`),
            ) +
              1),
        )
    );
  }
  const s = "#".repeat(i),
    l = n.enter("headingAtx"),
    a = n.enter("phrasing");
  o.move(s + " ");
  let u = n.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...o.current(),
  });
  return (
    /^[\t ]/.test(u) && (u = "&#x" + u.charCodeAt(0).toString(16).toUpperCase() + ";" + u.slice(1)),
    (u = u ? s + " " + u : s),
    n.options.closeAtx && (u += " " + s),
    a(),
    l(),
    u
  );
}
dx.peek = dk;
function dx(e) {
  return e.value || "";
}
function dk() {
  return "<";
}
fx.peek = fk;
function fx(e, t, n, r) {
  const i = yf(n),
    o = i === '"' ? "Quote" : "Apostrophe",
    s = n.enter("image");
  let l = n.enter("label");
  const a = n.createTracker(r);
  let u = a.move("![");
  return (
    (u += a.move(n.safe(e.alt, { before: u, after: "]", ...a.current() }))),
    (u += a.move("](")),
    l(),
    (!e.url && e.title) || /[\0- \u007F]/.test(e.url)
      ? ((l = n.enter("destinationLiteral")),
        (u += a.move("<")),
        (u += a.move(n.safe(e.url, { before: u, after: ">", ...a.current() }))),
        (u += a.move(">")))
      : ((l = n.enter("destinationRaw")),
        (u += a.move(n.safe(e.url, { before: u, after: e.title ? " " : ")", ...a.current() })))),
    l(),
    e.title &&
      ((l = n.enter(`title${o}`)),
      (u += a.move(" " + i)),
      (u += a.move(n.safe(e.title, { before: u, after: i, ...a.current() }))),
      (u += a.move(i)),
      l()),
    (u += a.move(")")),
    s(),
    u
  );
}
function fk() {
  return "!";
}
hx.peek = hk;
function hx(e, t, n, r) {
  const i = e.referenceType,
    o = n.enter("imageReference");
  let s = n.enter("label");
  const l = n.createTracker(r);
  let a = l.move("![");
  const u = n.safe(e.alt, { before: a, after: "]", ...l.current() });
  (a += l.move(u + "][")), s();
  const c = n.stack;
  (n.stack = []), (s = n.enter("reference"));
  const d = n.safe(n.associationId(e), { before: a, after: "]", ...l.current() });
  return (
    s(),
    (n.stack = c),
    o(),
    i === "full" || !u || u !== d
      ? (a += l.move(d + "]"))
      : i === "shortcut"
        ? (a = a.slice(0, -1))
        : (a += l.move("]")),
    a
  );
}
function hk() {
  return "!";
}
px.peek = pk;
function px(e, t, n) {
  let r = e.value || "",
    i = "`",
    o = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); ) i += "`";
  for (
    /[^ \r\n]/.test(r) && ((/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r)) || /^`|`$/.test(r)) && (r = " " + r + " ");
    ++o < n.unsafe.length;

  ) {
    const s = n.unsafe[o],
      l = n.compilePattern(s);
    let a;
    if (s.atBreak)
      for (; (a = l.exec(r)); ) {
        let u = a.index;
        r.charCodeAt(u) === 10 && r.charCodeAt(u - 1) === 13 && u--, (r = r.slice(0, u) + " " + r.slice(a.index + 1));
      }
  }
  return i + r + i;
}
function pk() {
  return "`";
}
function gx(e, t) {
  const n = _f(e);
  return !!(
    !t.options.resourceLink &&
    e.url &&
    !e.title &&
    e.children &&
    e.children.length === 1 &&
    e.children[0].type === "text" &&
    (n === e.url || "mailto:" + n === e.url) &&
    /^[a-z][a-z+.-]+:/i.test(e.url) &&
    !/[\0- <>\u007F]/.test(e.url)
  );
}
mx.peek = gk;
function mx(e, t, n, r) {
  const i = yf(n),
    o = i === '"' ? "Quote" : "Apostrophe",
    s = n.createTracker(r);
  let l, a;
  if (gx(e, n)) {
    const c = n.stack;
    (n.stack = []), (l = n.enter("autolink"));
    let d = s.move("<");
    return (
      (d += s.move(n.containerPhrasing(e, { before: d, after: ">", ...s.current() }))),
      (d += s.move(">")),
      l(),
      (n.stack = c),
      d
    );
  }
  (l = n.enter("link")), (a = n.enter("label"));
  let u = s.move("[");
  return (
    (u += s.move(n.containerPhrasing(e, { before: u, after: "](", ...s.current() }))),
    (u += s.move("](")),
    a(),
    (!e.url && e.title) || /[\0- \u007F]/.test(e.url)
      ? ((a = n.enter("destinationLiteral")),
        (u += s.move("<")),
        (u += s.move(n.safe(e.url, { before: u, after: ">", ...s.current() }))),
        (u += s.move(">")))
      : ((a = n.enter("destinationRaw")),
        (u += s.move(n.safe(e.url, { before: u, after: e.title ? " " : ")", ...s.current() })))),
    a(),
    e.title &&
      ((a = n.enter(`title${o}`)),
      (u += s.move(" " + i)),
      (u += s.move(n.safe(e.title, { before: u, after: i, ...s.current() }))),
      (u += s.move(i)),
      a()),
    (u += s.move(")")),
    l(),
    u
  );
}
function gk(e, t, n) {
  return gx(e, n) ? "<" : "[";
}
xx.peek = mk;
function xx(e, t, n, r) {
  const i = e.referenceType,
    o = n.enter("linkReference");
  let s = n.enter("label");
  const l = n.createTracker(r);
  let a = l.move("[");
  const u = n.containerPhrasing(e, { before: a, after: "]", ...l.current() });
  (a += l.move(u + "][")), s();
  const c = n.stack;
  (n.stack = []), (s = n.enter("reference"));
  const d = n.safe(n.associationId(e), { before: a, after: "]", ...l.current() });
  return (
    s(),
    (n.stack = c),
    o(),
    i === "full" || !u || u !== d
      ? (a += l.move(d + "]"))
      : i === "shortcut"
        ? (a = a.slice(0, -1))
        : (a += l.move("]")),
    a
  );
}
function mk() {
  return "[";
}
function wf(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error("Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`");
  return t;
}
function xk(e) {
  const t = wf(e),
    n = e.options.bulletOther;
  if (!n) return t === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error("Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`");
  if (n === t) throw new Error("Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different");
  return n;
}
function vk(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error("Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`");
  return t;
}
function vx(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error("Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`");
  return t;
}
function bk(e, t, n, r) {
  const i = n.enter("list"),
    o = n.bulletCurrent;
  let s = e.ordered ? vk(n) : wf(n);
  const l = e.ordered ? (s === "." ? ")" : ".") : xk(n);
  let a = t && n.bulletLastUsed ? s === n.bulletLastUsed : !1;
  if (!e.ordered) {
    const c = e.children ? e.children[0] : void 0;
    if (
      ((s === "*" || s === "-") &&
        c &&
        (!c.children || !c.children[0]) &&
        n.stack[n.stack.length - 1] === "list" &&
        n.stack[n.stack.length - 2] === "listItem" &&
        n.stack[n.stack.length - 3] === "list" &&
        n.stack[n.stack.length - 4] === "listItem" &&
        n.indexStack[n.indexStack.length - 1] === 0 &&
        n.indexStack[n.indexStack.length - 2] === 0 &&
        n.indexStack[n.indexStack.length - 3] === 0 &&
        (a = !0),
      vx(n) === s && c)
    ) {
      let d = -1;
      for (; ++d < e.children.length; ) {
        const f = e.children[d];
        if (f && f.type === "listItem" && f.children && f.children[0] && f.children[0].type === "thematicBreak") {
          a = !0;
          break;
        }
      }
    }
  }
  a && (s = l), (n.bulletCurrent = s);
  const u = n.containerFlow(e, r);
  return (n.bulletLastUsed = s), (n.bulletCurrent = o), i(), u;
}
function yk(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`",
    );
  return t;
}
function Ck(e, t, n, r) {
  const i = yk(n);
  let o = n.bulletCurrent || wf(n);
  t &&
    t.type === "list" &&
    t.ordered &&
    (o =
      (typeof t.start == "number" && t.start > -1 ? t.start : 1) +
      (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) +
      o);
  let s = o.length + 1;
  (i === "tab" || (i === "mixed" && ((t && t.type === "list" && t.spread) || e.spread))) && (s = Math.ceil(s / 4) * 4);
  const l = n.createTracker(r);
  l.move(o + " ".repeat(s - o.length)), l.shift(s);
  const a = n.enter("listItem"),
    u = n.indentLines(n.containerFlow(e, l.current()), c);
  return a(), u;
  function c(d, f, h) {
    return f ? (h ? "" : " ".repeat(s)) + d : (h ? o : o + " ".repeat(s - o.length)) + d;
  }
}
function _k(e, t, n, r) {
  const i = n.enter("paragraph"),
    o = n.enter("phrasing"),
    s = n.containerPhrasing(e, r);
  return o(), i(), s;
}
const wk = Cf([
  "break",
  "delete",
  "emphasis",
  "footnote",
  "footnoteReference",
  "image",
  "imageReference",
  "inlineCode",
  "inlineMath",
  "link",
  "linkReference",
  "mdxJsxTextElement",
  "mdxTextExpression",
  "strong",
  "text",
  "textDirective",
]);
function Ek(e, t, n, r) {
  return (
    e.children.some(function (s) {
      return wk(s);
    })
      ? n.containerPhrasing
      : n.containerFlow
  ).call(n, e, r);
}
function kk(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error("Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`");
  return t;
}
bx.peek = Sk;
function bx(e, t, n, r) {
  const i = kk(n),
    o = n.enter("strong"),
    s = n.createTracker(r);
  let l = s.move(i + i);
  return (l += s.move(n.containerPhrasing(e, { before: l, after: i, ...s.current() }))), (l += s.move(i + i)), o(), l;
}
function Sk(e, t, n) {
  return n.options.strong || "*";
}
function Tk(e, t, n, r) {
  return n.safe(e.value, r);
}
function Ak(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more",
    );
  return t;
}
function Ik(e, t, n) {
  const r = (vx(n) + (n.options.ruleSpaces ? " " : "")).repeat(Ak(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const Ef = {
    blockquote: UE,
    break: bg,
    code: GE,
    definition: qE,
    emphasis: sx,
    hardBreak: bg,
    heading: ck,
    html: dx,
    image: fx,
    imageReference: hx,
    inlineCode: px,
    link: mx,
    linkReference: xx,
    list: bk,
    listItem: Ck,
    paragraph: _k,
    root: Ek,
    strong: bx,
    text: Tk,
    thematicBreak: Ik,
  },
  Nk = [Lk];
function Lk(e, t, n, r) {
  if (t.type === "code" && Lc(t, r) && (e.type === "list" || (e.type === t.type && Lc(e, r)))) return !1;
  if ("spread" in n && typeof n.spread == "boolean")
    return e.type === "paragraph" &&
      (e.type === t.type || t.type === "definition" || (t.type === "heading" && cx(t, r)))
      ? void 0
      : n.spread
        ? 1
        : 0;
}
const Lr = ["autolink", "destinationLiteral", "destinationRaw", "reference", "titleQuote", "titleApostrophe"],
  Mk = [
    { character: "	", after: "[\\r\\n]", inConstruct: "phrasing" },
    { character: "	", before: "[\\r\\n]", inConstruct: "phrasing" },
    { character: "	", inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"] },
    {
      character: "\r",
      inConstruct: [
        "codeFencedLangGraveAccent",
        "codeFencedLangTilde",
        "codeFencedMetaGraveAccent",
        "codeFencedMetaTilde",
        "destinationLiteral",
        "headingAtx",
      ],
    },
    {
      character: `
`,
      inConstruct: [
        "codeFencedLangGraveAccent",
        "codeFencedLangTilde",
        "codeFencedMetaGraveAccent",
        "codeFencedMetaTilde",
        "destinationLiteral",
        "headingAtx",
      ],
    },
    { character: " ", after: "[\\r\\n]", inConstruct: "phrasing" },
    { character: " ", before: "[\\r\\n]", inConstruct: "phrasing" },
    { character: " ", inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"] },
    { character: "!", after: "\\[", inConstruct: "phrasing", notInConstruct: Lr },
    { character: '"', inConstruct: "titleQuote" },
    { atBreak: !0, character: "#" },
    {
      character: "#",
      inConstruct: "headingAtx",
      after: `(?:[\r
]|$)`,
    },
    { character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" },
    { character: "'", inConstruct: "titleApostrophe" },
    { character: "(", inConstruct: "destinationRaw" },
    { before: "\\]", character: "(", inConstruct: "phrasing", notInConstruct: Lr },
    { atBreak: !0, before: "\\d+", character: ")" },
    { character: ")", inConstruct: "destinationRaw" },
    {
      atBreak: !0,
      character: "*",
      after: `(?:[ 	\r
*])`,
    },
    { character: "*", inConstruct: "phrasing", notInConstruct: Lr },
    {
      atBreak: !0,
      character: "+",
      after: `(?:[ 	\r
])`,
    },
    {
      atBreak: !0,
      character: "-",
      after: `(?:[ 	\r
-])`,
    },
    {
      atBreak: !0,
      before: "\\d+",
      character: ".",
      after: `(?:[ 	\r
]|$)`,
    },
    { atBreak: !0, character: "<", after: "[!/?A-Za-z]" },
    { character: "<", after: "[!/?A-Za-z]", inConstruct: "phrasing", notInConstruct: Lr },
    { character: "<", inConstruct: "destinationLiteral" },
    { atBreak: !0, character: "=" },
    { atBreak: !0, character: ">" },
    { character: ">", inConstruct: "destinationLiteral" },
    { atBreak: !0, character: "[" },
    { character: "[", inConstruct: "phrasing", notInConstruct: Lr },
    { character: "[", inConstruct: ["label", "reference"] },
    { character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" },
    { character: "]", inConstruct: ["label", "reference"] },
    { atBreak: !0, character: "_" },
    { character: "_", inConstruct: "phrasing", notInConstruct: Lr },
    { atBreak: !0, character: "`" },
    { character: "`", inConstruct: ["codeFencedLangGraveAccent", "codeFencedMetaGraveAccent"] },
    { character: "`", inConstruct: "phrasing", notInConstruct: Lr },
    { atBreak: !0, character: "~" },
  ];
function Ok(e, t) {
  const n = Number.parseInt(e, t);
  return n < 9 ||
    n === 11 ||
    (n > 13 && n < 32) ||
    (n > 126 && n < 160) ||
    (n > 55295 && n < 57344) ||
    (n > 64975 && n < 65008) ||
    (n & 65535) === 65535 ||
    (n & 65535) === 65534 ||
    n > 1114111
    ? "�"
    : String.fromCodePoint(n);
}
const Fk = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function yx(e) {
  return e.replace(Fk, Rk);
}
function Rk(e, t, n) {
  if (t) return t;
  if (n.charCodeAt(0) === 35) {
    const i = n.charCodeAt(1),
      o = i === 120 || i === 88;
    return Ok(n.slice(o ? 2 : 1), o ? 16 : 10);
  }
  return $o(n) || e;
}
function Pk(e) {
  return e.label || !e.identifier ? e.label || "" : yx(e.identifier);
}
function Dk(e) {
  if (!e._compiled) {
    const t = (e.atBreak ? "[\\r\\n][\\t ]*" : "") + (e.before ? "(?:" + e.before + ")" : "");
    e._compiled = new RegExp(
      (t ? "(" + t + ")" : "") +
        (/[|\\{}()[\]^$+*?.-]/.test(e.character) ? "\\" : "") +
        e.character +
        (e.after ? "(?:" + e.after + ")" : ""),
      "g",
    );
  }
  return e._compiled;
}
function $k(e, t, n) {
  const r = t.indexStack,
    i = e.children || [],
    o = [];
  let s = -1,
    l = n.before;
  r.push(-1);
  let a = t.createTracker(n);
  for (; ++s < i.length; ) {
    const u = i[s];
    let c;
    if (((r[r.length - 1] = s), s + 1 < i.length)) {
      let d = t.handle.handlers[i[s + 1].type];
      d && d.peek && (d = d.peek),
        (c = d ? d(i[s + 1], e, t, { before: "", after: "", ...a.current() }).charAt(0) : "");
    } else c = n.after;
    o.length > 0 &&
      (l === "\r" ||
        l ===
          `
`) &&
      u.type === "html" &&
      ((o[o.length - 1] = o[o.length - 1].replace(/(\r?\n|\r)$/, " ")),
      (l = " "),
      (a = t.createTracker(n)),
      a.move(o.join(""))),
      o.push(a.move(t.handle(u, e, t, { ...a.current(), before: l, after: c }))),
      (l = o[o.length - 1].slice(-1));
  }
  return r.pop(), o.join("");
}
function Bk(e, t, n) {
  const r = t.indexStack,
    i = e.children || [],
    o = t.createTracker(n),
    s = [];
  let l = -1;
  for (r.push(-1); ++l < i.length; ) {
    const a = i[l];
    (r[r.length - 1] = l),
      s.push(
        o.move(
          t.handle(a, e, t, {
            before: `
`,
            after: `
`,
            ...o.current(),
          }),
        ),
      ),
      a.type !== "list" && (t.bulletLastUsed = void 0),
      l < i.length - 1 && s.push(o.move(Hk(a, i[l + 1], e, t)));
  }
  return r.pop(), s.join("");
}
function Hk(e, t, n, r) {
  let i = r.join.length;
  for (; i--; ) {
    const o = r.join[i](e, t, n, r);
    if (o === !0 || o === 1) break;
    if (typeof o == "number")
      return `
`.repeat(1 + o);
    if (o === !1)
      return `

<!---->

`;
  }
  return `

`;
}
const Vk = /\r?\n|\r/g;
function zk(e, t) {
  const n = [];
  let r = 0,
    i = 0,
    o;
  for (; (o = Vk.exec(e)); ) s(e.slice(r, o.index)), n.push(o[0]), (r = o.index + o[0].length), i++;
  return s(e.slice(r)), n.join("");
  function s(l) {
    n.push(t(l, i, !l));
  }
}
function jk(e, t, n) {
  const r = (n.before || "") + (t || "") + (n.after || ""),
    i = [],
    o = [],
    s = {};
  let l = -1;
  for (; ++l < e.unsafe.length; ) {
    const c = e.unsafe[l];
    if (!ox(e.stack, c)) continue;
    const d = e.compilePattern(c);
    let f;
    for (; (f = d.exec(r)); ) {
      const h = "before" in c || !!c.atBreak,
        p = "after" in c,
        g = f.index + (h ? f[1].length : 0);
      i.includes(g)
        ? (s[g].before && !h && (s[g].before = !1), s[g].after && !p && (s[g].after = !1))
        : (i.push(g), (s[g] = { before: h, after: p }));
    }
  }
  i.sort(Uk);
  let a = n.before ? n.before.length : 0;
  const u = r.length - (n.after ? n.after.length : 0);
  for (l = -1; ++l < i.length; ) {
    const c = i[l];
    c < a ||
      c >= u ||
      (c + 1 < u && i[l + 1] === c + 1 && s[c].after && !s[c + 1].before && !s[c + 1].after) ||
      (i[l - 1] === c - 1 && s[c].before && !s[c - 1].before && !s[c - 1].after) ||
      (a !== c && o.push(Cg(r.slice(a, c), "\\")),
      (a = c),
      /[!-/:-@[-`{-~]/.test(r.charAt(c)) && (!n.encode || !n.encode.includes(r.charAt(c)))
        ? o.push("\\")
        : (o.push("&#x" + r.charCodeAt(c).toString(16).toUpperCase() + ";"), a++));
  }
  return o.push(Cg(r.slice(a, u), n.after)), o.join("");
}
function Uk(e, t) {
  return e - t;
}
function Cg(e, t) {
  const n = /\\(?=[!-/:-@[-`{-~])/g,
    r = [],
    i = [],
    o = e + t;
  let s = -1,
    l = 0,
    a;
  for (; (a = n.exec(o)); ) r.push(a.index);
  for (; ++s < r.length; ) l !== r[s] && i.push(e.slice(l, r[s])), i.push("\\"), (l = r[s]);
  return i.push(e.slice(l)), i.join("");
}
function Wk(e) {
  const t = e || {},
    n = t.now || {};
  let r = t.lineShift || 0,
    i = n.line || 1,
    o = n.column || 1;
  return { move: a, current: s, shift: l };
  function s() {
    return { now: { line: i, column: o }, lineShift: r };
  }
  function l(u) {
    r += u;
  }
  function a(u) {
    const c = u || "",
      d = c.split(/\r?\n|\r/g),
      f = d[d.length - 1];
    return (i += d.length - 1), (o = d.length === 1 ? o + f.length : 1 + f.length + r), c;
  }
}
function Cx(e, t = {}) {
  const n = {
    enter: i,
    indentLines: zk,
    associationId: Pk,
    containerPhrasing: Zk,
    containerFlow: qk,
    createTracker: Wk,
    compilePattern: Dk,
    safe: Yk,
    stack: [],
    unsafe: [...Mk],
    join: [...Nk],
    handlers: { ...Ef },
    options: {},
    indexStack: [],
    handle: void 0,
  };
  ix(n, t),
    n.options.tightDefinitions && n.join.push(Gk),
    (n.handle = VE("type", { invalid: Kk, unknown: Jk, handlers: n.handlers }));
  let r = n.handle(e, void 0, n, {
    before: `
`,
    after: `
`,
    now: { line: 1, column: 1 },
    lineShift: 0,
  });
  return (
    r &&
      r.charCodeAt(r.length - 1) !== 10 &&
      r.charCodeAt(r.length - 1) !== 13 &&
      (r += `
`),
    r
  );
  function i(o) {
    return n.stack.push(o), s;
    function s() {
      n.stack.pop();
    }
  }
}
function Kk(e) {
  throw new Error("Cannot handle value `" + e + "`, expected node");
}
function Jk(e) {
  const t = e;
  throw new Error("Cannot handle unknown node `" + t.type + "`");
}
function Gk(e, t) {
  if (e.type === "definition" && e.type === t.type) return 0;
}
function Zk(e, t) {
  return $k(e, this, t);
}
function qk(e, t) {
  return Bk(e, this, t);
}
function Yk(e, t) {
  return jk(this, e, t);
}
const Xk = ["mdxJsxTextElement", "mdxJsxFlowElement"];
function _x(e) {
  return Xk.includes(e.type) && Qk.includes(e.name.toLowerCase());
}
const Qk = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
];
function e9(e, t) {
  const n = _g(e),
    r = _g(t),
    i = { ...n, ...r };
  return t9(i);
}
function _g(e) {
  const t = {};
  return (
    e
      .split(";")
      .filter((r) => r.trim() !== "")
      .forEach((r) => {
        const [i, o] = r.split(":").map((s) => s.trim());
        t[i] = o;
      }),
    t
  );
}
function t9(e) {
  return Object.entries(e)
    .map(([t, n]) => `${t}: ${n}`)
    .join("; ");
}
function n9(e) {
  return e.children instanceof Array;
}
function kf({ root: e, visitors: t, jsxComponentDescriptors: n, jsxIsAvailable: r, addImportStatements: i = !0 }) {
  let o = null;
  const s = new Set(),
    l = new Map();
  (t = t.sort((b, m) => (m.priority ?? 0) - (b.priority ?? 0))), d(e, null);
  function a(b, m) {
    s.add(b), m && l.set(b, { ...m });
  }
  function u(b, m) {
    if (o === null) return (o = m), o;
    if (!n9(b)) throw new Error("Attempting to append children to a non-parent");
    const v = b.children,
      _ = v.at(-1);
    if (_) {
      const k = t.find((w) => {
        var y;
        return (y = w.shouldJoin) == null ? void 0 : y.call(w, _, m);
      });
      if (k) {
        const w = k.join(_, m);
        return v.splice(v.length - 1, 1, w), w;
      }
    }
    return v.push(m), m;
  }
  function c(b, m) {
    b.getChildren().forEach((v) => {
      d(v, m);
    });
  }
  function d(b, m, v = null) {
    var _;
    const k = t.find((w, y) => {
      var S;
      return v != null && v.has(y) ? !1 : (S = w.testLexicalNode) == null ? void 0 : S.call(w, b);
    });
    if (!k) throw new Error(`no lexical visitor found for ${b.getType()}`, { cause: b });
    (_ = k.visitLexicalNode) == null ||
      _.call(k, {
        lexicalNode: b,
        mdastParent: m,
        actions: {
          addAndStepInto(w, y = {}, S = !0) {
            const T = { type: w, ...y, ...(S ? { children: [] } : {}) };
            u(m, T), P(b) && S && c(b, T);
          },
          appendToParent: u,
          visitChildren: c,
          visit: d,
          registerReferredComponent: a,
          nextVisitor() {
            d(b, m, (v ?? new Set()).add(t.indexOf(k)));
          },
        },
      });
  }
  if (o === null) throw new Error("traversal ended with no root element");
  const f = new Map(),
    h = new Map();
  for (const b of s) {
    const m = n.find((v) => v.name === b) ?? l.get(b) ?? n.find((v) => v.name === "*");
    if (!m) throw new Error(`Component ${b} is used but not imported`);
    if (m.source)
      if (m.defaultExport) h.set(b, m.source);
      else {
        const { source: v } = m,
          _ = f.get(v);
        _ ? _.push(b) : f.set(v, [b]);
      }
  }
  if (!i) {
    for (const [b, m] of f.entries()) {
      const v = m.filter((_) => l.has(_));
      v.length > 0 ? f.set(b, v) : f.delete(b);
    }
    for (const b of h.keys()) l.has(b) || h.delete(b);
  }
  const p = Array.from(f).map(([b, m]) => ({ type: "mdxjsEsm", value: `import { ${m.join(", ")} } from '${b}'` }));
  p.push(...Array.from(h).map(([b, m]) => ({ type: "mdxjsEsm", value: `import ${b} from '${m}'` })));
  const g = o,
    x = g.children.find((b) => b.type === "yaml");
  return (
    x ? g.children.splice(g.children.indexOf(x) + 1, 0, ...p) : g.children.unshift(...p),
    nl(g, []),
    wx(g),
    r || Ex(g),
    g
  );
}
function wx(e) {
  if ("children" in e && e.children.length > 0) {
    if (_x(e) && e.children.length === 1) {
      const t = e.children[0];
      t.type === "mdxJsxTextElement" &&
        t.name === "span" &&
        (t.attributes.forEach((n) => {
          if (n.type === "mdxJsxAttribute") {
            const r = e.attributes.find((i) => i.type === "mdxJsxAttribute" && i.name === n.name);
            if (r)
              if (n.name === "className") {
                const i = new Set([...r.value.split(" "), ...n.value.split(" ")]);
                r.value = Array.from(i).join(" ");
              } else n.name === "style" && (r.value = e9(r.value, n.value));
            else e.attributes.push(n);
          }
        }),
        (e.children = t.children));
    }
    e.children.forEach((t) => {
      wx(t);
    });
  }
}
function Ex(e) {
  if (Object.hasOwn(e, "children")) {
    const t = e,
      n = [];
    t.children.forEach((r) => {
      r.type === "mdxJsxTextElement" && r.name === "u"
        ? n.push({ type: "html", value: "<u>" }, ...r.children, { type: "html", value: "</u>" })
        : (n.push(r), Ex(r));
    }),
      (t.children = n);
  }
}
const wg = /\s+$/,
  Eg = /^\s+/;
function nl(e, t) {
  if (e.type === "strong" || e.type === "emphasis") {
    const n = e.children.at(-1);
    if ((n == null ? void 0 : n.type) === "text") {
      const i = n.value.match(wg);
      if (i) {
        n.value = n.value.replace(wg, "");
        const o = t.at(-1);
        o && (o.children.splice(o.children.indexOf(e) + 1, 0, { type: "text", value: i[0] }), nl(o, t.slice(0, -1)));
      }
    }
    const r = e.children.at(0);
    if ((r == null ? void 0 : r.type) === "text") {
      const i = r.value.match(Eg);
      if (i) {
        r.value = r.value.replace(Eg, "");
        const o = t.at(-1);
        o && (o.children.splice(o.children.indexOf(e), 0, { type: "text", value: i[0] }), nl(o, t.slice(0, -1)));
      }
    }
  }
  if ("children" in e && e.children.length > 0) {
    const n = e;
    n.children.forEach((r) => {
      nl(r, [...t, n]);
    });
  }
}
function r9({
  root: e,
  toMarkdownOptions: t,
  toMarkdownExtensions: n,
  visitors: r,
  jsxComponentDescriptors: i,
  jsxIsAvailable: o,
}) {
  return (
    Cx(kf({ root: e, visitors: r, jsxComponentDescriptors: i, jsxIsAvailable: o }), { extensions: n, ...t }) +
    `
`
  );
}
const kg = {}.hasOwnProperty;
function i9(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; ) o9(t, e[n]);
  return t;
}
function o9(e, t) {
  let n;
  for (n in t) {
    const i = (kg.call(e, n) ? e[n] : void 0) || (e[n] = {}),
      o = t[n];
    let s;
    if (o)
      for (s in o) {
        kg.call(i, s) || (i[s] = []);
        const l = o[s];
        s9(i[s], Array.isArray(l) ? l : l ? [l] : []);
      }
  }
}
function s9(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; ) (t[n].add === "after" ? e : r).push(t[n]);
  $t(e, 0, 0, r);
}
const l9 = { tokenize: a9 };
function a9(e) {
  const t = e.attempt(this.parser.constructs.contentInitial, r, i);
  let n;
  return t;
  function r(l) {
    if (l === null) {
      e.consume(l);
      return;
    }
    return e.enter("lineEnding"), e.consume(l), e.exit("lineEnding"), ve(e, t, "linePrefix");
  }
  function i(l) {
    return e.enter("paragraph"), o(l);
  }
  function o(l) {
    const a = e.enter("chunkText", { contentType: "text", previous: n });
    return n && (n.next = a), (n = a), s(l);
  }
  function s(l) {
    if (l === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(l);
      return;
    }
    return ee(l) ? (e.consume(l), e.exit("chunkText"), o) : (e.consume(l), s);
  }
}
const u9 = { tokenize: c9 },
  Sg = { tokenize: d9 };
function c9(e) {
  const t = this,
    n = [];
  let r = 0,
    i,
    o,
    s;
  return l;
  function l(v) {
    if (r < n.length) {
      const _ = n[r];
      return (t.containerState = _[1]), e.attempt(_[0].continuation, a, u)(v);
    }
    return u(v);
  }
  function a(v) {
    if ((r++, t.containerState._closeFlow)) {
      (t.containerState._closeFlow = void 0), i && m();
      const _ = t.events.length;
      let k = _,
        w;
      for (; k--; )
        if (t.events[k][0] === "exit" && t.events[k][1].type === "chunkFlow") {
          w = t.events[k][1].end;
          break;
        }
      b(r);
      let y = _;
      for (; y < t.events.length; ) (t.events[y][1].end = Object.assign({}, w)), y++;
      return $t(t.events, k + 1, 0, t.events.slice(_)), (t.events.length = y), u(v);
    }
    return l(v);
  }
  function u(v) {
    if (r === n.length) {
      if (!i) return f(v);
      if (i.currentConstruct && i.currentConstruct.concrete) return p(v);
      t.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);
    }
    return (t.containerState = {}), e.check(Sg, c, d)(v);
  }
  function c(v) {
    return i && m(), b(r), f(v);
  }
  function d(v) {
    return (t.parser.lazy[t.now().line] = r !== n.length), (s = t.now().offset), p(v);
  }
  function f(v) {
    return (t.containerState = {}), e.attempt(Sg, h, p)(v);
  }
  function h(v) {
    return r++, n.push([t.currentConstruct, t.containerState]), f(v);
  }
  function p(v) {
    if (v === null) {
      i && m(), b(0), e.consume(v);
      return;
    }
    return (
      (i = i || t.parser.flow(t.now())), e.enter("chunkFlow", { contentType: "flow", previous: o, _tokenizer: i }), g(v)
    );
  }
  function g(v) {
    if (v === null) {
      x(e.exit("chunkFlow"), !0), b(0), e.consume(v);
      return;
    }
    return ee(v) ? (e.consume(v), x(e.exit("chunkFlow")), (r = 0), (t.interrupt = void 0), l) : (e.consume(v), g);
  }
  function x(v, _) {
    const k = t.sliceStream(v);
    if (
      (_ && k.push(null),
      (v.previous = o),
      o && (o.next = v),
      (o = v),
      i.defineSkip(v.start),
      i.write(k),
      t.parser.lazy[v.start.line])
    ) {
      let w = i.events.length;
      for (; w--; )
        if (i.events[w][1].start.offset < s && (!i.events[w][1].end || i.events[w][1].end.offset > s)) return;
      const y = t.events.length;
      let S = y,
        T,
        A;
      for (; S--; )
        if (t.events[S][0] === "exit" && t.events[S][1].type === "chunkFlow") {
          if (T) {
            A = t.events[S][1].end;
            break;
          }
          T = !0;
        }
      for (b(r), w = y; w < t.events.length; ) (t.events[w][1].end = Object.assign({}, A)), w++;
      $t(t.events, S + 1, 0, t.events.slice(y)), (t.events.length = w);
    }
  }
  function b(v) {
    let _ = n.length;
    for (; _-- > v; ) {
      const k = n[_];
      (t.containerState = k[1]), k[0].exit.call(t, e);
    }
    n.length = v;
  }
  function m() {
    i.write([null]), (o = void 0), (i = void 0), (t.containerState._closeFlow = void 0);
  }
}
function d9(e, t, n) {
  return ve(
    e,
    e.attempt(this.parser.constructs.document, t, n),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4,
  );
}
const Oc = { name: "attention", tokenize: h9, resolveAll: f9 };
function f9(e, t) {
  let n = -1,
    r,
    i,
    o,
    s,
    l,
    a,
    u,
    c;
  for (; ++n < e.length; )
    if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
      for (r = n; r--; )
        if (
          e[r][0] === "exit" &&
          e[r][1].type === "attentionSequence" &&
          e[r][1]._open &&
          t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)
        ) {
          if (
            (e[r][1]._close || e[n][1]._open) &&
            (e[n][1].end.offset - e[n][1].start.offset) % 3 &&
            !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3)
          )
            continue;
          a = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
          const d = Object.assign({}, e[r][1].end),
            f = Object.assign({}, e[n][1].start);
          Tg(d, -a),
            Tg(f, a),
            (s = {
              type: a > 1 ? "strongSequence" : "emphasisSequence",
              start: d,
              end: Object.assign({}, e[r][1].end),
            }),
            (l = {
              type: a > 1 ? "strongSequence" : "emphasisSequence",
              start: Object.assign({}, e[n][1].start),
              end: f,
            }),
            (o = {
              type: a > 1 ? "strongText" : "emphasisText",
              start: Object.assign({}, e[r][1].end),
              end: Object.assign({}, e[n][1].start),
            }),
            (i = {
              type: a > 1 ? "strong" : "emphasis",
              start: Object.assign({}, s.start),
              end: Object.assign({}, l.end),
            }),
            (e[r][1].end = Object.assign({}, s.start)),
            (e[n][1].start = Object.assign({}, l.end)),
            (u = []),
            e[r][1].end.offset - e[r][1].start.offset &&
              (u = jt(u, [
                ["enter", e[r][1], t],
                ["exit", e[r][1], t],
              ])),
            (u = jt(u, [
              ["enter", i, t],
              ["enter", s, t],
              ["exit", s, t],
              ["enter", o, t],
            ])),
            (u = jt(u, ya(t.parser.constructs.insideSpan.null, e.slice(r + 1, n), t))),
            (u = jt(u, [
              ["exit", o, t],
              ["enter", l, t],
              ["exit", l, t],
              ["exit", i, t],
            ])),
            e[n][1].end.offset - e[n][1].start.offset
              ? ((c = 2),
                (u = jt(u, [
                  ["enter", e[n][1], t],
                  ["exit", e[n][1], t],
                ])))
              : (c = 0),
            $t(e, r - 1, n - r + 3, u),
            (n = r + u.length - c - 2);
          break;
        }
    }
  for (n = -1; ++n < e.length; ) e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
  return e;
}
function h9(e, t) {
  const n = this.parser.constructs.attentionMarkers.null,
    r = this.previous,
    i = Al(r);
  let o;
  return s;
  function s(a) {
    return (o = a), e.enter("attentionSequence"), l(a);
  }
  function l(a) {
    if (a === o) return e.consume(a), l;
    const u = e.exit("attentionSequence"),
      c = Al(a),
      d = !c || (c === 2 && i) || n.includes(a),
      f = !i || (i === 2 && c) || n.includes(r);
    return (u._open = !!(o === 42 ? d : d && (i || !f))), (u._close = !!(o === 42 ? f : f && (c || !d))), t(a);
  }
}
function Tg(e, t) {
  (e.column += t), (e.offset += t), (e._bufferIndex += t);
}
const p9 = { name: "autolink", tokenize: g9 };
function g9(e, t, n) {
  let r = 0;
  return i;
  function i(h) {
    return (
      e.enter("autolink"),
      e.enter("autolinkMarker"),
      e.consume(h),
      e.exit("autolinkMarker"),
      e.enter("autolinkProtocol"),
      o
    );
  }
  function o(h) {
    return Wt(h) ? (e.consume(h), s) : h === 64 ? n(h) : u(h);
  }
  function s(h) {
    return h === 43 || h === 45 || h === 46 || Dt(h) ? ((r = 1), l(h)) : u(h);
  }
  function l(h) {
    return h === 58
      ? (e.consume(h), (r = 0), a)
      : (h === 43 || h === 45 || h === 46 || Dt(h)) && r++ < 32
        ? (e.consume(h), l)
        : ((r = 0), u(h));
  }
  function a(h) {
    return h === 62
      ? (e.exit("autolinkProtocol"),
        e.enter("autolinkMarker"),
        e.consume(h),
        e.exit("autolinkMarker"),
        e.exit("autolink"),
        t)
      : h === null || h === 32 || h === 60 || Ac(h)
        ? n(h)
        : (e.consume(h), a);
  }
  function u(h) {
    return h === 64 ? (e.consume(h), c) : Uw(h) ? (e.consume(h), u) : n(h);
  }
  function c(h) {
    return Dt(h) ? d(h) : n(h);
  }
  function d(h) {
    return h === 46
      ? (e.consume(h), (r = 0), c)
      : h === 62
        ? ((e.exit("autolinkProtocol").type = "autolinkEmail"),
          e.enter("autolinkMarker"),
          e.consume(h),
          e.exit("autolinkMarker"),
          e.exit("autolink"),
          t)
        : f(h);
  }
  function f(h) {
    if ((h === 45 || Dt(h)) && r++ < 63) {
      const p = h === 45 ? f : d;
      return e.consume(h), p;
    }
    return n(h);
  }
}
const wa = { tokenize: m9, partial: !0 };
function m9(e, t, n) {
  return r;
  function r(o) {
    return fe(o) ? ve(e, i, "linePrefix")(o) : i(o);
  }
  function i(o) {
    return o === null || ee(o) ? t(o) : n(o);
  }
}
const kx = { name: "blockQuote", tokenize: x9, continuation: { tokenize: v9 }, exit: b9 };
function x9(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    if (s === 62) {
      const l = r.containerState;
      return (
        l.open || (e.enter("blockQuote", { _container: !0 }), (l.open = !0)),
        e.enter("blockQuotePrefix"),
        e.enter("blockQuoteMarker"),
        e.consume(s),
        e.exit("blockQuoteMarker"),
        o
      );
    }
    return n(s);
  }
  function o(s) {
    return fe(s)
      ? (e.enter("blockQuotePrefixWhitespace"),
        e.consume(s),
        e.exit("blockQuotePrefixWhitespace"),
        e.exit("blockQuotePrefix"),
        t)
      : (e.exit("blockQuotePrefix"), t(s));
  }
}
function v9(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return fe(s)
      ? ve(e, o, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(s)
      : o(s);
  }
  function o(s) {
    return e.attempt(kx, t, n)(s);
  }
}
function b9(e) {
  e.exit("blockQuote");
}
const Sx = { name: "characterEscape", tokenize: y9 };
function y9(e, t, n) {
  return r;
  function r(o) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(o), e.exit("escapeMarker"), i;
  }
  function i(o) {
    return Kw(o)
      ? (e.enter("characterEscapeValue"), e.consume(o), e.exit("characterEscapeValue"), e.exit("characterEscape"), t)
      : n(o);
  }
}
const Tx = { name: "characterReference", tokenize: C9 };
function C9(e, t, n) {
  const r = this;
  let i = 0,
    o,
    s;
  return l;
  function l(d) {
    return (
      e.enter("characterReference"),
      e.enter("characterReferenceMarker"),
      e.consume(d),
      e.exit("characterReferenceMarker"),
      a
    );
  }
  function a(d) {
    return d === 35
      ? (e.enter("characterReferenceMarkerNumeric"), e.consume(d), e.exit("characterReferenceMarkerNumeric"), u)
      : (e.enter("characterReferenceValue"), (o = 31), (s = Dt), c(d));
  }
  function u(d) {
    return d === 88 || d === 120
      ? (e.enter("characterReferenceMarkerHexadecimal"),
        e.consume(d),
        e.exit("characterReferenceMarkerHexadecimal"),
        e.enter("characterReferenceValue"),
        (o = 6),
        (s = Ww),
        c)
      : (e.enter("characterReferenceValue"), (o = 7), (s = Ic), c(d));
  }
  function c(d) {
    if (d === 59 && i) {
      const f = e.exit("characterReferenceValue");
      return s === Dt && !$o(r.sliceSerialize(f))
        ? n(d)
        : (e.enter("characterReferenceMarker"),
          e.consume(d),
          e.exit("characterReferenceMarker"),
          e.exit("characterReference"),
          t);
    }
    return s(d) && i++ < o ? (e.consume(d), c) : n(d);
  }
}
const Ag = { tokenize: w9, partial: !0 },
  Ig = { name: "codeFenced", tokenize: _9, concrete: !0 };
function _9(e, t, n) {
  const r = this,
    i = { tokenize: k, partial: !0 };
  let o = 0,
    s = 0,
    l;
  return a;
  function a(w) {
    return u(w);
  }
  function u(w) {
    const y = r.events[r.events.length - 1];
    return (
      (o = y && y[1].type === "linePrefix" ? y[2].sliceSerialize(y[1], !0).length : 0),
      (l = w),
      e.enter("codeFenced"),
      e.enter("codeFencedFence"),
      e.enter("codeFencedFenceSequence"),
      c(w)
    );
  }
  function c(w) {
    return w === l
      ? (s++, e.consume(w), c)
      : s < 3
        ? n(w)
        : (e.exit("codeFencedFenceSequence"), fe(w) ? ve(e, d, "whitespace")(w) : d(w));
  }
  function d(w) {
    return w === null || ee(w)
      ? (e.exit("codeFencedFence"), r.interrupt ? t(w) : e.check(Ag, g, _)(w))
      : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", { contentType: "string" }), f(w));
  }
  function f(w) {
    return w === null || ee(w)
      ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), d(w))
      : fe(w)
        ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), ve(e, h, "whitespace")(w))
        : w === 96 && w === l
          ? n(w)
          : (e.consume(w), f);
  }
  function h(w) {
    return w === null || ee(w)
      ? d(w)
      : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", { contentType: "string" }), p(w));
  }
  function p(w) {
    return w === null || ee(w)
      ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), d(w))
      : w === 96 && w === l
        ? n(w)
        : (e.consume(w), p);
  }
  function g(w) {
    return e.attempt(i, _, x)(w);
  }
  function x(w) {
    return e.enter("lineEnding"), e.consume(w), e.exit("lineEnding"), b;
  }
  function b(w) {
    return o > 0 && fe(w) ? ve(e, m, "linePrefix", o + 1)(w) : m(w);
  }
  function m(w) {
    return w === null || ee(w) ? e.check(Ag, g, _)(w) : (e.enter("codeFlowValue"), v(w));
  }
  function v(w) {
    return w === null || ee(w) ? (e.exit("codeFlowValue"), m(w)) : (e.consume(w), v);
  }
  function _(w) {
    return e.exit("codeFenced"), t(w);
  }
  function k(w, y, S) {
    let T = 0;
    return A;
    function A(N) {
      return w.enter("lineEnding"), w.consume(N), w.exit("lineEnding"), F;
    }
    function F(N) {
      return (
        w.enter("codeFencedFence"),
        fe(N) ? ve(w, R, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(N) : R(N)
      );
    }
    function R(N) {
      return N === l ? (w.enter("codeFencedFenceSequence"), V(N)) : S(N);
    }
    function V(N) {
      return N === l
        ? (T++, w.consume(N), V)
        : T >= s
          ? (w.exit("codeFencedFenceSequence"), fe(N) ? ve(w, B, "whitespace")(N) : B(N))
          : S(N);
    }
    function B(N) {
      return N === null || ee(N) ? (w.exit("codeFencedFence"), y(N)) : S(N);
    }
  }
}
function w9(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return s === null ? n(s) : (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), o);
  }
  function o(s) {
    return r.parser.lazy[r.now().line] ? n(s) : t(s);
  }
}
const yu = { name: "codeIndented", tokenize: k9 },
  E9 = { tokenize: S9, partial: !0 };
function k9(e, t, n) {
  const r = this;
  return i;
  function i(u) {
    return e.enter("codeIndented"), ve(e, o, "linePrefix", 5)(u);
  }
  function o(u) {
    const c = r.events[r.events.length - 1];
    return c && c[1].type === "linePrefix" && c[2].sliceSerialize(c[1], !0).length >= 4 ? s(u) : n(u);
  }
  function s(u) {
    return u === null ? a(u) : ee(u) ? e.attempt(E9, s, a)(u) : (e.enter("codeFlowValue"), l(u));
  }
  function l(u) {
    return u === null || ee(u) ? (e.exit("codeFlowValue"), s(u)) : (e.consume(u), l);
  }
  function a(u) {
    return e.exit("codeIndented"), t(u);
  }
}
function S9(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return r.parser.lazy[r.now().line]
      ? n(s)
      : ee(s)
        ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), i)
        : ve(e, o, "linePrefix", 5)(s);
  }
  function o(s) {
    const l = r.events[r.events.length - 1];
    return l && l[1].type === "linePrefix" && l[2].sliceSerialize(l[1], !0).length >= 4 ? t(s) : ee(s) ? i(s) : n(s);
  }
}
const T9 = { name: "codeText", tokenize: N9, resolve: A9, previous: I9 };
function A9(e) {
  let t = e.length - 4,
    n = 3,
    r,
    i;
  if (
    (e[n][1].type === "lineEnding" || e[n][1].type === "space") &&
    (e[t][1].type === "lineEnding" || e[t][1].type === "space")
  ) {
    for (r = n; ++r < t; )
      if (e[r][1].type === "codeTextData") {
        (e[n][1].type = "codeTextPadding"), (e[t][1].type = "codeTextPadding"), (n += 2), (t -= 2);
        break;
      }
  }
  for (r = n - 1, t++; ++r <= t; )
    i === void 0
      ? r !== t && e[r][1].type !== "lineEnding" && (i = r)
      : (r === t || e[r][1].type === "lineEnding") &&
        ((e[i][1].type = "codeTextData"),
        r !== i + 2 && ((e[i][1].end = e[r - 1][1].end), e.splice(i + 2, r - i - 2), (t -= r - i - 2), (r = i + 2)),
        (i = void 0));
  return e;
}
function I9(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function N9(e, t, n) {
  let r = 0,
    i,
    o;
  return s;
  function s(d) {
    return e.enter("codeText"), e.enter("codeTextSequence"), l(d);
  }
  function l(d) {
    return d === 96 ? (e.consume(d), r++, l) : (e.exit("codeTextSequence"), a(d));
  }
  function a(d) {
    return d === null
      ? n(d)
      : d === 32
        ? (e.enter("space"), e.consume(d), e.exit("space"), a)
        : d === 96
          ? ((o = e.enter("codeTextSequence")), (i = 0), c(d))
          : ee(d)
            ? (e.enter("lineEnding"), e.consume(d), e.exit("lineEnding"), a)
            : (e.enter("codeTextData"), u(d));
  }
  function u(d) {
    return d === null || d === 32 || d === 96 || ee(d) ? (e.exit("codeTextData"), a(d)) : (e.consume(d), u);
  }
  function c(d) {
    return d === 96
      ? (e.consume(d), i++, c)
      : i === r
        ? (e.exit("codeTextSequence"), e.exit("codeText"), t(d))
        : ((o.type = "codeTextData"), u(d));
  }
}
let L9 = class {
  constructor(t) {
    (this.left = t ? [...t] : []), (this.right = []);
  }
  get(t) {
    if (t < 0 || t >= this.left.length + this.right.length)
      throw new RangeError(
        "Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`",
      );
    return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1];
  }
  get length() {
    return this.left.length + this.right.length;
  }
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  slice(t, n) {
    const r = n ?? Number.POSITIVE_INFINITY;
    return r < this.left.length
      ? this.left.slice(t, r)
      : t > this.left.length
        ? this.right.slice(this.right.length - r + this.left.length, this.right.length - t + this.left.length).reverse()
        : this.left.slice(t).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  splice(t, n, r) {
    const i = n || 0;
    this.setCursor(Math.trunc(t));
    const o = this.right.splice(this.right.length - i, Number.POSITIVE_INFINITY);
    return r && go(this.left, r), o.reverse();
  }
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  push(t) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t);
  }
  pushMany(t) {
    this.setCursor(Number.POSITIVE_INFINITY), go(this.left, t);
  }
  unshift(t) {
    this.setCursor(0), this.right.push(t);
  }
  unshiftMany(t) {
    this.setCursor(0), go(this.right, t.reverse());
  }
  setCursor(t) {
    if (
      !(
        t === this.left.length ||
        (t > this.left.length && this.right.length === 0) ||
        (t < 0 && this.left.length === 0)
      )
    )
      if (t < this.left.length) {
        const n = this.left.splice(t, Number.POSITIVE_INFINITY);
        go(this.right, n.reverse());
      } else {
        const n = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
        go(this.left, n.reverse());
      }
  }
};
function go(e, t) {
  let n = 0;
  if (t.length < 1e4) e.push(...t);
  else for (; n < t.length; ) e.push(...t.slice(n, n + 1e4)), (n += 1e4);
}
function M9(e) {
  const t = {};
  let n = -1,
    r,
    i,
    o,
    s,
    l,
    a,
    u;
  const c = new L9(e);
  for (; ++n < c.length; ) {
    for (; n in t; ) n = t[n];
    if (
      ((r = c.get(n)),
      n &&
        r[1].type === "chunkFlow" &&
        c.get(n - 1)[1].type === "listItemPrefix" &&
        ((a = r[1]._tokenizer.events),
        (o = 0),
        o < a.length && a[o][1].type === "lineEndingBlank" && (o += 2),
        o < a.length && a[o][1].type === "content"))
    )
      for (; ++o < a.length && a[o][1].type !== "content"; )
        a[o][1].type === "chunkText" && ((a[o][1]._isInFirstContentOfListItem = !0), o++);
    if (r[0] === "enter") r[1].contentType && (Object.assign(t, O9(c, n)), (n = t[n]), (u = !0));
    else if (r[1]._container) {
      for (o = n, i = void 0; o-- && ((s = c.get(o)), s[1].type === "lineEnding" || s[1].type === "lineEndingBlank"); )
        s[0] === "enter" && (i && (c.get(i)[1].type = "lineEndingBlank"), (s[1].type = "lineEnding"), (i = o));
      i &&
        ((r[1].end = Object.assign({}, c.get(i)[1].start)),
        (l = c.slice(i, n)),
        l.unshift(r),
        c.splice(i, n - i + 1, l));
    }
  }
  return $t(e, 0, Number.POSITIVE_INFINITY, c.slice(0)), !u;
}
function O9(e, t) {
  const n = e.get(t)[1],
    r = e.get(t)[2];
  let i = t - 1;
  const o = [],
    s = n._tokenizer || r.parser[n.contentType](n.start),
    l = s.events,
    a = [],
    u = {};
  let c,
    d,
    f = -1,
    h = n,
    p = 0,
    g = 0;
  const x = [g];
  for (; h; ) {
    for (; e.get(++i)[1] !== h; );
    o.push(i),
      h._tokenizer ||
        ((c = r.sliceStream(h)),
        h.next || c.push(null),
        d && s.defineSkip(h.start),
        h._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = !0),
        s.write(c),
        h._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = void 0)),
      (d = h),
      (h = h.next);
  }
  for (h = n; ++f < l.length; )
    l[f][0] === "exit" &&
      l[f - 1][0] === "enter" &&
      l[f][1].type === l[f - 1][1].type &&
      l[f][1].start.line !== l[f][1].end.line &&
      ((g = f + 1), x.push(g), (h._tokenizer = void 0), (h.previous = void 0), (h = h.next));
  for (s.events = [], h ? ((h._tokenizer = void 0), (h.previous = void 0)) : x.pop(), f = x.length; f--; ) {
    const b = l.slice(x[f], x[f + 1]),
      m = o.pop();
    a.push([m, m + b.length - 1]), e.splice(m, 2, b);
  }
  for (a.reverse(), f = -1; ++f < a.length; ) (u[p + a[f][0]] = p + a[f][1]), (p += a[f][1] - a[f][0] - 1);
  return u;
}
const F9 = { tokenize: D9, resolve: P9 },
  R9 = { tokenize: $9, partial: !0 };
function P9(e) {
  return M9(e), e;
}
function D9(e, t) {
  let n;
  return r;
  function r(l) {
    return e.enter("content"), (n = e.enter("chunkContent", { contentType: "content" })), i(l);
  }
  function i(l) {
    return l === null ? o(l) : ee(l) ? e.check(R9, s, o)(l) : (e.consume(l), i);
  }
  function o(l) {
    return e.exit("chunkContent"), e.exit("content"), t(l);
  }
  function s(l) {
    return (
      e.consume(l),
      e.exit("chunkContent"),
      (n.next = e.enter("chunkContent", { contentType: "content", previous: n })),
      (n = n.next),
      i
    );
  }
}
function $9(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), ve(e, o, "linePrefix");
  }
  function o(s) {
    if (s === null || ee(s)) return n(s);
    const l = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") &&
      l &&
      l[1].type === "linePrefix" &&
      l[2].sliceSerialize(l[1], !0).length >= 4
      ? t(s)
      : e.interrupt(r.parser.constructs.flow, n, t)(s);
  }
}
function Ax(e, t, n, r, i, o, s, l, a) {
  const u = a || Number.POSITIVE_INFINITY;
  let c = 0;
  return d;
  function d(b) {
    return b === 60
      ? (e.enter(r), e.enter(i), e.enter(o), e.consume(b), e.exit(o), f)
      : b === null || b === 32 || b === 41 || Ac(b)
        ? n(b)
        : (e.enter(r), e.enter(s), e.enter(l), e.enter("chunkString", { contentType: "string" }), g(b));
  }
  function f(b) {
    return b === 62
      ? (e.enter(o), e.consume(b), e.exit(o), e.exit(i), e.exit(r), t)
      : (e.enter(l), e.enter("chunkString", { contentType: "string" }), h(b));
  }
  function h(b) {
    return b === 62
      ? (e.exit("chunkString"), e.exit(l), f(b))
      : b === null || b === 60 || ee(b)
        ? n(b)
        : (e.consume(b), b === 92 ? p : h);
  }
  function p(b) {
    return b === 60 || b === 62 || b === 92 ? (e.consume(b), h) : h(b);
  }
  function g(b) {
    return !c && (b === null || b === 41 || Ae(b))
      ? (e.exit("chunkString"), e.exit(l), e.exit(s), e.exit(r), t(b))
      : c < u && b === 40
        ? (e.consume(b), c++, g)
        : b === 41
          ? (e.consume(b), c--, g)
          : b === null || b === 32 || b === 40 || Ac(b)
            ? n(b)
            : (e.consume(b), b === 92 ? x : g);
  }
  function x(b) {
    return b === 40 || b === 41 || b === 92 ? (e.consume(b), g) : g(b);
  }
}
function Ix(e, t, n, r, i, o) {
  const s = this;
  let l = 0,
    a;
  return u;
  function u(h) {
    return e.enter(r), e.enter(i), e.consume(h), e.exit(i), e.enter(o), c;
  }
  function c(h) {
    return l > 999 ||
      h === null ||
      h === 91 ||
      (h === 93 && !a) ||
      (h === 94 && !l && "_hiddenFootnoteSupport" in s.parser.constructs)
      ? n(h)
      : h === 93
        ? (e.exit(o), e.enter(i), e.consume(h), e.exit(i), e.exit(r), t)
        : ee(h)
          ? (e.enter("lineEnding"), e.consume(h), e.exit("lineEnding"), c)
          : (e.enter("chunkString", { contentType: "string" }), d(h));
  }
  function d(h) {
    return h === null || h === 91 || h === 93 || ee(h) || l++ > 999
      ? (e.exit("chunkString"), c(h))
      : (e.consume(h), a || (a = !fe(h)), h === 92 ? f : d);
  }
  function f(h) {
    return h === 91 || h === 92 || h === 93 ? (e.consume(h), l++, d) : d(h);
  }
}
function Nx(e, t, n, r, i, o) {
  let s;
  return l;
  function l(f) {
    return f === 34 || f === 39 || f === 40
      ? (e.enter(r), e.enter(i), e.consume(f), e.exit(i), (s = f === 40 ? 41 : f), a)
      : n(f);
  }
  function a(f) {
    return f === s ? (e.enter(i), e.consume(f), e.exit(i), e.exit(r), t) : (e.enter(o), u(f));
  }
  function u(f) {
    return f === s
      ? (e.exit(o), a(s))
      : f === null
        ? n(f)
        : ee(f)
          ? (e.enter("lineEnding"), e.consume(f), e.exit("lineEnding"), ve(e, u, "linePrefix"))
          : (e.enter("chunkString", { contentType: "string" }), c(f));
  }
  function c(f) {
    return f === s || f === null || ee(f) ? (e.exit("chunkString"), u(f)) : (e.consume(f), f === 92 ? d : c);
  }
  function d(f) {
    return f === s || f === 92 ? (e.consume(f), c) : c(f);
  }
}
function Kn(e, t) {
  let n;
  return r;
  function r(i) {
    return ee(i)
      ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), (n = !0), r)
      : fe(i)
        ? ve(e, r, n ? "linePrefix" : "lineSuffix")(i)
        : t(i);
  }
}
function Sf(e) {
  return e
    .replace(/[\t\n\r ]+/g, " ")
    .replace(/^ | $/g, "")
    .toLowerCase()
    .toUpperCase();
}
const B9 = { name: "definition", tokenize: V9 },
  H9 = { tokenize: z9, partial: !0 };
function V9(e, t, n) {
  const r = this;
  let i;
  return o;
  function o(h) {
    return e.enter("definition"), s(h);
  }
  function s(h) {
    return Ix.call(r, e, l, n, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(h);
  }
  function l(h) {
    return (
      (i = Sf(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))),
      h === 58 ? (e.enter("definitionMarker"), e.consume(h), e.exit("definitionMarker"), a) : n(h)
    );
  }
  function a(h) {
    return Ae(h) ? Kn(e, u)(h) : u(h);
  }
  function u(h) {
    return Ax(
      e,
      c,
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString",
    )(h);
  }
  function c(h) {
    return e.attempt(H9, d, d)(h);
  }
  function d(h) {
    return fe(h) ? ve(e, f, "whitespace")(h) : f(h);
  }
  function f(h) {
    return h === null || ee(h) ? (e.exit("definition"), r.parser.defined.push(i), t(h)) : n(h);
  }
}
function z9(e, t, n) {
  return r;
  function r(l) {
    return Ae(l) ? Kn(e, i)(l) : n(l);
  }
  function i(l) {
    return Nx(e, o, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(l);
  }
  function o(l) {
    return fe(l) ? ve(e, s, "whitespace")(l) : s(l);
  }
  function s(l) {
    return l === null || ee(l) ? t(l) : n(l);
  }
}
const j9 = { name: "hardBreakEscape", tokenize: U9 };
function U9(e, t, n) {
  return r;
  function r(o) {
    return e.enter("hardBreakEscape"), e.consume(o), i;
  }
  function i(o) {
    return ee(o) ? (e.exit("hardBreakEscape"), t(o)) : n(o);
  }
}
const W9 = { name: "headingAtx", tokenize: J9, resolve: K9 };
function K9(e, t) {
  let n = e.length - 2,
    r = 3,
    i,
    o;
  return (
    e[r][1].type === "whitespace" && (r += 2),
    n - 2 > r && e[n][1].type === "whitespace" && (n -= 2),
    e[n][1].type === "atxHeadingSequence" &&
      (r === n - 1 || (n - 4 > r && e[n - 2][1].type === "whitespace")) &&
      (n -= r + 1 === n ? 2 : 4),
    n > r &&
      ((i = { type: "atxHeadingText", start: e[r][1].start, end: e[n][1].end }),
      (o = { type: "chunkText", start: e[r][1].start, end: e[n][1].end, contentType: "text" }),
      $t(e, r, n - r + 1, [
        ["enter", i, t],
        ["enter", o, t],
        ["exit", o, t],
        ["exit", i, t],
      ])),
    e
  );
}
function J9(e, t, n) {
  let r = 0;
  return i;
  function i(c) {
    return e.enter("atxHeading"), o(c);
  }
  function o(c) {
    return e.enter("atxHeadingSequence"), s(c);
  }
  function s(c) {
    return c === 35 && r++ < 6 ? (e.consume(c), s) : c === null || Ae(c) ? (e.exit("atxHeadingSequence"), l(c)) : n(c);
  }
  function l(c) {
    return c === 35
      ? (e.enter("atxHeadingSequence"), a(c))
      : c === null || ee(c)
        ? (e.exit("atxHeading"), t(c))
        : fe(c)
          ? ve(e, l, "whitespace")(c)
          : (e.enter("atxHeadingText"), u(c));
  }
  function a(c) {
    return c === 35 ? (e.consume(c), a) : (e.exit("atxHeadingSequence"), l(c));
  }
  function u(c) {
    return c === null || c === 35 || Ae(c) ? (e.exit("atxHeadingText"), l(c)) : (e.consume(c), u);
  }
}
const G9 = [
    "address",
    "article",
    "aside",
    "base",
    "basefont",
    "blockquote",
    "body",
    "caption",
    "center",
    "col",
    "colgroup",
    "dd",
    "details",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "frame",
    "frameset",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hr",
    "html",
    "iframe",
    "legend",
    "li",
    "link",
    "main",
    "menu",
    "menuitem",
    "nav",
    "noframes",
    "ol",
    "optgroup",
    "option",
    "p",
    "param",
    "search",
    "section",
    "summary",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "title",
    "tr",
    "track",
    "ul",
  ],
  Ng = ["pre", "script", "style", "textarea"],
  Z9 = { name: "htmlFlow", tokenize: Q9, resolveTo: X9, concrete: !0 },
  q9 = { tokenize: tS, partial: !0 },
  Y9 = { tokenize: eS, partial: !0 };
function X9(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); );
  return (
    t > 1 &&
      e[t - 2][1].type === "linePrefix" &&
      ((e[t][1].start = e[t - 2][1].start), (e[t + 1][1].start = e[t - 2][1].start), e.splice(t - 2, 2)),
    e
  );
}
function Q9(e, t, n) {
  const r = this;
  let i, o, s, l, a;
  return u;
  function u(M) {
    return c(M);
  }
  function c(M) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(M), d;
  }
  function d(M) {
    return M === 33
      ? (e.consume(M), f)
      : M === 47
        ? (e.consume(M), (o = !0), g)
        : M === 63
          ? (e.consume(M), (i = 3), r.interrupt ? t : L)
          : Wt(M)
            ? (e.consume(M), (s = String.fromCharCode(M)), x)
            : n(M);
  }
  function f(M) {
    return M === 45
      ? (e.consume(M), (i = 2), h)
      : M === 91
        ? (e.consume(M), (i = 5), (l = 0), p)
        : Wt(M)
          ? (e.consume(M), (i = 4), r.interrupt ? t : L)
          : n(M);
  }
  function h(M) {
    return M === 45 ? (e.consume(M), r.interrupt ? t : L) : n(M);
  }
  function p(M) {
    const me = "CDATA[";
    return M === me.charCodeAt(l++) ? (e.consume(M), l === me.length ? (r.interrupt ? t : R) : p) : n(M);
  }
  function g(M) {
    return Wt(M) ? (e.consume(M), (s = String.fromCharCode(M)), x) : n(M);
  }
  function x(M) {
    if (M === null || M === 47 || M === 62 || Ae(M)) {
      const me = M === 47,
        Ee = s.toLowerCase();
      return !me && !o && Ng.includes(Ee)
        ? ((i = 1), r.interrupt ? t(M) : R(M))
        : G9.includes(s.toLowerCase())
          ? ((i = 6), me ? (e.consume(M), b) : r.interrupt ? t(M) : R(M))
          : ((i = 7), r.interrupt && !r.parser.lazy[r.now().line] ? n(M) : o ? m(M) : v(M));
    }
    return M === 45 || Dt(M) ? (e.consume(M), (s += String.fromCharCode(M)), x) : n(M);
  }
  function b(M) {
    return M === 62 ? (e.consume(M), r.interrupt ? t : R) : n(M);
  }
  function m(M) {
    return fe(M) ? (e.consume(M), m) : A(M);
  }
  function v(M) {
    return M === 47
      ? (e.consume(M), A)
      : M === 58 || M === 95 || Wt(M)
        ? (e.consume(M), _)
        : fe(M)
          ? (e.consume(M), v)
          : A(M);
  }
  function _(M) {
    return M === 45 || M === 46 || M === 58 || M === 95 || Dt(M) ? (e.consume(M), _) : k(M);
  }
  function k(M) {
    return M === 61 ? (e.consume(M), w) : fe(M) ? (e.consume(M), k) : v(M);
  }
  function w(M) {
    return M === null || M === 60 || M === 61 || M === 62 || M === 96
      ? n(M)
      : M === 34 || M === 39
        ? (e.consume(M), (a = M), y)
        : fe(M)
          ? (e.consume(M), w)
          : S(M);
  }
  function y(M) {
    return M === a ? (e.consume(M), (a = null), T) : M === null || ee(M) ? n(M) : (e.consume(M), y);
  }
  function S(M) {
    return M === null || M === 34 || M === 39 || M === 47 || M === 60 || M === 61 || M === 62 || M === 96 || Ae(M)
      ? k(M)
      : (e.consume(M), S);
  }
  function T(M) {
    return M === 47 || M === 62 || fe(M) ? v(M) : n(M);
  }
  function A(M) {
    return M === 62 ? (e.consume(M), F) : n(M);
  }
  function F(M) {
    return M === null || ee(M) ? R(M) : fe(M) ? (e.consume(M), F) : n(M);
  }
  function R(M) {
    return M === 45 && i === 2
      ? (e.consume(M), G)
      : M === 60 && i === 1
        ? (e.consume(M), U)
        : M === 62 && i === 4
          ? (e.consume(M), se)
          : M === 63 && i === 3
            ? (e.consume(M), L)
            : M === 93 && i === 5
              ? (e.consume(M), te)
              : ee(M) && (i === 6 || i === 7)
                ? (e.exit("htmlFlowData"), e.check(q9, pe, V)(M))
                : M === null || ee(M)
                  ? (e.exit("htmlFlowData"), V(M))
                  : (e.consume(M), R);
  }
  function V(M) {
    return e.check(Y9, B, pe)(M);
  }
  function B(M) {
    return e.enter("lineEnding"), e.consume(M), e.exit("lineEnding"), N;
  }
  function N(M) {
    return M === null || ee(M) ? V(M) : (e.enter("htmlFlowData"), R(M));
  }
  function G(M) {
    return M === 45 ? (e.consume(M), L) : R(M);
  }
  function U(M) {
    return M === 47 ? (e.consume(M), (s = ""), X) : R(M);
  }
  function X(M) {
    if (M === 62) {
      const me = s.toLowerCase();
      return Ng.includes(me) ? (e.consume(M), se) : R(M);
    }
    return Wt(M) && s.length < 8 ? (e.consume(M), (s += String.fromCharCode(M)), X) : R(M);
  }
  function te(M) {
    return M === 93 ? (e.consume(M), L) : R(M);
  }
  function L(M) {
    return M === 62 ? (e.consume(M), se) : M === 45 && i === 2 ? (e.consume(M), L) : R(M);
  }
  function se(M) {
    return M === null || ee(M) ? (e.exit("htmlFlowData"), pe(M)) : (e.consume(M), se);
  }
  function pe(M) {
    return e.exit("htmlFlow"), t(M);
  }
}
function eS(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return ee(s) ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), o) : n(s);
  }
  function o(s) {
    return r.parser.lazy[r.now().line] ? n(s) : t(s);
  }
}
function tS(e, t, n) {
  return r;
  function r(i) {
    return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), e.attempt(wa, t, n);
  }
}
const nS = { name: "htmlText", tokenize: rS };
function rS(e, t, n) {
  const r = this;
  let i, o, s;
  return l;
  function l(L) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(L), a;
  }
  function a(L) {
    return L === 33
      ? (e.consume(L), u)
      : L === 47
        ? (e.consume(L), k)
        : L === 63
          ? (e.consume(L), v)
          : Wt(L)
            ? (e.consume(L), S)
            : n(L);
  }
  function u(L) {
    return L === 45 ? (e.consume(L), c) : L === 91 ? (e.consume(L), (o = 0), p) : Wt(L) ? (e.consume(L), m) : n(L);
  }
  function c(L) {
    return L === 45 ? (e.consume(L), h) : n(L);
  }
  function d(L) {
    return L === null ? n(L) : L === 45 ? (e.consume(L), f) : ee(L) ? ((s = d), U(L)) : (e.consume(L), d);
  }
  function f(L) {
    return L === 45 ? (e.consume(L), h) : d(L);
  }
  function h(L) {
    return L === 62 ? G(L) : L === 45 ? f(L) : d(L);
  }
  function p(L) {
    const se = "CDATA[";
    return L === se.charCodeAt(o++) ? (e.consume(L), o === se.length ? g : p) : n(L);
  }
  function g(L) {
    return L === null ? n(L) : L === 93 ? (e.consume(L), x) : ee(L) ? ((s = g), U(L)) : (e.consume(L), g);
  }
  function x(L) {
    return L === 93 ? (e.consume(L), b) : g(L);
  }
  function b(L) {
    return L === 62 ? G(L) : L === 93 ? (e.consume(L), b) : g(L);
  }
  function m(L) {
    return L === null || L === 62 ? G(L) : ee(L) ? ((s = m), U(L)) : (e.consume(L), m);
  }
  function v(L) {
    return L === null ? n(L) : L === 63 ? (e.consume(L), _) : ee(L) ? ((s = v), U(L)) : (e.consume(L), v);
  }
  function _(L) {
    return L === 62 ? G(L) : v(L);
  }
  function k(L) {
    return Wt(L) ? (e.consume(L), w) : n(L);
  }
  function w(L) {
    return L === 45 || Dt(L) ? (e.consume(L), w) : y(L);
  }
  function y(L) {
    return ee(L) ? ((s = y), U(L)) : fe(L) ? (e.consume(L), y) : G(L);
  }
  function S(L) {
    return L === 45 || Dt(L) ? (e.consume(L), S) : L === 47 || L === 62 || Ae(L) ? T(L) : n(L);
  }
  function T(L) {
    return L === 47
      ? (e.consume(L), G)
      : L === 58 || L === 95 || Wt(L)
        ? (e.consume(L), A)
        : ee(L)
          ? ((s = T), U(L))
          : fe(L)
            ? (e.consume(L), T)
            : G(L);
  }
  function A(L) {
    return L === 45 || L === 46 || L === 58 || L === 95 || Dt(L) ? (e.consume(L), A) : F(L);
  }
  function F(L) {
    return L === 61 ? (e.consume(L), R) : ee(L) ? ((s = F), U(L)) : fe(L) ? (e.consume(L), F) : T(L);
  }
  function R(L) {
    return L === null || L === 60 || L === 61 || L === 62 || L === 96
      ? n(L)
      : L === 34 || L === 39
        ? (e.consume(L), (i = L), V)
        : ee(L)
          ? ((s = R), U(L))
          : fe(L)
            ? (e.consume(L), R)
            : (e.consume(L), B);
  }
  function V(L) {
    return L === i ? (e.consume(L), (i = void 0), N) : L === null ? n(L) : ee(L) ? ((s = V), U(L)) : (e.consume(L), V);
  }
  function B(L) {
    return L === null || L === 34 || L === 39 || L === 60 || L === 61 || L === 96
      ? n(L)
      : L === 47 || L === 62 || Ae(L)
        ? T(L)
        : (e.consume(L), B);
  }
  function N(L) {
    return L === 47 || L === 62 || Ae(L) ? T(L) : n(L);
  }
  function G(L) {
    return L === 62 ? (e.consume(L), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(L);
  }
  function U(L) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(L), e.exit("lineEnding"), X;
  }
  function X(L) {
    return fe(L)
      ? ve(e, te, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(L)
      : te(L);
  }
  function te(L) {
    return e.enter("htmlTextData"), s(L);
  }
}
const Tf = { name: "labelEnd", tokenize: uS, resolveTo: aS, resolveAll: lS },
  iS = { tokenize: cS },
  oS = { tokenize: dS },
  sS = { tokenize: fS };
function lS(e) {
  let t = -1;
  for (; ++t < e.length; ) {
    const n = e[t][1];
    (n.type === "labelImage" || n.type === "labelLink" || n.type === "labelEnd") &&
      (e.splice(t + 1, n.type === "labelImage" ? 4 : 2), (n.type = "data"), t++);
  }
  return e;
}
function aS(e, t) {
  let n = e.length,
    r = 0,
    i,
    o,
    s,
    l;
  for (; n--; )
    if (((i = e[n][1]), o)) {
      if (i.type === "link" || (i.type === "labelLink" && i._inactive)) break;
      e[n][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (s) {
      if (
        e[n][0] === "enter" &&
        (i.type === "labelImage" || i.type === "labelLink") &&
        !i._balanced &&
        ((o = n), i.type !== "labelLink")
      ) {
        r = 2;
        break;
      }
    } else i.type === "labelEnd" && (s = n);
  const a = {
      type: e[o][1].type === "labelLink" ? "link" : "image",
      start: Object.assign({}, e[o][1].start),
      end: Object.assign({}, e[e.length - 1][1].end),
    },
    u = { type: "label", start: Object.assign({}, e[o][1].start), end: Object.assign({}, e[s][1].end) },
    c = { type: "labelText", start: Object.assign({}, e[o + r + 2][1].end), end: Object.assign({}, e[s - 2][1].start) };
  return (
    (l = [
      ["enter", a, t],
      ["enter", u, t],
    ]),
    (l = jt(l, e.slice(o + 1, o + r + 3))),
    (l = jt(l, [["enter", c, t]])),
    (l = jt(l, ya(t.parser.constructs.insideSpan.null, e.slice(o + r + 4, s - 3), t))),
    (l = jt(l, [["exit", c, t], e[s - 2], e[s - 1], ["exit", u, t]])),
    (l = jt(l, e.slice(s + 1))),
    (l = jt(l, [["exit", a, t]])),
    $t(e, o, e.length, l),
    e
  );
}
function uS(e, t, n) {
  const r = this;
  let i = r.events.length,
    o,
    s;
  for (; i--; )
    if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
      o = r.events[i][1];
      break;
    }
  return l;
  function l(f) {
    return o
      ? o._inactive
        ? d(f)
        : ((s = r.parser.defined.includes(Sf(r.sliceSerialize({ start: o.end, end: r.now() })))),
          e.enter("labelEnd"),
          e.enter("labelMarker"),
          e.consume(f),
          e.exit("labelMarker"),
          e.exit("labelEnd"),
          a)
      : n(f);
  }
  function a(f) {
    return f === 40 ? e.attempt(iS, c, s ? c : d)(f) : f === 91 ? e.attempt(oS, c, s ? u : d)(f) : s ? c(f) : d(f);
  }
  function u(f) {
    return e.attempt(sS, c, d)(f);
  }
  function c(f) {
    return t(f);
  }
  function d(f) {
    return (o._balanced = !0), n(f);
  }
}
function cS(e, t, n) {
  return r;
  function r(d) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(d), e.exit("resourceMarker"), i;
  }
  function i(d) {
    return Ae(d) ? Kn(e, o)(d) : o(d);
  }
  function o(d) {
    return d === 41
      ? c(d)
      : Ax(
          e,
          s,
          l,
          "resourceDestination",
          "resourceDestinationLiteral",
          "resourceDestinationLiteralMarker",
          "resourceDestinationRaw",
          "resourceDestinationString",
          32,
        )(d);
  }
  function s(d) {
    return Ae(d) ? Kn(e, a)(d) : c(d);
  }
  function l(d) {
    return n(d);
  }
  function a(d) {
    return d === 34 || d === 39 || d === 40
      ? Nx(e, u, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(d)
      : c(d);
  }
  function u(d) {
    return Ae(d) ? Kn(e, c)(d) : c(d);
  }
  function c(d) {
    return d === 41 ? (e.enter("resourceMarker"), e.consume(d), e.exit("resourceMarker"), e.exit("resource"), t) : n(d);
  }
}
function dS(e, t, n) {
  const r = this;
  return i;
  function i(l) {
    return Ix.call(r, e, o, s, "reference", "referenceMarker", "referenceString")(l);
  }
  function o(l) {
    return r.parser.defined.includes(Sf(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(l) : n(l);
  }
  function s(l) {
    return n(l);
  }
}
function fS(e, t, n) {
  return r;
  function r(o) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(o), e.exit("referenceMarker"), i;
  }
  function i(o) {
    return o === 93
      ? (e.enter("referenceMarker"), e.consume(o), e.exit("referenceMarker"), e.exit("reference"), t)
      : n(o);
  }
}
const hS = { name: "labelStartImage", tokenize: pS, resolveAll: Tf.resolveAll };
function pS(e, t, n) {
  const r = this;
  return i;
  function i(l) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(l), e.exit("labelImageMarker"), o;
  }
  function o(l) {
    return l === 91 ? (e.enter("labelMarker"), e.consume(l), e.exit("labelMarker"), e.exit("labelImage"), s) : n(l);
  }
  function s(l) {
    return l === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(l) : t(l);
  }
}
const gS = { name: "labelStartLink", tokenize: mS, resolveAll: Tf.resolveAll };
function mS(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(s), e.exit("labelMarker"), e.exit("labelLink"), o;
  }
  function o(s) {
    return s === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(s) : t(s);
  }
}
const Cu = { name: "lineEnding", tokenize: xS };
function xS(e, t) {
  return n;
  function n(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), ve(e, t, "linePrefix");
  }
}
const rl = { name: "thematicBreak", tokenize: vS };
function vS(e, t, n) {
  let r = 0,
    i;
  return o;
  function o(u) {
    return e.enter("thematicBreak"), s(u);
  }
  function s(u) {
    return (i = u), l(u);
  }
  function l(u) {
    return u === i
      ? (e.enter("thematicBreakSequence"), a(u))
      : r >= 3 && (u === null || ee(u))
        ? (e.exit("thematicBreak"), t(u))
        : n(u);
  }
  function a(u) {
    return u === i
      ? (e.consume(u), r++, a)
      : (e.exit("thematicBreakSequence"), fe(u) ? ve(e, l, "whitespace")(u) : l(u));
  }
}
const It = { name: "list", tokenize: CS, continuation: { tokenize: _S }, exit: ES },
  bS = { tokenize: kS, partial: !0 },
  yS = { tokenize: wS, partial: !0 };
function CS(e, t, n) {
  const r = this,
    i = r.events[r.events.length - 1];
  let o = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0,
    s = 0;
  return l;
  function l(h) {
    const p = r.containerState.type || (h === 42 || h === 43 || h === 45 ? "listUnordered" : "listOrdered");
    if (p === "listUnordered" ? !r.containerState.marker || h === r.containerState.marker : Ic(h)) {
      if (
        (r.containerState.type || ((r.containerState.type = p), e.enter(p, { _container: !0 })), p === "listUnordered")
      )
        return e.enter("listItemPrefix"), h === 42 || h === 45 ? e.check(rl, n, u)(h) : u(h);
      if (!r.interrupt || h === 49) return e.enter("listItemPrefix"), e.enter("listItemValue"), a(h);
    }
    return n(h);
  }
  function a(h) {
    return Ic(h) && ++s < 10
      ? (e.consume(h), a)
      : (!r.interrupt || s < 2) && (r.containerState.marker ? h === r.containerState.marker : h === 41 || h === 46)
        ? (e.exit("listItemValue"), u(h))
        : n(h);
  }
  function u(h) {
    return (
      e.enter("listItemMarker"),
      e.consume(h),
      e.exit("listItemMarker"),
      (r.containerState.marker = r.containerState.marker || h),
      e.check(wa, r.interrupt ? n : c, e.attempt(bS, f, d))
    );
  }
  function c(h) {
    return (r.containerState.initialBlankLine = !0), o++, f(h);
  }
  function d(h) {
    return fe(h) ? (e.enter("listItemPrefixWhitespace"), e.consume(h), e.exit("listItemPrefixWhitespace"), f) : n(h);
  }
  function f(h) {
    return (r.containerState.size = o + r.sliceSerialize(e.exit("listItemPrefix"), !0).length), t(h);
  }
}
function _S(e, t, n) {
  const r = this;
  return (r.containerState._closeFlow = void 0), e.check(wa, i, o);
  function i(l) {
    return (
      (r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine),
      ve(e, t, "listItemIndent", r.containerState.size + 1)(l)
    );
  }
  function o(l) {
    return r.containerState.furtherBlankLines || !fe(l)
      ? ((r.containerState.furtherBlankLines = void 0), (r.containerState.initialBlankLine = void 0), s(l))
      : ((r.containerState.furtherBlankLines = void 0),
        (r.containerState.initialBlankLine = void 0),
        e.attempt(yS, t, s)(l));
  }
  function s(l) {
    return (
      (r.containerState._closeFlow = !0),
      (r.interrupt = void 0),
      ve(
        e,
        e.attempt(It, t, n),
        "linePrefix",
        r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4,
      )(l)
    );
  }
}
function wS(e, t, n) {
  const r = this;
  return ve(e, i, "listItemIndent", r.containerState.size + 1);
  function i(o) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "listItemIndent" && s[2].sliceSerialize(s[1], !0).length === r.containerState.size
      ? t(o)
      : n(o);
  }
}
function ES(e) {
  e.exit(this.containerState.type);
}
function kS(e, t, n) {
  const r = this;
  return ve(e, i, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function i(o) {
    const s = r.events[r.events.length - 1];
    return !fe(o) && s && s[1].type === "listItemPrefixWhitespace" ? t(o) : n(o);
  }
}
const Lg = { name: "setextUnderline", tokenize: TS, resolveTo: SS };
function SS(e, t) {
  let n = e.length,
    r,
    i,
    o;
  for (; n--; )
    if (e[n][0] === "enter") {
      if (e[n][1].type === "content") {
        r = n;
        break;
      }
      e[n][1].type === "paragraph" && (i = n);
    } else e[n][1].type === "content" && e.splice(n, 1), !o && e[n][1].type === "definition" && (o = n);
  const s = {
    type: "setextHeading",
    start: Object.assign({}, e[i][1].start),
    end: Object.assign({}, e[e.length - 1][1].end),
  };
  return (
    (e[i][1].type = "setextHeadingText"),
    o
      ? (e.splice(i, 0, ["enter", s, t]),
        e.splice(o + 1, 0, ["exit", e[r][1], t]),
        (e[r][1].end = Object.assign({}, e[o][1].end)))
      : (e[r][1] = s),
    e.push(["exit", s, t]),
    e
  );
}
function TS(e, t, n) {
  const r = this;
  let i;
  return o;
  function o(u) {
    let c = r.events.length,
      d;
    for (; c--; )
      if (
        r.events[c][1].type !== "lineEnding" &&
        r.events[c][1].type !== "linePrefix" &&
        r.events[c][1].type !== "content"
      ) {
        d = r.events[c][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || d) ? (e.enter("setextHeadingLine"), (i = u), s(u)) : n(u);
  }
  function s(u) {
    return e.enter("setextHeadingLineSequence"), l(u);
  }
  function l(u) {
    return u === i
      ? (e.consume(u), l)
      : (e.exit("setextHeadingLineSequence"), fe(u) ? ve(e, a, "lineSuffix")(u) : a(u));
  }
  function a(u) {
    return u === null || ee(u) ? (e.exit("setextHeadingLine"), t(u)) : n(u);
  }
}
const AS = { tokenize: IS };
function IS(e) {
  const t = this,
    n = e.attempt(
      wa,
      r,
      e.attempt(
        this.parser.constructs.flowInitial,
        i,
        ve(e, e.attempt(this.parser.constructs.flow, i, e.attempt(F9, i)), "linePrefix"),
      ),
    );
  return n;
  function r(o) {
    if (o === null) {
      e.consume(o);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(o), e.exit("lineEndingBlank"), (t.currentConstruct = void 0), n;
  }
  function i(o) {
    if (o === null) {
      e.consume(o);
      return;
    }
    return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), (t.currentConstruct = void 0), n;
  }
}
const NS = { resolveAll: Mx() },
  LS = Lx("string"),
  MS = Lx("text");
function Lx(e) {
  return { tokenize: t, resolveAll: Mx(e === "text" ? OS : void 0) };
  function t(n) {
    const r = this,
      i = this.parser.constructs[e],
      o = n.attempt(i, s, l);
    return s;
    function s(c) {
      return u(c) ? o(c) : l(c);
    }
    function l(c) {
      if (c === null) {
        n.consume(c);
        return;
      }
      return n.enter("data"), n.consume(c), a;
    }
    function a(c) {
      return u(c) ? (n.exit("data"), o(c)) : (n.consume(c), a);
    }
    function u(c) {
      if (c === null) return !0;
      const d = i[c];
      let f = -1;
      if (d)
        for (; ++f < d.length; ) {
          const h = d[f];
          if (!h.previous || h.previous.call(r, r.previous)) return !0;
        }
      return !1;
    }
  }
}
function Mx(e) {
  return t;
  function t(n, r) {
    let i = -1,
      o;
    for (; ++i <= n.length; )
      o === void 0
        ? n[i] && n[i][1].type === "data" && ((o = i), i++)
        : (!n[i] || n[i][1].type !== "data") &&
          (i !== o + 2 && ((n[o][1].end = n[i - 1][1].end), n.splice(o + 2, i - o - 2), (i = o + 2)), (o = void 0));
    return e ? e(n, r) : n;
  }
}
function OS(e, t) {
  let n = 0;
  for (; ++n <= e.length; )
    if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
      const r = e[n - 1][1],
        i = t.sliceStream(r);
      let o = i.length,
        s = -1,
        l = 0,
        a;
      for (; o--; ) {
        const u = i[o];
        if (typeof u == "string") {
          for (s = u.length; u.charCodeAt(s - 1) === 32; ) l++, s--;
          if (s) break;
          s = -1;
        } else if (u === -2) (a = !0), l++;
        else if (u !== -1) {
          o++;
          break;
        }
      }
      if (l) {
        const u = {
          type: n === e.length || a || l < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: r.end.line,
            column: r.end.column - l,
            offset: r.end.offset - l,
            _index: r.start._index + o,
            _bufferIndex: o ? s : r.start._bufferIndex + s,
          },
          end: Object.assign({}, r.end),
        };
        (r.end = Object.assign({}, u.start)),
          r.start.offset === r.end.offset
            ? Object.assign(r, u)
            : (e.splice(n, 0, ["enter", u, t], ["exit", u, t]), (n += 2));
      }
      n++;
    }
  return e;
}
function FS(e, t, n) {
  let r = Object.assign(n ? Object.assign({}, n) : { line: 1, column: 1, offset: 0 }, { _index: 0, _bufferIndex: -1 });
  const i = {},
    o = [];
  let s = [],
    l = [];
  const a = { consume: m, enter: v, exit: _, attempt: y(k), check: y(w), interrupt: y(w, { interrupt: !0 }) },
    u = {
      previous: null,
      code: null,
      containerState: {},
      events: [],
      parser: e,
      sliceStream: h,
      sliceSerialize: f,
      now: p,
      defineSkip: g,
      write: d,
    };
  let c = t.tokenize.call(u, a);
  return t.resolveAll && o.push(t), u;
  function d(F) {
    return (s = jt(s, F)), x(), s[s.length - 1] !== null ? [] : (S(t, 0), (u.events = ya(o, u.events, u)), u.events);
  }
  function f(F, R) {
    return PS(h(F), R);
  }
  function h(F) {
    return RS(s, F);
  }
  function p() {
    const { line: F, column: R, offset: V, _index: B, _bufferIndex: N } = r;
    return { line: F, column: R, offset: V, _index: B, _bufferIndex: N };
  }
  function g(F) {
    (i[F.line] = F.column), A();
  }
  function x() {
    let F;
    for (; r._index < s.length; ) {
      const R = s[r._index];
      if (typeof R == "string")
        for (F = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === F && r._bufferIndex < R.length; )
          b(R.charCodeAt(r._bufferIndex));
      else b(R);
    }
  }
  function b(F) {
    c = c(F);
  }
  function m(F) {
    ee(F) ? (r.line++, (r.column = 1), (r.offset += F === -3 ? 2 : 1), A()) : F !== -1 && (r.column++, r.offset++),
      r._bufferIndex < 0
        ? r._index++
        : (r._bufferIndex++, r._bufferIndex === s[r._index].length && ((r._bufferIndex = -1), r._index++)),
      (u.previous = F);
  }
  function v(F, R) {
    const V = R || {};
    return (V.type = F), (V.start = p()), u.events.push(["enter", V, u]), l.push(V), V;
  }
  function _(F) {
    const R = l.pop();
    return (R.end = p()), u.events.push(["exit", R, u]), R;
  }
  function k(F, R) {
    S(F, R.from);
  }
  function w(F, R) {
    R.restore();
  }
  function y(F, R) {
    return V;
    function V(B, N, G) {
      let U, X, te, L;
      return Array.isArray(B) ? pe(B) : "tokenize" in B ? pe([B]) : se(B);
      function se(ce) {
        return z;
        function z(W) {
          const Y = W !== null && ce[W],
            Q = W !== null && ce.null,
            oe = [...(Array.isArray(Y) ? Y : Y ? [Y] : []), ...(Array.isArray(Q) ? Q : Q ? [Q] : [])];
          return pe(oe)(W);
        }
      }
      function pe(ce) {
        return (U = ce), (X = 0), ce.length === 0 ? G : M(ce[X]);
      }
      function M(ce) {
        return z;
        function z(W) {
          return (
            (L = T()),
            (te = ce),
            ce.partial || (u.currentConstruct = ce),
            ce.name && u.parser.constructs.disable.null.includes(ce.name)
              ? Ee()
              : ce.tokenize.call(R ? Object.assign(Object.create(u), R) : u, a, me, Ee)(W)
          );
        }
      }
      function me(ce) {
        return F(te, L), N;
      }
      function Ee(ce) {
        return L.restore(), ++X < U.length ? M(U[X]) : G;
      }
    }
  }
  function S(F, R) {
    F.resolveAll && !o.includes(F) && o.push(F),
      F.resolve && $t(u.events, R, u.events.length - R, F.resolve(u.events.slice(R), u)),
      F.resolveTo && (u.events = F.resolveTo(u.events, u));
  }
  function T() {
    const F = p(),
      R = u.previous,
      V = u.currentConstruct,
      B = u.events.length,
      N = Array.from(l);
    return { restore: G, from: B };
    function G() {
      (r = F), (u.previous = R), (u.currentConstruct = V), (u.events.length = B), (l = N), A();
    }
  }
  function A() {
    r.line in i && r.column < 2 && ((r.column = i[r.line]), (r.offset += i[r.line] - 1));
  }
}
function RS(e, t) {
  const n = t.start._index,
    r = t.start._bufferIndex,
    i = t.end._index,
    o = t.end._bufferIndex;
  let s;
  if (n === i) s = [e[n].slice(r, o)];
  else {
    if (((s = e.slice(n, i)), r > -1)) {
      const l = s[0];
      typeof l == "string" ? (s[0] = l.slice(r)) : s.shift();
    }
    o > 0 && s.push(e[i].slice(0, o));
  }
  return s;
}
function PS(e, t) {
  let n = -1;
  const r = [];
  let i;
  for (; ++n < e.length; ) {
    const o = e[n];
    let s;
    if (typeof o == "string") s = o;
    else
      switch (o) {
        case -5: {
          s = "\r";
          break;
        }
        case -4: {
          s = `
`;
          break;
        }
        case -3: {
          s = `\r
`;
          break;
        }
        case -2: {
          s = t ? " " : "	";
          break;
        }
        case -1: {
          if (!t && i) continue;
          s = " ";
          break;
        }
        default:
          s = String.fromCharCode(o);
      }
    (i = o === -2), r.push(s);
  }
  return r.join("");
}
const DS = {
    42: It,
    43: It,
    45: It,
    48: It,
    49: It,
    50: It,
    51: It,
    52: It,
    53: It,
    54: It,
    55: It,
    56: It,
    57: It,
    62: kx,
  },
  $S = { 91: B9 },
  BS = { [-2]: yu, [-1]: yu, 32: yu },
  HS = { 35: W9, 42: rl, 45: [Lg, rl], 60: Z9, 61: Lg, 95: rl, 96: Ig, 126: Ig },
  VS = { 38: Tx, 92: Sx },
  zS = {
    [-5]: Cu,
    [-4]: Cu,
    [-3]: Cu,
    33: hS,
    38: Tx,
    42: Oc,
    60: [p9, nS],
    91: gS,
    92: [j9, Sx],
    93: Tf,
    95: Oc,
    96: T9,
  },
  jS = { null: [Oc, NS] },
  US = { null: [42, 95] },
  WS = { null: [] },
  KS = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        attentionMarkers: US,
        contentInitial: $S,
        disable: WS,
        document: DS,
        flow: HS,
        flowInitial: BS,
        insideSpan: jS,
        string: VS,
        text: zS,
      },
      Symbol.toStringTag,
      { value: "Module" },
    ),
  );
function JS(e) {
  const n = i9([KS, ...((e || {}).extensions || [])]),
    r = {
      defined: [],
      lazy: {},
      constructs: n,
      content: i(l9),
      document: i(u9),
      flow: i(AS),
      string: i(LS),
      text: i(MS),
    };
  return r;
  function i(o) {
    return s;
    function s(l) {
      return FS(r, o, l);
    }
  }
}
class GS {
  constructor(t) {
    (this.left = t ? [...t] : []), (this.right = []);
  }
  get(t) {
    if (t < 0 || t >= this.left.length + this.right.length)
      throw new RangeError(
        "Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`",
      );
    return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1];
  }
  get length() {
    return this.left.length + this.right.length;
  }
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  slice(t, n) {
    const r = n ?? Number.POSITIVE_INFINITY;
    return r < this.left.length
      ? this.left.slice(t, r)
      : t > this.left.length
        ? this.right.slice(this.right.length - r + this.left.length, this.right.length - t + this.left.length).reverse()
        : this.left.slice(t).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  splice(t, n, r) {
    const i = n || 0;
    this.setCursor(Math.trunc(t));
    const o = this.right.splice(this.right.length - i, Number.POSITIVE_INFINITY);
    return r && mo(this.left, r), o.reverse();
  }
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  push(t) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t);
  }
  pushMany(t) {
    this.setCursor(Number.POSITIVE_INFINITY), mo(this.left, t);
  }
  unshift(t) {
    this.setCursor(0), this.right.push(t);
  }
  unshiftMany(t) {
    this.setCursor(0), mo(this.right, t.reverse());
  }
  setCursor(t) {
    if (
      !(
        t === this.left.length ||
        (t > this.left.length && this.right.length === 0) ||
        (t < 0 && this.left.length === 0)
      )
    )
      if (t < this.left.length) {
        const n = this.left.splice(t, Number.POSITIVE_INFINITY);
        mo(this.right, n.reverse());
      } else {
        const n = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
        mo(this.left, n.reverse());
      }
  }
}
function mo(e, t) {
  let n = 0;
  if (t.length < 1e4) e.push(...t);
  else for (; n < t.length; ) e.push(...t.slice(n, n + 1e4)), (n += 1e4);
}
function ZS(e) {
  const t = {};
  let n = -1,
    r,
    i,
    o,
    s,
    l,
    a,
    u;
  const c = new GS(e);
  for (; ++n < c.length; ) {
    for (; n in t; ) n = t[n];
    if (
      ((r = c.get(n)),
      n &&
        r[1].type === "chunkFlow" &&
        c.get(n - 1)[1].type === "listItemPrefix" &&
        ((a = r[1]._tokenizer.events),
        (o = 0),
        o < a.length && a[o][1].type === "lineEndingBlank" && (o += 2),
        o < a.length && a[o][1].type === "content"))
    )
      for (; ++o < a.length && a[o][1].type !== "content"; )
        a[o][1].type === "chunkText" && ((a[o][1]._isInFirstContentOfListItem = !0), o++);
    if (r[0] === "enter") r[1].contentType && (Object.assign(t, qS(c, n)), (n = t[n]), (u = !0));
    else if (r[1]._container) {
      for (o = n, i = void 0; o-- && ((s = c.get(o)), s[1].type === "lineEnding" || s[1].type === "lineEndingBlank"); )
        s[0] === "enter" && (i && (c.get(i)[1].type = "lineEndingBlank"), (s[1].type = "lineEnding"), (i = o));
      i &&
        ((r[1].end = Object.assign({}, c.get(i)[1].start)),
        (l = c.slice(i, n)),
        l.unshift(r),
        c.splice(i, n - i + 1, l));
    }
  }
  return $t(e, 0, Number.POSITIVE_INFINITY, c.slice(0)), !u;
}
function qS(e, t) {
  const n = e.get(t)[1],
    r = e.get(t)[2];
  let i = t - 1;
  const o = [],
    s = n._tokenizer || r.parser[n.contentType](n.start),
    l = s.events,
    a = [],
    u = {};
  let c,
    d,
    f = -1,
    h = n,
    p = 0,
    g = 0;
  const x = [g];
  for (; h; ) {
    for (; e.get(++i)[1] !== h; );
    o.push(i),
      h._tokenizer ||
        ((c = r.sliceStream(h)),
        h.next || c.push(null),
        d && s.defineSkip(h.start),
        h._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = !0),
        s.write(c),
        h._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = void 0)),
      (d = h),
      (h = h.next);
  }
  for (h = n; ++f < l.length; )
    l[f][0] === "exit" &&
      l[f - 1][0] === "enter" &&
      l[f][1].type === l[f - 1][1].type &&
      l[f][1].start.line !== l[f][1].end.line &&
      ((g = f + 1), x.push(g), (h._tokenizer = void 0), (h.previous = void 0), (h = h.next));
  for (s.events = [], h ? ((h._tokenizer = void 0), (h.previous = void 0)) : x.pop(), f = x.length; f--; ) {
    const b = l.slice(x[f], x[f + 1]),
      m = o.pop();
    a.push([m, m + b.length - 1]), e.splice(m, 2, b);
  }
  for (a.reverse(), f = -1; ++f < a.length; ) (u[p + a[f][0]] = p + a[f][1]), (p += a[f][1] - a[f][0] - 1);
  return u;
}
function YS(e) {
  for (; !ZS(e); );
  return e;
}
const Mg = /[\0\t\n\r]/g;
function XS() {
  let e = 1,
    t = "",
    n = !0,
    r;
  return i;
  function i(o, s, l) {
    const a = [];
    let u, c, d, f, h;
    for (
      o = t + (typeof o == "string" ? o.toString() : new TextDecoder(s || void 0).decode(o)),
        d = 0,
        t = "",
        n && (o.charCodeAt(0) === 65279 && d++, (n = void 0));
      d < o.length;

    ) {
      if (
        ((Mg.lastIndex = d),
        (u = Mg.exec(o)),
        (f = u && u.index !== void 0 ? u.index : o.length),
        (h = o.charCodeAt(f)),
        !u)
      ) {
        t = o.slice(d);
        break;
      }
      if (h === 10 && d === f && r) a.push(-3), (r = void 0);
      else
        switch ((r && (a.push(-5), (r = void 0)), d < f && (a.push(o.slice(d, f)), (e += f - d)), h)) {
          case 0: {
            a.push(65533), e++;
            break;
          }
          case 9: {
            for (c = Math.ceil(e / 4) * 4, a.push(-2); e++ < c; ) a.push(-1);
            break;
          }
          case 10: {
            a.push(-4), (e = 1);
            break;
          }
          default:
            (r = !0), (e = 1);
        }
      d = f + 1;
    }
    return l && (r && a.push(-5), t && a.push(t), a.push(null)), a;
  }
}
function QS(e, t) {
  const n = Number.parseInt(e, t);
  return n < 9 ||
    n === 11 ||
    (n > 13 && n < 32) ||
    (n > 126 && n < 160) ||
    (n > 55295 && n < 57344) ||
    (n > 64975 && n < 65008) ||
    (n & 65535) === 65535 ||
    (n & 65535) === 65534 ||
    n > 1114111
    ? "�"
    : String.fromCodePoint(n);
}
function _u(e) {
  return e
    .replace(/[\t\n\r ]+/g, " ")
    .replace(/^ | $/g, "")
    .toLowerCase()
    .toUpperCase();
}
const Ox = {}.hasOwnProperty;
function e3(e, t, n) {
  return (
    typeof t != "string" && ((n = t), (t = void 0)),
    t3(n)(
      YS(
        JS(n)
          .document()
          .write(XS()(e, t, !0)),
      ),
    )
  );
}
function t3(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: o(st),
      autolinkProtocol: T,
      autolinkEmail: T,
      atxHeading: o(Xe),
      blockQuote: o(Q),
      characterEscape: T,
      characterReference: T,
      codeFenced: o(oe),
      codeFencedFenceInfo: s,
      codeFencedFenceMeta: s,
      codeIndented: o(oe, s),
      codeText: o(he, s),
      codeTextData: T,
      data: T,
      codeFlowValue: T,
      definition: o(ke),
      definitionDestinationString: s,
      definitionLabelString: s,
      definitionTitleString: s,
      emphasis: o(De),
      hardBreakEscape: o(Qe),
      hardBreakTrailing: o(Qe),
      htmlFlow: o(rt, s),
      htmlFlowData: T,
      htmlText: o(rt, s),
      htmlTextData: T,
      image: o(gn),
      label: s,
      link: o(st),
      listItem: o(_t),
      listItemValue: f,
      listOrdered: o(mn, d),
      listUnordered: o(mn),
      paragraph: o(Ir),
      reference: M,
      referenceString: s,
      resourceDestinationString: s,
      resourceTitleString: s,
      setextHeading: o(Xe),
      strong: o(Zt),
      thematicBreak: o(Ot),
    },
    exit: {
      atxHeading: a(),
      atxHeadingSequence: k,
      autolink: a(),
      autolinkEmail: Y,
      autolinkProtocol: W,
      blockQuote: a(),
      characterEscapeValue: A,
      characterReferenceMarkerHexadecimal: Ee,
      characterReferenceMarkerNumeric: Ee,
      characterReferenceValue: ce,
      characterReference: z,
      codeFenced: a(x),
      codeFencedFence: g,
      codeFencedFenceInfo: h,
      codeFencedFenceMeta: p,
      codeFlowValue: A,
      codeIndented: a(b),
      codeText: a(N),
      codeTextData: A,
      data: A,
      definition: a(),
      definitionDestinationString: _,
      definitionLabelString: m,
      definitionTitleString: v,
      emphasis: a(),
      hardBreakEscape: a(R),
      hardBreakTrailing: a(R),
      htmlFlow: a(V),
      htmlFlowData: A,
      htmlText: a(B),
      htmlTextData: A,
      image: a(U),
      label: te,
      labelText: X,
      lineEnding: F,
      link: a(G),
      listItem: a(),
      listOrdered: a(),
      listUnordered: a(),
      paragraph: a(),
      referenceString: me,
      resourceDestinationString: L,
      resourceTitleString: se,
      resource: pe,
      setextHeading: a(S),
      setextHeadingLineSequence: y,
      setextHeadingText: w,
      strong: a(),
      thematicBreak: a(),
    },
  };
  Fx(t, (e || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r($) {
    let j = { type: "root", children: [] };
    const I = { stack: [j], tokenStack: [], config: t, enter: l, exit: u, buffer: s, resume: c, data: n },
      de = [];
    let ye = -1;
    for (; ++ye < $.length; )
      if ($[ye][1].type === "listOrdered" || $[ye][1].type === "listUnordered")
        if ($[ye][0] === "enter") de.push(ye);
        else {
          const $e = de.pop();
          ye = i($, $e, ye);
        }
    for (ye = -1; ++ye < $.length; ) {
      const $e = t[$[ye][0]];
      Ox.call($e, $[ye][1].type) &&
        $e[$[ye][1].type].call(Object.assign({ sliceSerialize: $[ye][2].sliceSerialize }, I), $[ye][1]);
    }
    if (I.tokenStack.length > 0) {
      const $e = I.tokenStack[I.tokenStack.length - 1];
      ($e[1] || Og).call(I, void 0, $e[0]);
    }
    for (
      j.position = {
        start: sr($.length > 0 ? $[0][1].start : { line: 1, column: 1, offset: 0 }),
        end: sr($.length > 0 ? $[$.length - 2][1].end : { line: 1, column: 1, offset: 0 }),
      },
        ye = -1;
      ++ye < t.transforms.length;

    )
      j = t.transforms[ye](j) || j;
    return j;
  }
  function i($, j, I) {
    let de = j - 1,
      ye = -1,
      $e = !1,
      Mn,
      On,
      co,
      fo;
    for (; ++de <= I; ) {
      const Ft = $[de];
      switch (Ft[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          Ft[0] === "enter" ? ye++ : ye--, (fo = void 0);
          break;
        }
        case "lineEndingBlank": {
          Ft[0] === "enter" && (Mn && !fo && !ye && !co && (co = de), (fo = void 0));
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          fo = void 0;
      }
      if (
        (!ye && Ft[0] === "enter" && Ft[1].type === "listItemPrefix") ||
        (ye === -1 && Ft[0] === "exit" && (Ft[1].type === "listUnordered" || Ft[1].type === "listOrdered"))
      ) {
        if (Mn) {
          let di = de;
          for (On = void 0; di--; ) {
            const Fn = $[di];
            if (Fn[1].type === "lineEnding" || Fn[1].type === "lineEndingBlank") {
              if (Fn[0] === "exit") continue;
              On && (($[On][1].type = "lineEndingBlank"), ($e = !0)), (Fn[1].type = "lineEnding"), (On = di);
            } else if (
              !(
                Fn[1].type === "linePrefix" ||
                Fn[1].type === "blockQuotePrefix" ||
                Fn[1].type === "blockQuotePrefixWhitespace" ||
                Fn[1].type === "blockQuoteMarker" ||
                Fn[1].type === "listItemIndent"
              )
            )
              break;
          }
          co && (!On || co < On) && (Mn._spread = !0),
            (Mn.end = Object.assign({}, On ? $[On][1].start : Ft[1].end)),
            $.splice(On || de, 0, ["exit", Mn, Ft[2]]),
            de++,
            I++;
        }
        if (Ft[1].type === "listItemPrefix") {
          const di = { type: "listItem", _spread: !1, start: Object.assign({}, Ft[1].start), end: void 0 };
          (Mn = di), $.splice(de, 0, ["enter", di, Ft[2]]), de++, I++, (co = void 0), (fo = !0);
        }
      }
    }
    return ($[j][1]._spread = $e), I;
  }
  function o($, j) {
    return I;
    function I(de) {
      l.call(this, $(de), de), j && j.call(this, de);
    }
  }
  function s() {
    this.stack.push({ type: "fragment", children: [] });
  }
  function l($, j, I) {
    this.stack[this.stack.length - 1].children.push($),
      this.stack.push($),
      this.tokenStack.push([j, I]),
      ($.position = { start: sr(j.start), end: void 0 });
  }
  function a($) {
    return j;
    function j(I) {
      $ && $.call(this, I), u.call(this, I);
    }
  }
  function u($, j) {
    const I = this.stack.pop(),
      de = this.tokenStack.pop();
    if (de) de[0].type !== $.type && (j ? j.call(this, $, de[0]) : (de[1] || Og).call(this, $, de[0]));
    else throw new Error("Cannot close `" + $.type + "` (" + Wn({ start: $.start, end: $.end }) + "): it’s not open");
    I.position.end = sr($.end);
  }
  function c() {
    return _f(this.stack.pop());
  }
  function d() {
    this.data.expectingFirstListItemValue = !0;
  }
  function f($) {
    if (this.data.expectingFirstListItemValue) {
      const j = this.stack[this.stack.length - 2];
      (j.start = Number.parseInt(this.sliceSerialize($), 10)), (this.data.expectingFirstListItemValue = void 0);
    }
  }
  function h() {
    const $ = this.resume(),
      j = this.stack[this.stack.length - 1];
    j.lang = $;
  }
  function p() {
    const $ = this.resume(),
      j = this.stack[this.stack.length - 1];
    j.meta = $;
  }
  function g() {
    this.data.flowCodeInside || (this.buffer(), (this.data.flowCodeInside = !0));
  }
  function x() {
    const $ = this.resume(),
      j = this.stack[this.stack.length - 1];
    (j.value = $.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "")), (this.data.flowCodeInside = void 0);
  }
  function b() {
    const $ = this.resume(),
      j = this.stack[this.stack.length - 1];
    j.value = $.replace(/(\r?\n|\r)$/g, "");
  }
  function m($) {
    const j = this.resume(),
      I = this.stack[this.stack.length - 1];
    (I.label = j), (I.identifier = _u(this.sliceSerialize($)).toLowerCase());
  }
  function v() {
    const $ = this.resume(),
      j = this.stack[this.stack.length - 1];
    j.title = $;
  }
  function _() {
    const $ = this.resume(),
      j = this.stack[this.stack.length - 1];
    j.url = $;
  }
  function k($) {
    const j = this.stack[this.stack.length - 1];
    if (!j.depth) {
      const I = this.sliceSerialize($).length;
      j.depth = I;
    }
  }
  function w() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function y($) {
    const j = this.stack[this.stack.length - 1];
    j.depth = this.sliceSerialize($).codePointAt(0) === 61 ? 1 : 2;
  }
  function S() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function T($) {
    const I = this.stack[this.stack.length - 1].children;
    let de = I[I.length - 1];
    (!de || de.type !== "text") && ((de = Re()), (de.position = { start: sr($.start), end: void 0 }), I.push(de)),
      this.stack.push(de);
  }
  function A($) {
    const j = this.stack.pop();
    (j.value += this.sliceSerialize($)), (j.position.end = sr($.end));
  }
  function F($) {
    const j = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const I = j.children[j.children.length - 1];
      (I.position.end = sr($.end)), (this.data.atHardBreak = void 0);
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(j.type) && (T.call(this, $), A.call(this, $));
  }
  function R() {
    this.data.atHardBreak = !0;
  }
  function V() {
    const $ = this.resume(),
      j = this.stack[this.stack.length - 1];
    j.value = $;
  }
  function B() {
    const $ = this.resume(),
      j = this.stack[this.stack.length - 1];
    j.value = $;
  }
  function N() {
    const $ = this.resume(),
      j = this.stack[this.stack.length - 1];
    j.value = $;
  }
  function G() {
    const $ = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const j = this.data.referenceType || "shortcut";
      ($.type += "Reference"), ($.referenceType = j), delete $.url, delete $.title;
    } else delete $.identifier, delete $.label;
    this.data.referenceType = void 0;
  }
  function U() {
    const $ = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const j = this.data.referenceType || "shortcut";
      ($.type += "Reference"), ($.referenceType = j), delete $.url, delete $.title;
    } else delete $.identifier, delete $.label;
    this.data.referenceType = void 0;
  }
  function X($) {
    const j = this.sliceSerialize($),
      I = this.stack[this.stack.length - 2];
    (I.label = yx(j)), (I.identifier = _u(j).toLowerCase());
  }
  function te() {
    const $ = this.stack[this.stack.length - 1],
      j = this.resume(),
      I = this.stack[this.stack.length - 1];
    if (((this.data.inReference = !0), I.type === "link")) {
      const de = $.children;
      I.children = de;
    } else I.alt = j;
  }
  function L() {
    const $ = this.resume(),
      j = this.stack[this.stack.length - 1];
    j.url = $;
  }
  function se() {
    const $ = this.resume(),
      j = this.stack[this.stack.length - 1];
    j.title = $;
  }
  function pe() {
    this.data.inReference = void 0;
  }
  function M() {
    this.data.referenceType = "collapsed";
  }
  function me($) {
    const j = this.resume(),
      I = this.stack[this.stack.length - 1];
    (I.label = j), (I.identifier = _u(this.sliceSerialize($)).toLowerCase()), (this.data.referenceType = "full");
  }
  function Ee($) {
    this.data.characterReferenceType = $.type;
  }
  function ce($) {
    const j = this.sliceSerialize($),
      I = this.data.characterReferenceType;
    let de;
    I
      ? ((de = QS(j, I === "characterReferenceMarkerNumeric" ? 10 : 16)), (this.data.characterReferenceType = void 0))
      : (de = $o(j));
    const ye = this.stack[this.stack.length - 1];
    ye.value += de;
  }
  function z($) {
    const j = this.stack.pop();
    j.position.end = sr($.end);
  }
  function W($) {
    A.call(this, $);
    const j = this.stack[this.stack.length - 1];
    j.url = this.sliceSerialize($);
  }
  function Y($) {
    A.call(this, $);
    const j = this.stack[this.stack.length - 1];
    j.url = "mailto:" + this.sliceSerialize($);
  }
  function Q() {
    return { type: "blockquote", children: [] };
  }
  function oe() {
    return { type: "code", lang: null, meta: null, value: "" };
  }
  function he() {
    return { type: "inlineCode", value: "" };
  }
  function ke() {
    return { type: "definition", identifier: "", label: null, title: null, url: "" };
  }
  function De() {
    return { type: "emphasis", children: [] };
  }
  function Xe() {
    return { type: "heading", depth: 0, children: [] };
  }
  function Qe() {
    return { type: "break" };
  }
  function rt() {
    return { type: "html", value: "" };
  }
  function gn() {
    return { type: "image", title: null, url: "", alt: null };
  }
  function st() {
    return { type: "link", title: null, url: "", children: [] };
  }
  function mn($) {
    return { type: "list", ordered: $.type === "listOrdered", start: null, spread: $._spread, children: [] };
  }
  function _t($) {
    return { type: "listItem", spread: $._spread, checked: null, children: [] };
  }
  function Ir() {
    return { type: "paragraph", children: [] };
  }
  function Zt() {
    return { type: "strong", children: [] };
  }
  function Re() {
    return { type: "text", value: "" };
  }
  function Ot() {
    return { type: "thematicBreak" };
  }
}
function sr(e) {
  return { line: e.line, column: e.column, offset: e.offset };
}
function Fx(e, t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? Fx(e, r) : n3(e, r);
  }
}
function n3(e, t) {
  let n;
  for (n in t)
    if (Ox.call(t, n))
      switch (n) {
        case "canContainEols": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "transforms": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = t[n];
          r && Object.assign(e[n], r);
          break;
        }
      }
}
function Og(e, t) {
  throw e
    ? new Error(
        "Cannot close `" +
          e.type +
          "` (" +
          Wn({ start: e.start, end: e.end }) +
          "): a different token (`" +
          t.type +
          "`, " +
          Wn({ start: t.start, end: t.end }) +
          ") is open",
      )
    : new Error(
        "Cannot close document, a token (`" + t.type + "`, " + Wn({ start: t.start, end: t.end }) + ") is still open",
      );
}
function xo(e) {
  return e.children instanceof Array;
}
class Fc extends Error {
  constructor(t, n) {
    super(t), (this.name = "MarkdownParseError"), (this.cause = n);
  }
}
class Rc extends Error {
  constructor(t) {
    super(t), (this.name = "UnrecognizedMarkdownConstructError");
  }
}
function r3(e) {
  const t = new Map();
  return e.type !== "root"
    ? { importDeclarations: {} }
    : (e.children
        .filter((r) => r.type === "mdxjsEsm")
        .filter((r) => r.value.startsWith("import "))
        .forEach((r) => {
          var i, o;
          (((o = (i = r.data) == null ? void 0 : i.estree) == null ? void 0 : o.body) ?? []).forEach((s) => {
            s.type === "ImportDeclaration" &&
              s.specifiers.forEach((l) => {
                t.set(l.local.name, {
                  source: `${s.source.value}`,
                  defaultExport: l.type === "ImportDefaultSpecifier",
                });
              });
          });
        }),
      { importDeclarations: Object.fromEntries(t.entries()) });
}
function i3({ root: e, markdown: t, visitors: n, syntaxExtensions: r, mdastExtensions: i, ...o }) {
  var s;
  let l;
  try {
    l = e3(t, { extensions: r, mdastExtensions: i });
  } catch (a) {
    throw a instanceof Error
      ? new Fc(`Error parsing markdown: ${a.message}`, a)
      : new Fc(`Error parsing markdown: ${a}`, a);
  }
  l.children.length === 0 && l.children.push({ type: "paragraph", children: [] }),
    ((s = l.children.at(-1)) == null ? void 0 : s.type) !== "paragraph" &&
      l.children.push({ type: "paragraph", children: [] }),
    Af({ root: e, mdastRoot: l, visitors: n, ...o });
}
function Af({ root: e, mdastRoot: t, visitors: n, ...r }) {
  const i = new WeakMap(),
    o = new WeakMap(),
    s = r3(t);
  n = n.sort((u, c) => (c.priority ?? 0) - (u.priority ?? 0));
  function l(u, c) {
    if (!xo(u)) throw new Error("Attempting to visit children of a non-parent");
    u.children.forEach((d) => {
      a(d, c, u);
    });
  }
  function a(u, c, d, f = null) {
    const h = n.find((p, g) =>
      f != null && f.has(g) ? !1 : typeof p.testNode == "string" ? p.testNode === u.type : p.testNode(u, r),
    );
    if (!h)
      try {
        throw new Rc(`Unsupported markdown syntax: ${Cx(u)}`);
      } catch {
        throw new Rc(
          `Parsing of the following markdown structure failed: ${JSON.stringify({
            type: u.type,
            name: "name" in u ? u.name : "N/A",
          })}`,
        );
      }
    h.visitNode({
      mdastNode: u,
      lexicalParent: c,
      mdastParent: d,
      descriptors: r,
      metaData: s,
      actions: {
        visitChildren: l,
        nextVisitor() {
          a(u, c, d, (f ?? new Set()).add(n.indexOf(h)));
        },
        addAndStepInto(p) {
          c.append(p), xo(u) && l(u, p);
        },
        addFormatting(p, g) {
          g || (xo(u) && (g = u)), g && i.set(g, p | (i.get(d) ?? 0));
        },
        removeFormatting(p, g) {
          g || (xo(u) && (g = u)), g && i.set(g, p ^ (i.get(d) ?? 0));
        },
        getParentFormatting() {
          return i.get(d) ?? 0;
        },
        addStyle(p, g) {
          g || (xo(u) && (g = u)), g && o.set(g, p);
        },
        getParentStyle() {
          return o.get(d) ?? "";
        },
      },
    });
  }
  a(t, e, null);
}
var o3 = Object.defineProperty,
  s3 = (e, t, n) => (t in e ? o3(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (e[t] = n)),
  wu = (e, t, n) => (s3(e, typeof t != "symbol" ? t + "" : t, n), n);
const Fg = "generic-html";
class xs extends dn {
  constructor(t, n, r, i) {
    super(i),
      wu(this, "__tag"),
      wu(this, "__nodeType"),
      wu(this, "__attributes"),
      (this.__tag = t),
      (this.__nodeType = n),
      (this.__attributes = r);
  }
  static getType() {
    return Fg;
  }
  static clone(t) {
    return new xs(t.__tag, t.__nodeType, t.__attributes, t.__key);
  }
  getTag() {
    return this.__tag;
  }
  getNodeType() {
    return this.__nodeType;
  }
  getAttributes() {
    return this.__attributes;
  }
  updateAttributes(t) {
    const n = this.getWritable();
    n.__attributes = t;
  }
  getStyle() {
    var t;
    return (t = this.__attributes.find((n) => n.name === "style")) == null ? void 0 : t.value;
  }
  createDOM() {
    const t = this.__tag,
      n = document.createElement(t);
    return (
      this.__attributes.forEach((r) => {
        n.setAttribute(r.name, r.value);
      }),
      n
    );
  }
  updateDOM() {
    return !1;
  }
  static importDOM() {
    return {};
  }
  exportDOM(t) {
    const { element: n } = super.exportDOM(t);
    return { element: n };
  }
  static importJSON(t) {
    const n = Rx(t.tag, t.mdxType, t.attributes);
    return n.setFormat(t.format), n.setIndent(t.indent), n.setDirection(t.direction), n;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      tag: this.getTag(),
      attributes: this.__attributes,
      mdxType: this.__nodeType,
      type: Fg,
      version: 1,
    };
  }
  extractWithChild() {
    return !0;
  }
  isInline() {
    return this.__nodeType === "mdxJsxTextElement";
  }
}
function Rx(e, t, n) {
  return Mt(new xs(e, t, n));
}
function l3(e) {
  return e instanceof xs;
}
const a3 = {
    testLexicalNode: l3,
    visitLexicalNode({ actions: e, lexicalNode: t }) {
      e.addAndStepInto("mdxJsxTextElement", { name: t.getTag(), type: t.getNodeType(), attributes: t.getAttributes() });
    },
    priority: -100,
  },
  u3 = {
    testLexicalNode: rn,
    visitLexicalNode: ({ mdastParent: e, actions: t }) => {
      t.appendToParent(e, {
        type: "text",
        value: `
`,
      });
    },
  },
  c3 = {
    testLexicalNode: nf,
    visitLexicalNode: ({ actions: e }) => {
      e.addAndStepInto("paragraph");
    },
  },
  d3 = {
    testLexicalNode: ut,
    visitLexicalNode: ({ actions: e }) => {
      e.addAndStepInto("root");
    },
  },
  No = 1,
  Lo = 2,
  Mo = 4,
  Oo = 8,
  Ea = 16,
  Fo = 32,
  Ro = 64;
function Rg(e) {
  return e.type === "text";
}
const f3 = ["u", "span", "sub", "sup"],
  h3 = {
    shouldJoin: (e, t) => {
      if (["text", "emphasis", "strong"].includes(e.type)) return e.type === t.type;
      if (e.type === "mdxJsxTextElement" && t.type === "mdxJsxTextElement" && f3.includes(t.name)) {
        const n = t;
        return e.name === n.name && JSON.stringify(e.attributes) === JSON.stringify(n.attributes);
      }
      return !1;
    },
    join(e, t) {
      return Rg(e) && Rg(t)
        ? { type: "text", value: e.value + t.value }
        : { ...e, children: [...e.children, ...t.children] };
    },
    testLexicalNode: Z,
    visitLexicalNode: ({ lexicalNode: e, mdastParent: t, actions: n }) => {
      const r = e.getPreviousSibling(),
        i = Z(r) ? r.getFormat() : 0,
        o = e.getTextContent(),
        s = e.getFormat(),
        l = e.getStyle();
      let a = t;
      if (
        (l &&
          (a = n.appendToParent(a, {
            type: "mdxJsxTextElement",
            name: "span",
            children: [],
            attributes: [{ type: "mdxJsxAttribute", name: "style", value: l }],
          })),
        i & s & Oo && (a = n.appendToParent(a, { type: "mdxJsxTextElement", name: "u", children: [], attributes: [] })),
        i & s & Ro &&
          (a = n.appendToParent(a, { type: "mdxJsxTextElement", name: "sup", children: [], attributes: [] })),
        i & s & Fo &&
          (a = n.appendToParent(a, { type: "mdxJsxTextElement", name: "sub", children: [], attributes: [] })),
        i & s & Lo && (a = n.appendToParent(a, { type: "emphasis", children: [] })),
        i & s & No && (a = n.appendToParent(a, { type: "strong", children: [] })),
        i & s & Mo && (a = n.appendToParent(a, { type: "delete", children: [] })),
        s & Oo &&
          !(i & Oo) &&
          (a = n.appendToParent(a, { type: "mdxJsxTextElement", name: "u", children: [], attributes: [] })),
        s & Ro &&
          !(i & Ro) &&
          (a = n.appendToParent(a, { type: "mdxJsxTextElement", name: "sup", children: [], attributes: [] })),
        s & Fo &&
          !(i & Fo) &&
          (a = n.appendToParent(a, { type: "mdxJsxTextElement", name: "sub", children: [], attributes: [] })),
        s & Lo && !(i & Lo) && (a = n.appendToParent(a, { type: "emphasis", children: [] })),
        s & No && !(i & No) && (a = n.appendToParent(a, { type: "strong", children: [] })),
        s & Mo && !(i & Mo) && (a = n.appendToParent(a, { type: "delete", children: [] })),
        s & Ea)
      ) {
        n.appendToParent(a, { type: "inlineCode", value: o });
        return;
      }
      n.appendToParent(a, { type: "text", value: o });
    },
  },
  p3 = {
    testNode: "break",
    visitNode: function ({ lexicalParent: e }) {
      e.append(sn());
    },
  };
function Bs(e, t) {
  return [
    {
      testNode: (n) => n.type === "mdxJsxTextElement" && n.name === e,
      visitNode({ actions: n, mdastNode: r, lexicalParent: i }) {
        n.addFormatting(t), n.visitChildren(r, i);
      },
    },
    {
      testNode: (n) => n.type === "html" && n.value === `<${e}>`,
      visitNode({ actions: n, mdastParent: r }) {
        n.addFormatting(t, r);
      },
    },
    {
      testNode: (n) => n.type === "html" && n.value === `</${e}>`,
      visitNode({ actions: n, mdastParent: r }) {
        n.removeFormatting(t, r);
      },
    },
  ];
}
const g3 = {
    testNode: "delete",
    visitNode({ mdastNode: e, actions: t, lexicalParent: n }) {
      t.addFormatting(Mo), t.visitChildren(e, n);
    },
  },
  m3 = {
    testNode: "inlineCode",
    visitNode({ mdastNode: e, actions: t }) {
      t.addAndStepInto(Be(e.value).setFormat(t.getParentFormatting() | Ea));
    },
  },
  x3 = {
    testNode: "emphasis",
    visitNode({ mdastNode: e, actions: t, lexicalParent: n }) {
      t.addFormatting(Lo), t.visitChildren(e, n);
    },
  },
  v3 = {
    testNode: "strong",
    visitNode({ mdastNode: e, actions: t, lexicalParent: n }) {
      t.addFormatting(No), t.visitChildren(e, n);
    },
  },
  b3 = [x3, v3, ...Bs("u", Oo), ...Bs("code", Ea), m3, g3, ...Bs("sup", Ro), ...Bs("sub", Fo)],
  y3 = {
    testNode: _x,
    visitNode: function ({ mdastNode: e, actions: t, lexicalParent: n }) {
      e.name === "span" &&
      e.attributes.length === 1 &&
      e.attributes[0].type === "mdxJsxAttribute" &&
      e.attributes[0].name === "style"
        ? (t.addStyle(e.attributes[0].value, e), t.visitChildren(e, n))
        : t.addAndStepInto(Rx(e.name, e.type, e.attributes));
    },
    priority: -100,
  },
  C3 = ["listitem", "quote", "admonition"],
  _3 = {
    testNode: "paragraph",
    visitNode: function ({ mdastNode: e, lexicalParent: t, actions: n }) {
      C3.includes(t.getType()) ? n.visitChildren(e, t) : n.addAndStepInto(Se());
    },
  },
  w3 = {
    testNode: "root",
    visitNode({ actions: e, mdastNode: t, lexicalParent: n }) {
      e.visitChildren(t, n);
    },
  },
  E3 = {
    testNode: "text",
    visitNode({ mdastNode: e, actions: t }) {
      const n = Be(e.value);
      n.setFormat(t.getParentFormatting());
      const r = t.getParentStyle();
      r !== "" && n.setStyle(r), t.addAndStepInto(n);
    },
  },
  Px = () => C.createElement(W0, { externalHistoryState: qe(Z3) }),
  Yt = {
    carriageReturn: -5,
    lineFeed: -4,
    carriageReturnLineFeed: -3,
    horizontalTab: -2,
    virtualSpace: -1,
    eof: null,
    nul: 0,
    soh: 1,
    stx: 2,
    etx: 3,
    eot: 4,
    enq: 5,
    ack: 6,
    bel: 7,
    bs: 8,
    ht: 9,
    lf: 10,
    vt: 11,
    ff: 12,
    cr: 13,
    so: 14,
    si: 15,
    dle: 16,
    dc1: 17,
    dc2: 18,
    dc3: 19,
    dc4: 20,
    nak: 21,
    syn: 22,
    etb: 23,
    can: 24,
    em: 25,
    sub: 26,
    esc: 27,
    fs: 28,
    gs: 29,
    rs: 30,
    us: 31,
    space: 32,
    exclamationMark: 33,
    quotationMark: 34,
    numberSign: 35,
    dollarSign: 36,
    percentSign: 37,
    ampersand: 38,
    apostrophe: 39,
    leftParenthesis: 40,
    rightParenthesis: 41,
    asterisk: 42,
    plusSign: 43,
    comma: 44,
    dash: 45,
    dot: 46,
    slash: 47,
    digit0: 48,
    digit1: 49,
    digit2: 50,
    digit3: 51,
    digit4: 52,
    digit5: 53,
    digit6: 54,
    digit7: 55,
    digit8: 56,
    digit9: 57,
    colon: 58,
    semicolon: 59,
    lessThan: 60,
    equalsTo: 61,
    greaterThan: 62,
    questionMark: 63,
    atSign: 64,
    uppercaseA: 65,
    uppercaseB: 66,
    uppercaseC: 67,
    uppercaseD: 68,
    uppercaseE: 69,
    uppercaseF: 70,
    uppercaseG: 71,
    uppercaseH: 72,
    uppercaseI: 73,
    uppercaseJ: 74,
    uppercaseK: 75,
    uppercaseL: 76,
    uppercaseM: 77,
    uppercaseN: 78,
    uppercaseO: 79,
    uppercaseP: 80,
    uppercaseQ: 81,
    uppercaseR: 82,
    uppercaseS: 83,
    uppercaseT: 84,
    uppercaseU: 85,
    uppercaseV: 86,
    uppercaseW: 87,
    uppercaseX: 88,
    uppercaseY: 89,
    uppercaseZ: 90,
    leftSquareBracket: 91,
    backslash: 92,
    rightSquareBracket: 93,
    caret: 94,
    underscore: 95,
    graveAccent: 96,
    lowercaseA: 97,
    lowercaseB: 98,
    lowercaseC: 99,
    lowercaseD: 100,
    lowercaseE: 101,
    lowercaseF: 102,
    lowercaseG: 103,
    lowercaseH: 104,
    lowercaseI: 105,
    lowercaseJ: 106,
    lowercaseK: 107,
    lowercaseL: 108,
    lowercaseM: 109,
    lowercaseN: 110,
    lowercaseO: 111,
    lowercaseP: 112,
    lowercaseQ: 113,
    lowercaseR: 114,
    lowercaseS: 115,
    lowercaseT: 116,
    lowercaseU: 117,
    lowercaseV: 118,
    lowercaseW: 119,
    lowercaseX: 120,
    lowercaseY: 121,
    lowercaseZ: 122,
    leftCurlyBrace: 123,
    verticalBar: 124,
    rightCurlyBrace: 125,
    tilde: 126,
    del: 127,
    byteOrderMarker: 65279,
    replacementCharacter: 65533,
  },
  Mr = {
    data: "data",
    whitespace: "whitespace",
    lineEnding: "lineEnding",
    lineEndingBlank: "lineEndingBlank",
    linePrefix: "linePrefix",
    lineSuffix: "lineSuffix",
    atxHeading: "atxHeading",
    atxHeadingSequence: "atxHeadingSequence",
    atxHeadingText: "atxHeadingText",
    autolink: "autolink",
    autolinkEmail: "autolinkEmail",
    autolinkMarker: "autolinkMarker",
    autolinkProtocol: "autolinkProtocol",
    characterEscape: "characterEscape",
    characterEscapeValue: "characterEscapeValue",
    characterReference: "characterReference",
    characterReferenceMarker: "characterReferenceMarker",
    characterReferenceMarkerNumeric: "characterReferenceMarkerNumeric",
    characterReferenceMarkerHexadecimal: "characterReferenceMarkerHexadecimal",
    characterReferenceValue: "characterReferenceValue",
    codeFenced: "codeFenced",
    codeFencedFence: "codeFencedFence",
    codeFencedFenceSequence: "codeFencedFenceSequence",
    codeFencedFenceInfo: "codeFencedFenceInfo",
    codeFencedFenceMeta: "codeFencedFenceMeta",
    codeFlowValue: "codeFlowValue",
    codeIndented: "codeIndented",
    codeText: "codeText",
    codeTextData: "codeTextData",
    codeTextPadding: "codeTextPadding",
    codeTextSequence: "codeTextSequence",
    content: "content",
    definition: "definition",
    definitionDestination: "definitionDestination",
    definitionDestinationLiteral: "definitionDestinationLiteral",
    definitionDestinationLiteralMarker: "definitionDestinationLiteralMarker",
    definitionDestinationRaw: "definitionDestinationRaw",
    definitionDestinationString: "definitionDestinationString",
    definitionLabel: "definitionLabel",
    definitionLabelMarker: "definitionLabelMarker",
    definitionLabelString: "definitionLabelString",
    definitionMarker: "definitionMarker",
    definitionTitle: "definitionTitle",
    definitionTitleMarker: "definitionTitleMarker",
    definitionTitleString: "definitionTitleString",
    emphasis: "emphasis",
    emphasisSequence: "emphasisSequence",
    emphasisText: "emphasisText",
    escapeMarker: "escapeMarker",
    hardBreakEscape: "hardBreakEscape",
    hardBreakTrailing: "hardBreakTrailing",
    htmlFlow: "htmlFlow",
    htmlFlowData: "htmlFlowData",
    htmlText: "htmlText",
    htmlTextData: "htmlTextData",
    image: "image",
    label: "label",
    labelText: "labelText",
    labelLink: "labelLink",
    labelImage: "labelImage",
    labelMarker: "labelMarker",
    labelImageMarker: "labelImageMarker",
    labelEnd: "labelEnd",
    link: "link",
    paragraph: "paragraph",
    reference: "reference",
    referenceMarker: "referenceMarker",
    referenceString: "referenceString",
    resource: "resource",
    resourceDestination: "resourceDestination",
    resourceDestinationLiteral: "resourceDestinationLiteral",
    resourceDestinationLiteralMarker: "resourceDestinationLiteralMarker",
    resourceDestinationRaw: "resourceDestinationRaw",
    resourceDestinationString: "resourceDestinationString",
    resourceMarker: "resourceMarker",
    resourceTitle: "resourceTitle",
    resourceTitleMarker: "resourceTitleMarker",
    resourceTitleString: "resourceTitleString",
    setextHeading: "setextHeading",
    setextHeadingText: "setextHeadingText",
    setextHeadingLine: "setextHeadingLine",
    setextHeadingLineSequence: "setextHeadingLineSequence",
    strong: "strong",
    strongSequence: "strongSequence",
    strongText: "strongText",
    thematicBreak: "thematicBreak",
    thematicBreakSequence: "thematicBreakSequence",
    blockQuote: "blockQuote",
    blockQuotePrefix: "blockQuotePrefix",
    blockQuoteMarker: "blockQuoteMarker",
    blockQuotePrefixWhitespace: "blockQuotePrefixWhitespace",
    listOrdered: "listOrdered",
    listUnordered: "listUnordered",
    listItemIndent: "listItemIndent",
    listItemMarker: "listItemMarker",
    listItemPrefix: "listItemPrefix",
    listItemPrefixWhitespace: "listItemPrefixWhitespace",
    listItemValue: "listItemValue",
    chunkDocument: "chunkDocument",
    chunkContent: "chunkContent",
    chunkFlow: "chunkFlow",
    chunkText: "chunkText",
    chunkString: "chunkString",
  };
function k3(e) {
  return {
    canContainEols: ["comment"],
    enter: {
      comment(t) {
        this.buffer();
      },
    },
    exit: {
      comment(t) {
        this.resume();
      },
    },
  };
}
const Pg = (e, t, n) => {
    return r;
    function r(p) {
      return e.enter("comment"), e.consume(p), i;
    }
    function i(p) {
      return p === Yt.exclamationMark ? (e.consume(p), o) : n(p);
    }
    function o(p) {
      return p === Yt.dash ? (e.consume(p), s) : n(p);
    }
    function s(p) {
      return p === Yt.dash ? (e.consume(p), l) : n(p);
    }
    function l(p) {
      return p === Yt.greaterThan ? n(p) : ee(p) ? c(p) : (e.enter(Mr.data), p === Yt.dash ? (e.consume(p), a) : u(p));
    }
    function a(p) {
      return p === Yt.greaterThan ? n(p) : u(p);
    }
    function u(p) {
      return p === Yt.eof
        ? n(p)
        : p === Yt.dash
          ? (e.consume(p), f)
          : ee(p)
            ? (e.exit(Mr.data), c(p))
            : (e.consume(p), u);
    }
    function c(p) {
      return e.enter(Mr.lineEnding), e.consume(p), e.exit(Mr.lineEnding), ve(e, d, Mr.linePrefix);
    }
    function d(p) {
      return ee(p) ? c(p) : (e.enter(Mr.data), u(p));
    }
    function f(p) {
      return p === Yt.dash ? (e.consume(p), h) : u(p);
    }
    function h(p) {
      return p === Yt.greaterThan
        ? (e.exit(Mr.data), e.enter("commentEnd"), e.consume(p), e.exit("commentEnd"), e.exit("comment"), t(p))
        : p === Yt.dash
          ? (e.consume(p), h)
          : u(p);
    }
  },
  S3 = { flow: { 60: { tokenize: Pg, concrete: !0 } }, text: { 60: { tokenize: Pg } } },
  T3 = "_bold_1tncs_10",
  A3 = "_italic_1tncs_14",
  I3 = "_underline_1tncs_18",
  N3 = "_strikethrough_1tncs_34",
  L3 = "_underlineStrikethrough_1tncs_38",
  M3 = "_subscript_1tncs_42",
  O3 = "_superscript_1tncs_47",
  F3 = "_code_1tncs_52",
  R3 = "_nestedListItem_1tncs_59",
  P3 = "_listitem_1tncs_69",
  D3 = "_listItemChecked_1tncs_73",
  $3 = "_listItemUnchecked_1tncs_74",
  B3 = "_admonitionDanger_1tncs_151",
  H3 = "_admonitionInfo_1tncs_152",
  V3 = "_admonitionNote_1tncs_153",
  z3 = "_admonitionTip_1tncs_154",
  j3 = "_admonitionCaution_1tncs_155",
  U3 = "_mdxExpression_1tncs_188",
  dt = {
    bold: T3,
    italic: A3,
    underline: I3,
    strikethrough: N3,
    underlineStrikethrough: L3,
    subscript: M3,
    superscript: O3,
    code: F3,
    nestedListItem: R3,
    listitem: P3,
    listItemChecked: D3,
    listItemUnchecked: $3,
    admonitionDanger: B3,
    admonitionInfo: H3,
    admonitionNote: V3,
    admonitionTip: z3,
    admonitionCaution: j3,
    mdxExpression: U3,
  },
  ka = {
    text: {
      bold: dt.bold,
      italic: dt.italic,
      underline: dt.underline,
      code: dt.code,
      strikethrough: dt.strikethrough,
      subscript: dt.subscript,
      superscript: dt.superscript,
      underlineStrikethrough: dt.underlineStrikethrough,
    },
    list: {
      listitem: dt.listitem,
      listitemChecked: dt.listItemChecked,
      listitemUnchecked: dt.listItemUnchecked,
      nested: { listitem: dt.nestedListItem },
    },
    admonition: {
      danger: dt.admonitionDanger,
      info: dt.admonitionInfo,
      note: dt.admonitionNote,
      tip: dt.admonitionTip,
      caution: dt.admonitionCaution,
    },
  },
  Qr = ae("NESTED_EDITOR_UPDATED_COMMAND"),
  Ht = ne(null),
  je = ne(null),
  Pc = ne(""),
  Dc = ne(!0),
  ct = ne(!1, (e) => {
    e.sub(e.pipe(ct, Ve(Ht)), ([t, n]) => {
      n == null || n.setEditable(!t);
    });
  }),
  $c = ne(""),
  Dg = ne(!1),
  Jo = ne(!1),
  If = ne(0),
  Go = ne(null),
  Bc = Ze((e) => {
    e.link(
      e.pipe(
        Go,
        is((t) => t !== null),
      ),
      Bc,
    );
  }),
  Nf = Ze((e) => {
    e.sub(e.pipe(Nf, Ve(je)), ([t, n]) => {
      n == null || n.dispatchCommand(Un, t);
    });
  }),
  $i = ne(null, (e) => {
    e.sub(e.pipe($i, Ve(je)), ([t, n]) => {
      if (!t || !n) return;
      const r = t.anchor.getNode();
      let i =
        r.getKey() === "root"
          ? r
          : on(r, (l) => {
              const a = l.getParent();
              return a !== null && tt(a);
            });
      i === null && (i = r.getTopLevelElementOrThrow());
      const o = i.getKey();
      if (n.getElementByKey(o) !== null) {
        const l = ba(i) ? i.getTag() : i.getType();
        e.pub(Xx, l);
      }
    });
  }),
  Dx = ne(""),
  In = ne(""),
  Il = ne(!1),
  Sa = Ze((e) => {
    e.link(In, Sa),
      e.sub(Dx, (t) => {
        e.pubIn({ [Il]: !0, [In]: t });
      });
  }),
  Hc = Ze((e) => {
    e.link(
      e.pipe(
        Sa,
        Ve(zc),
        is(([, t]) => !t),
        tn(([t]) => t),
      ),
      Hc,
    );
  }),
  Ta = ne([]),
  Aa = ne([]),
  $x = ne([]),
  Bx = ne([]),
  Ia = ne([]),
  Hx = ne([]),
  Vc = ne({}),
  Lf = ne(!1),
  Na = ne([]),
  Bi = ne([]),
  no = ne([]),
  wr = ne(null),
  W3 = ne(null),
  fn = At(Aa),
  Gt = At(Ta),
  Hi = At($x),
  Vi = At(Bx),
  hn = At(Ia),
  vs = At(Hx),
  zc = ne(!1),
  Mf = Ze((e) => {
    e.sub(
      e.pipe(
        Mf,
        Ve(In, Ht, Jo),
        is(([t, n]) => t.trim() !== n.trim()),
      ),
      ([t, , n, r]) => {
        e.pub(zc, !0),
          n == null ||
            n.update(
              () => {
                Ce().clear(), Of(e, Ce(), t), r ? n.focus() : Ye(null);
              },
              {
                onUpdate: () => {
                  e.pub(zc, !1);
                },
              },
            );
      },
    );
  }),
  Vx = Ze((e) => {
    e.sub(e.pipe(Vx, Ve(je, Jo)), ([t, n, r]) => {
      n == null ||
        n.update(() => {
          const i = J();
          if (i !== null) {
            const o = {
              children: [],
              append(s) {
                this.children.push(s);
              },
              getType() {
                return i.getNodes()[0].getType();
              },
            };
            Of(e, o, t), Yi(o.children);
          }
          r ? n.focus() : Ye(null);
        });
    });
  });
function zx() {
  return N1(
    (e, [t, n]) => (
      e.forEach((r) => {
        if (!r) throw new Error("You have a subscription that does not return a teardown");
        r();
      }),
      n ? t.map((r) => r(n)) : []
    ),
    [],
  );
}
const jx = ne([], (e) => {
    e.pipe(e.combine(jx, je), zx());
  }),
  Ux = ne([], (e) => {
    e.pipe(e.combine(Ux, Ht), zx());
  }),
  li = ne(null),
  Zo = Ze(),
  Ke = ne((e) => {
    throw new Error(`No icon component for ${e}`);
  });
function At(e, t) {
  return Ze((n, r) => {
    n.changeWith(e, r, (i, o) => {
      Array.isArray(o) || (o = [o]);
      let s = i;
      for (const l of o) i.includes(l) || (s = [...s, l]);
      return s;
    }),
      t == null || t(n, r);
  });
}
function Wx(e) {
  const t = J();
  H(t) && e.pubIn({ [$i]: t, [If]: t.format });
}
const La = At(Ux, (e, t) => {
    e.pub(t, [
      (n) =>
        n.registerCommand(
          os,
          (r, i) => (
            e.pubIn({ [je]: i, [Jo]: !0 }),
            i._parentEditor === null &&
              i.getEditorState().read(() => {
                e.pub(li, { rootNode: Ce(), editorType: "lexical" });
              }),
            Wx(e),
            !1
          ),
          Bt,
        ),
      (n) =>
        n.registerUpdateListener(({ dirtyElements: r, dirtyLeaves: i, editorState: o }) => {
          if (e.getValue(Go) !== null || (r.size === 0 && i.size === 0)) return;
          let l;
          o.read(() => {
            Ce().getLastChild() instanceof Cr &&
              n.update(
                () => {
                  Ce().append(Se());
                },
                { discrete: !0 },
              ),
              (l = r9({
                root: Ce(),
                visitors: e.getValue(Ia),
                jsxComponentDescriptors: e.getValue(Na),
                toMarkdownExtensions: e.getValue(Hx),
                toMarkdownOptions: e.getValue(Vc),
                jsxIsAvailable: e.getValue(Lf),
              }));
          }),
            e.pub(In, l.trim()),
            e.pub(Il, !1);
        }),
      (n) => n.registerCommand(sa, () => (e.pub(Jo, !0), !1), Bt),
    ]);
  }),
  qo = At(jx, (e, t) => {
    e.pub(t, [
      (n) =>
        n.registerUpdateListener(({ editorState: r }) => {
          r.read(() => {
            Wx(e);
          });
        }),
      (n) =>
        n.registerCommand(
          la,
          (r) => {
            var i;
            const o = e.getValue(Ht);
            return (
              o && !((i = o.getRootElement()) != null && i.contains(r.relatedTarget)) && e.pubIn({ [Jo]: !1, [Zo]: r }),
              !1
            );
          },
          Bt,
        ),
    ]);
  });
function Of(e, t, n) {
  try {
    i3({
      root: t,
      visitors: e.getValue(Ta),
      mdastExtensions: e.getValue(Bx),
      markdown: n,
      syntaxExtensions: e.getValue($x),
      jsxComponentDescriptors: e.getValue(Na),
      directiveDescriptors: e.getValue(Bi),
      codeBlockEditorDescriptors: e.getValue(no),
    }),
      e.pub(Go, null);
  } catch (r) {
    if (r instanceof Fc || r instanceof Rc) e.pubIn({ [In]: n, [Go]: { error: r.message, source: n } });
    else throw r;
  }
}
const Kx = ne([]),
  ai = At(Kx),
  Jx = ne([]),
  K3 = At(Jx),
  Gx = ne([]),
  J3 = At(Gx),
  Zx = ne([]),
  G3 = At(Zx),
  qx = ne([]),
  Yx = At(qx),
  Z3 = ne(U0()),
  Xx = ne("");
Ze();
const Nl = Ze((e) => {
    e.sub(e.pipe(Nl, Ve(je)), ([t, n]) => {
      n == null ||
        n.update(() => {
          const r = J();
          H(r) &&
            (cw(r, t),
            setTimeout(() => {
              n.focus();
            }));
        });
    });
  }),
  Ma = Ze((e) => {
    e.sub(e.pipe(Ma, Ve(je)), ([t, n]) => {
      n == null ||
        n.focus(
          () => {
            n.getEditorState().read(() => {
              const r = J();
              H(r) &&
                (n.update(() => {
                  const i = t();
                  i.isInline() ? (Yi([i]), tt(i.getParentOrThrow()) && bf(i, Se).selectEnd()) : j0(i),
                    setTimeout(() => {
                      "select" in i && typeof i.select == "function" && i.select();
                    });
                }),
                setTimeout(() => {
                  n.dispatchCommand(Qr, void 0);
                }));
            });
          },
          { defaultSelection: "rootEnd" },
        );
    });
  }),
  mr = ne("rich-text", (e) => {
    function t() {
      return N1((n, r) => ({ current: n.next, next: r }), { current: "rich-text", next: "rich-text" });
    }
    e.sub(e.pipe(mr, t(), Ve(zi)), ([{ current: n }, r]) => {
      (n === "source" || n === "diff") && e.pub(Mf, r);
    }),
      e.sub(
        e.pipe(
          mr,
          t(),
          is((n) => n.current === "rich-text"),
          Ve(je),
        ),
        ([, n]) => {
          n == null || n.dispatchCommand(Qr, void 0);
        },
      );
  }),
  zi = ne("", (e) => {
    e.link(In, zi), e.link(zi, Sa);
  }),
  Ff = ne([]),
  ro = At(Ff),
  Qx = ne(() => {
    throw new Error("No translation function provided");
  }),
  Ll = ne(ka),
  q3 = vt({
    init(e, t) {
      const n = (t == null ? void 0 : t.initialMarkdown) ?? "";
      e.register(La),
        e.register(qo),
        e.register(Sa),
        e.pubIn({
          [Dx]: t != null && t.trim ? n.trim() : n,
          [Ke]: t == null ? void 0 : t.iconComponentFor,
          [Gt]: [w3, _3, E3, p3, ...b3],
          [fn]: [Xi, Ln, xs],
          [hn]: [d3, c3, h3, u3, a3],
          [ai]: Px,
          [Pc]: t == null ? void 0 : t.contentEditableClassName,
          [Dc]: t == null ? void 0 : t.spellCheck,
          [Vc]: t == null ? void 0 : t.toMarkdownOptions,
          [Dg]: t == null ? void 0 : t.autoFocus,
          [$c]: t == null ? void 0 : t.placeholder,
          [ct]: t == null ? void 0 : t.readOnly,
          [Qx]: t == null ? void 0 : t.translation,
          [Vi]: qw(),
          [Hi]: Gw(),
          [vs]: [mE(), Yw()],
          [Ll]: (t == null ? void 0 : t.lexicalTheme) ?? ka,
        }),
        e.singletonSub(Bc, t == null ? void 0 : t.onError),
        e.singletonSub(Hc, (r) => {
          t == null || t.onChange(r, e.getValue(Il));
        }),
        e.singletonSub(Zo, t == null ? void 0 : t.onBlur),
        (t != null && t.suppressHtmlProcessing) || e.pubIn({ [Vi]: [gE(), k3()], [Hi]: [BE(), HE(), S3], [Gt]: y3 });
    },
    postInit(e, t) {
      const n = rf({
        editable: (t == null ? void 0 : t.readOnly) !== !0,
        namespace: "MDXEditor",
        nodes: e.getValue(Aa),
        onError: (r) => {
          throw r;
        },
        theme: e.getValue(Ll),
      });
      n.update(() => {
        const r = (t == null ? void 0 : t.initialMarkdown.trim()) ?? "";
        Of(e, Ce(), r);
        const i = t == null ? void 0 : t.autoFocus;
        if (i) {
          if (i === !0) {
            setTimeout(() => {
              n.focus(Pr, { defaultSelection: "rootStart" });
            });
            return;
          }
          setTimeout(() => {
            n.focus(Pr, { defaultSelection: i.defaultSelection ?? "rootStart" });
          });
        }
      }),
        e.pub(Ht, n),
        e.pub(je, n);
    },
    update(e, t) {
      e.pubIn({
        [Pc]: t == null ? void 0 : t.contentEditableClassName,
        [Dc]: t == null ? void 0 : t.spellCheck,
        [Vc]: t == null ? void 0 : t.toMarkdownOptions,
        [Dg]: t == null ? void 0 : t.autoFocus,
        [$c]: t == null ? void 0 : t.placeholder,
        [ct]: t == null ? void 0 : t.readOnly,
      }),
        e.singletonSub(Hc, (n) => {
          t == null || t.onChange(n, e.getValue(Il));
        }),
        e.singletonSub(Zo, t == null ? void 0 : t.onBlur),
        e.singletonSub(Bc, t == null ? void 0 : t.onError);
    },
  });
function Fe() {
  return qe(Qx);
}
function Y3() {
  return Ce().getTextContent();
}
function X3(e, t = !0) {
  if (e) return !1;
  let n = Y3();
  return t && (n = n.trim()), n === "";
}
function Q3(e) {
  if (!X3(e, !1)) return !1;
  const t = Ce().getChildren(),
    n = t.length;
  if (n > 1) return !1;
  for (let r = 0; r < n; r++) {
    const i = t[r];
    if (Te(i)) return !1;
    if (P(i)) {
      if (!nf(i) || i.__indent !== 0) return !1;
      const o = i.getChildren(),
        s = o.length;
      for (let l = 0; l < s; l++) {
        const a = o[r];
        if (!Z(a)) return !1;
      }
    }
  }
  return !0;
}
function ev(e) {
  return () => Q3(e);
}
const tv =
  typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0
    ? E.useLayoutEffect
    : E.useEffect;
function eT(
  {
    editor: e,
    ariaActiveDescendant: t,
    ariaAutoComplete: n,
    ariaControls: r,
    ariaDescribedBy: i,
    ariaErrorMessage: o,
    ariaExpanded: s,
    ariaInvalid: l,
    ariaLabel: a,
    ariaLabelledBy: u,
    ariaMultiline: c,
    ariaOwns: d,
    ariaRequired: f,
    autoCapitalize: h,
    className: p,
    id: g,
    role: x = "textbox",
    spellCheck: b = !0,
    style: m,
    tabIndex: v,
    "data-testid": _,
    ...k
  },
  w,
) {
  const [y, S] = E.useState(e.isEditable()),
    T = E.useCallback(
      (F) => {
        F && F.ownerDocument && F.ownerDocument.defaultView ? e.setRootElement(F) : e.setRootElement(null);
      },
      [e],
    ),
    A = E.useMemo(
      () =>
        (function (...F) {
          return (R) => {
            F.forEach((V) => {
              typeof V == "function" ? V(R) : V != null && (V.current = R);
            });
          };
        })(w, T),
      [T, w],
    );
  return (
    tv(
      () => (
        S(e.isEditable()),
        e.registerEditableListener((F) => {
          S(F);
        })
      ),
      [e],
    ),
    O.jsx("div", {
      "aria-activedescendant": y ? t : void 0,
      "aria-autocomplete": y ? n : "none",
      "aria-controls": y ? r : void 0,
      "aria-describedby": i,
      ...(o != null ? { "aria-errormessage": o } : {}),
      "aria-expanded": y && x === "combobox" ? !!s : void 0,
      ...(l != null ? { "aria-invalid": l } : {}),
      "aria-label": a,
      "aria-labelledby": u,
      "aria-multiline": c,
      "aria-owns": y ? d : void 0,
      "aria-readonly": !y || void 0,
      "aria-required": f,
      autoCapitalize: h,
      className: p,
      contentEditable: y,
      "data-testid": _,
      id: g,
      ref: A,
      role: y ? x : void 0,
      spellCheck: b,
      style: m,
      tabIndex: v,
      ...k,
    })
  );
}
const tT = E.forwardRef(eT);
function $g(e) {
  return e.getEditorState().read(ev(e.isComposing()));
}
const Rf = E.forwardRef(nT);
function nT(e, t) {
  const { placeholder: n, ...r } = e,
    [i] = bt();
  return O.jsxs(O.Fragment, {
    children: [O.jsx(tT, { editor: i, ...r, ref: t }), n != null && O.jsx(rT, { editor: i, content: n })],
  });
}
function rT({ content: e, editor: t }) {
  const n = (function (s) {
      const [l, a] = E.useState(() => $g(s));
      return (
        tv(() => {
          function u() {
            const c = $g(s);
            a(c);
          }
          return (
            u(),
            yt(
              s.registerUpdateListener(() => {
                u();
              }),
              s.registerEditableListener(() => {
                u();
              }),
            )
          );
        }, [s]),
        l
      );
    })(t),
    [r, i] = E.useState(t.isEditable());
  if (
    (E.useLayoutEffect(
      () => (
        i(t.isEditable()),
        t.registerEditableListener((s) => {
          i(s);
        })
      ),
      [t],
    ),
    !n)
  )
    return null;
  let o = null;
  return (
    typeof e == "function" ? (o = e(r)) : e !== null && (o = e),
    o === null ? null : O.jsx("div", { "aria-hidden": !0, children: o })
  );
}
const iT =
  typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0
    ? E.useLayoutEffect
    : E.useEffect;
function oT(e) {
  return { initialValueFn: () => e.isEditable(), subscribe: (t) => e.registerEditableListener(t) };
}
function sT() {
  return (function (e) {
    const [t] = bt(),
      n = E.useMemo(() => e(t), [t, e]),
      [r, i] = E.useState(() => n.initialValueFn()),
      o = E.useRef(r);
    return (
      iT(() => {
        const { initialValueFn: s, subscribe: l } = n,
          a = s();
        return (
          o.current !== a && ((o.current = a), i(a)),
          l((u) => {
            (o.current = u), i(u);
          })
        );
      }, [n, e]),
      r
    );
  })(oT);
}
function lT(e) {
  const t = window.location.origin,
    n = (r) => {
      if (r.origin !== t) return;
      const i = e.getRootElement();
      if (document.activeElement !== i) return;
      const o = r.data;
      if (typeof o == "string") {
        let s;
        try {
          s = JSON.parse(o);
        } catch {
          return;
        }
        if (s && s.protocol === "nuanria_messaging" && s.type === "request") {
          const l = s.payload;
          if (l && l.functionId === "makeChanges") {
            const a = l.args;
            if (a) {
              const [u, c, d, f, h, p] = a;
              e.update(() => {
                const g = J();
                if (H(g)) {
                  const x = g.anchor;
                  let b = x.getNode(),
                    m = 0,
                    v = 0;
                  if (
                    (Z(b) && u >= 0 && c >= 0 && ((m = u), (v = u + c), g.setTextNodeRange(b, m, b, v)),
                    (m === v && d === "") || (g.insertRawText(d), (b = x.getNode())),
                    Z(b))
                  ) {
                    (m = f), (v = f + h);
                    const _ = b.getTextContentSize();
                    (m = m > _ ? _ : m), (v = v > _ ? _ : v), g.setTextNodeRange(b, m, b, v);
                  }
                  r.stopImmediatePropagation();
                }
              });
            }
          }
        }
      }
    };
  return (
    window.addEventListener("message", n, !0),
    () => {
      window.removeEventListener("message", n, !0);
    }
  );
}
const jc =
  typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0
    ? E.useLayoutEffect
    : E.useEffect;
function Bg(e) {
  return e.getEditorState().read(ev(e.isComposing()));
}
function Pf({ contentEditable: e, placeholder: t = null, ErrorBoundary: n }) {
  const [r] = bt(),
    i = (function (o, s) {
      const [l, a] = E.useState(() => o.getDecorators());
      return (
        jc(
          () =>
            o.registerDecoratorListener((u) => {
              Ni.flushSync(() => {
                a(u);
              });
            }),
          [o],
        ),
        E.useEffect(() => {
          a(o.getDecorators());
        }, [o]),
        E.useMemo(() => {
          const u = [],
            c = Object.keys(l);
          for (let d = 0; d < c.length; d++) {
            const f = c[d],
              h = O.jsx(s, {
                onError: (g) => o._onError(g),
                children: O.jsx(E.Suspense, { fallback: null, children: l[f] }),
              }),
              p = o.getElementByKey(f);
            p !== null && u.push(Ni.createPortal(h, p, f));
          }
          return u;
        }, [s, l, o])
      );
    })(r, n);
  return (
    (function (o) {
      jc(() => yt(jw(o), lT(o)), [o]);
    })(r),
    O.jsxs(O.Fragment, { children: [e, O.jsx(aT, { content: t }), i] })
  );
}
function aT({ content: e }) {
  const [t] = bt(),
    n = (function (i) {
      const [o, s] = E.useState(() => Bg(i));
      return (
        jc(() => {
          function l() {
            const a = Bg(i);
            s(a);
          }
          return (
            l(),
            yt(
              i.registerUpdateListener(() => {
                l();
              }),
              i.registerEditableListener(() => {
                l();
              }),
            )
          );
        }, [i]),
        o
      );
    })(t),
    r = sT();
  return n ? (typeof e == "function" ? e(r) : e) : null;
}
var nv = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/ (function (e) {
  (function () {
    var t = {}.hasOwnProperty;
    function n() {
      for (var o = "", s = 0; s < arguments.length; s++) {
        var l = arguments[s];
        l && (o = i(o, r(l)));
      }
      return o;
    }
    function r(o) {
      if (typeof o == "string" || typeof o == "number") return o;
      if (typeof o != "object") return "";
      if (Array.isArray(o)) return n.apply(null, o);
      if (o.toString !== Object.prototype.toString && !o.toString.toString().includes("[native code]"))
        return o.toString();
      var s = "";
      for (var l in o) t.call(o, l) && o[l] && (s = i(s, l));
      return s;
    }
    function i(o, s) {
      return s ? (o ? o + " " + s : o + s) : o;
    }
    e.exports ? ((n.default = n), (e.exports = n)) : (window.classNames = n);
  })();
})(nv);
var uT = nv.exports;
const we = w1(uT),
  cT = "_editorRoot_sects_53",
  dT = "_editorWrapper_sects_155",
  fT = "_toolbarRoot_sects_162",
  hT = "_readOnlyToolbarRoot_sects_189",
  pT = "_toolbarToggleItem_sects_208",
  gT = "_toolbarGroupOfGroups_sects_219",
  mT = "_toolbarToggleSingleGroup_sects_224",
  xT = "_toolbarButton_sects_239",
  vT = "_activeToolbarButton_sects_275",
  bT = "_toolbarButtonDropdownContainer_sects_286",
  yT = "_selectContainer_sects_288",
  CT = "_selectItem_sects_301",
  _T = "_toolbarButtonSelectTrigger_sects_307",
  wT = "_selectTrigger_sects_308",
  ET = "_selectDropdownArrow_sects_374",
  kT = "_contentEditable_sects_380",
  ST = "_codeMirrorWrapper_sects_392",
  TT = "_sandPackWrapper_sects_401",
  AT = "_codeMirrorToolbar_sects_409",
  IT = "_propertyPanelTitle_sects_431",
  NT = "_propertyEditorTable_sects_439",
  LT = "_iconButton_sects_457",
  MT = "_readOnlyColumnCell_sects_462",
  OT = "_buttonsFooter_sects_475",
  FT = "_propertyEditorInput_sects_481",
  RT = "_primaryButton_sects_507",
  PT = "_secondaryButton_sects_508",
  DT = "_smallButton_sects_523",
  $T = "_dialogForm_sects_535",
  BT = "_linkDialogEditForm_sects_541",
  HT = "_linkDialogInputContainer_sects_549",
  VT = "_linkDialogInputWrapper_sects_555",
  zT = "_linkDialogInput_sects_549",
  jT = "_linkDialogAnchor_sects_587",
  UT = "_linkDialogPopoverContent_sects_601",
  WT = "_tableColumnEditorPopoverContent_sects_602",
  KT = "_dialogContent_sects_603",
  JT = "_largeDialogContent_sects_615",
  GT = "_dialogTitle_sects_625",
  ZT = "_dialogCloseButton_sects_631",
  qT = "_popoverContent_sects_638",
  YT = "_popoverArrow_sects_650",
  XT = "_linkDialogPreviewAnchor_sects_654",
  QT = "_tooltipTrigger_sects_677",
  e7 = "_tooltipContent_sects_681",
  t7 = "_actionButton_sects_695",
  n7 = "_primaryActionButton_sects_702",
  r7 = "_tableEditor_sects_714",
  i7 = "_toolCell_sects_725",
  o7 = "_tableColumnEditorTrigger_sects_744",
  s7 = "_addRowButton_sects_746",
  l7 = "_addColumnButton_sects_747",
  a7 = "_tableColumnEditorToolbar_sects_789",
  u7 = "_toggleGroupRoot_sects_802",
  c7 = "_tableToolsColumn_sects_820",
  d7 = "_leftAlignedCell_sects_829",
  f7 = "_rightAlignedCell_sects_833",
  h7 = "_centeredCell_sects_837",
  p7 = "_dialogOverlay_sects_870",
  g7 = "_focusedImage_sects_916",
  m7 = "_imageWrapper_sects_920",
  x7 = "_editImageToolbar_sects_933",
  v7 = "_editImageButton_sects_937",
  b7 = "_inlineEditor_sects_943",
  y7 = "_blockEditor_sects_952",
  C7 = "_nestedEditor_sects_961",
  _7 = "_genericComponentName_sects_980",
  w7 = "_diffSourceToggleWrapper_sects_986",
  E7 = "_ggDiffSourceToggle_sects_994",
  k7 = "_diffSourceToggle_sects_986",
  S7 = "_selectWithLabel_sects_1012",
  T7 = "_toolbarTitleMode_sects_1027",
  A7 = "_imageControlWrapperResizing_sects_1032",
  I7 = "_imageResizer_sects_1036",
  N7 = "_imageResizerN_sects_1045",
  L7 = "_imageResizerNe_sects_1051",
  M7 = "_imageResizerE_sects_1057",
  O7 = "_imageResizerSe_sects_1063",
  F7 = "_imageResizerS_sects_1063",
  R7 = "_imageResizerSw_sects_1075",
  P7 = "_imageResizerW_sects_1081",
  D7 = "_imageResizerNw_sects_1087",
  $7 = "_imagePlaceholder_sects_1093",
  B7 = "_placeholder_sects_1101",
  H7 = "_rootContentEditableWrapper_sects_1114",
  V7 = "_downshiftInputWrapper_sects_1124",
  z7 = "_downshiftInput_sects_1124",
  j7 = "_downshiftAutocompleteContainer_sects_1155",
  U7 = "_textInput_sects_1201",
  W7 = "_multiFieldForm_sects_1209",
  K7 = "_formField_sects_1215",
  J7 = "_markdownParseError_sects_1226",
  G7 = "_popupContainer_sects_1235",
  Z7 = "_inputSizer_sects_1240",
  D = {
    editorRoot: cT,
    editorWrapper: dT,
    toolbarRoot: fT,
    readOnlyToolbarRoot: hT,
    toolbarToggleItem: pT,
    toolbarGroupOfGroups: gT,
    toolbarToggleSingleGroup: mT,
    toolbarButton: xT,
    activeToolbarButton: vT,
    toolbarButtonDropdownContainer: bT,
    selectContainer: yT,
    selectItem: CT,
    toolbarButtonSelectTrigger: _T,
    selectTrigger: wT,
    selectDropdownArrow: ET,
    contentEditable: kT,
    codeMirrorWrapper: ST,
    sandPackWrapper: TT,
    codeMirrorToolbar: AT,
    propertyPanelTitle: IT,
    propertyEditorTable: NT,
    iconButton: LT,
    readOnlyColumnCell: MT,
    buttonsFooter: OT,
    propertyEditorInput: FT,
    primaryButton: RT,
    secondaryButton: PT,
    smallButton: DT,
    dialogForm: $T,
    linkDialogEditForm: BT,
    linkDialogInputContainer: HT,
    linkDialogInputWrapper: VT,
    linkDialogInput: zT,
    linkDialogAnchor: jT,
    linkDialogPopoverContent: UT,
    tableColumnEditorPopoverContent: WT,
    dialogContent: KT,
    largeDialogContent: JT,
    dialogTitle: GT,
    dialogCloseButton: ZT,
    popoverContent: qT,
    popoverArrow: YT,
    linkDialogPreviewAnchor: XT,
    tooltipTrigger: QT,
    tooltipContent: e7,
    actionButton: t7,
    primaryActionButton: n7,
    tableEditor: r7,
    toolCell: i7,
    tableColumnEditorTrigger: o7,
    addRowButton: s7,
    addColumnButton: l7,
    tableColumnEditorToolbar: a7,
    toggleGroupRoot: u7,
    tableToolsColumn: c7,
    leftAlignedCell: d7,
    rightAlignedCell: f7,
    centeredCell: h7,
    dialogOverlay: p7,
    focusedImage: g7,
    imageWrapper: m7,
    editImageToolbar: x7,
    editImageButton: v7,
    inlineEditor: b7,
    blockEditor: y7,
    nestedEditor: C7,
    genericComponentName: _7,
    diffSourceToggleWrapper: w7,
    ggDiffSourceToggle: E7,
    diffSourceToggle: k7,
    selectWithLabel: S7,
    toolbarTitleMode: T7,
    imageControlWrapperResizing: A7,
    imageResizer: I7,
    imageResizerN: N7,
    imageResizerNe: L7,
    imageResizerE: M7,
    imageResizerSe: O7,
    imageResizerS: F7,
    imageResizerSw: R7,
    imageResizerW: P7,
    imageResizerNw: D7,
    imagePlaceholder: $7,
    placeholder: B7,
    rootContentEditableWrapper: H7,
    downshiftInputWrapper: V7,
    downshiftInput: z7,
    downshiftAutocompleteContainer: j7,
    textInput: U7,
    multiFieldForm: W7,
    formField: K7,
    markdownParseError: J7,
    popupContainer: G7,
    inputSizer: Z7,
  },
  q7 = {
    undo: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M7.202 18.5V17H14.3788C15.4224 17 16.3205 16.6554 17.073 15.9663C17.8257 15.2773 18.202 14.4263 18.202 13.4135C18.202 12.4007 17.8257 11.5512 17.073 10.8652C16.3205 10.1794 15.4224 9.8365 14.3788 9.8365H7.35775L10.1402 12.6193L9.0865 13.673L4.5 9.0865L9.0865 4.5L10.1402 5.55375L7.35775 8.3365H14.3788C15.8416 8.3365 17.0945 8.82467 18.1375 9.801C19.1805 10.7773 19.702 11.9815 19.702 13.4135C19.702 14.8455 19.1805 16.0513 18.1375 17.0308C17.0945 18.0103 15.8416 18.5 14.3788 18.5H7.202Z",
        fill: "currentColor",
      }),
    ),
    redo: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M9.6211 18.5C8.15827 18.5 6.90535 18.0103 5.86235 17.0308C4.81935 16.0513 4.29785 14.8455 4.29785 13.4135C4.29785 11.9815 4.81935 10.7773 5.86235 9.801C6.90535 8.82467 8.15827 8.3365 9.6211 8.3365H16.6421L13.8596 5.55375L14.9134 4.5L19.4999 9.0865L14.9134 13.673L13.8596 12.6193L16.6421 9.8365H9.6211C8.57744 9.8365 7.67935 10.1794 6.92685 10.8652C6.17418 11.5512 5.79785 12.4007 5.79785 13.4135C5.79785 14.4263 6.17418 15.2773 6.92685 15.9663C7.67935 16.6554 8.57744 17 9.6211 17H16.7979V18.5H9.6211Z",
        fill: "currentColor",
      }),
    ),
    format_bold: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M7.33838 18.625V5.375H12.1999C13.219 5.375 14.1405 5.69233 14.9644 6.327C15.788 6.9615 16.1999 7.816 16.1999 8.8905C16.1999 9.63783 16.0194 10.2471 15.6584 10.7182C15.2975 11.1894 14.9088 11.5314 14.4921 11.7442C15.005 11.9211 15.4947 12.2708 15.9614 12.7933C16.428 13.3158 16.6614 14.0193 16.6614 14.9038C16.6614 16.1819 16.1902 17.1217 15.2479 17.723C14.3055 18.3243 13.3562 18.625 12.3999 18.625H7.33838ZM9.48838 16.6328H12.3191C13.1063 16.6328 13.6627 16.4142 13.9884 15.977C14.314 15.5398 14.4769 15.1206 14.4769 14.7192C14.4769 14.3179 14.314 13.8987 13.9884 13.4615C13.6627 13.0243 13.0909 12.8058 12.2729 12.8058H9.48838V16.6328ZM9.48838 10.875H12.0826C12.6903 10.875 13.172 10.7013 13.5279 10.3538C13.8835 10.0064 14.0614 9.59042 14.0614 9.10575C14.0614 8.59042 13.8733 8.16925 13.4971 7.84225C13.1208 7.51542 12.6595 7.352 12.1134 7.352H9.48838V10.875Z",
        fill: "currentColor",
      }),
    ),
    format_italic: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M5.39404 18.625V16.8173H9.21129L12.4518 7.18275H8.63454V5.375H17.7883V7.18275H14.2785L11.0383 16.8173H14.5478V18.625H5.39404Z",
        fill: "currentColor",
      }),
    ),
    format_underlined: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M5.34619 22.125V20.625H18.6537V22.125H5.34619ZM11.9999 18.5287C10.4448 18.5287 9.23102 18.0566 8.35869 17.1125C7.48619 16.1683 7.04994 14.9032 7.04994 13.3172V5.41345H8.90369V13.4095C8.90369 14.4198 9.17228 15.2295 9.70944 15.8385C10.2466 16.4475 11.0101 16.752 11.9999 16.752C12.9898 16.752 13.7533 16.4475 14.2904 15.8385C14.8276 15.2295 15.0962 14.4198 15.0962 13.4095V5.41345H16.9499V13.3172C16.9499 14.9032 16.5137 16.1683 15.6412 17.1125C14.7689 18.0566 13.5551 18.5287 11.9999 18.5287Z",
        fill: "currentColor",
      }),
    ),
    code: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M7.99994 17.6537L2.34619 11.9999L7.99994 6.34619L9.06919 7.41544L4.46919 12.0154L9.05369 16.5999L7.99994 17.6537ZM15.9999 17.6537L14.9307 16.5844L19.5307 11.9844L14.9462 7.39994L15.9999 6.34619L21.6537 11.9999L15.9999 17.6537Z",
        fill: "currentColor",
      }),
    ),
    strikeThrough: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M12.15 19.6923C10.9732 19.6923 9.9315 19.359 9.025 18.6923C8.11867 18.0256 7.45525 17.1128 7.03475 15.9538L8.6385 15.2635C8.91667 16.0444 9.3545 16.6867 9.952 17.1905C10.5493 17.6944 11.2923 17.9463 12.1808 17.9463C12.9578 17.9463 13.6744 17.7508 14.3307 17.3598C14.9872 16.9686 15.3155 16.3487 15.3155 15.5C15.3155 15.123 15.2555 14.7968 15.1355 14.5213C15.0157 14.2456 14.8462 13.9885 14.627 13.75H16.677C16.7987 13.9705 16.8932 14.2256 16.9605 14.5153C17.0278 14.8051 17.0615 15.1334 17.0615 15.5C17.0615 16.8372 16.5747 17.8702 15.601 18.599C14.6272 19.3279 13.4768 19.6923 12.15 19.6923ZM2.25 11.75V10.25H21.75V11.75H2.25ZM12.05 4.19629C13.0475 4.19629 13.9123 4.42704 14.6443 4.88854C15.3763 5.35004 15.9673 6.05896 16.4173 7.01529L14.823 7.73079C14.6218 7.26029 14.2978 6.84462 13.851 6.48379C13.4042 6.12279 12.8141 5.94229 12.0808 5.94229C11.2244 5.94229 10.5392 6.16221 10.025 6.60204C9.51083 7.04171 9.264 7.59104 9.2845 8.25004H7.5385C7.50133 7.16421 7.89783 6.21712 8.728 5.40879C9.558 4.60046 10.6653 4.19629 12.05 4.19629Z",
        fill: "currentColor",
      }),
    ),
    superscript: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M16.6924 8V6.2115C16.6924 5.95383 16.7786 5.73875 16.9511 5.56625C17.1235 5.39392 17.3385 5.30775 17.5961 5.30775H19.5001V4.38475H16.6924V3.5H19.4809C19.7385 3.5 19.9536 3.58625 20.1261 3.75875C20.2985 3.93108 20.3846 4.14617 20.3846 4.404V5.2885C20.3846 5.54617 20.2985 5.76125 20.1261 5.93375C19.9536 6.10608 19.7385 6.19225 19.4809 6.19225H17.5771V7.1155H20.3846V8H16.6924ZM4.44238 18.5L8.84638 11.6287L4.77713 5.30775H6.74438L9.95963 10.404H10.0214L13.2501 5.30775H15.2329L11.1194 11.6287L15.5579 18.5H13.5751L10.0214 12.9308H9.95963L6.42513 18.5H4.44238Z",
        fill: "currentColor",
      }),
    ),
    subscript: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M16.6924 20.5V18.7115C16.6924 18.4538 16.7786 18.2387 16.9511 18.0662C17.1235 17.8939 17.3385 17.8077 17.5961 17.8077H19.5001V16.8845H16.6924V16H19.4809C19.7385 16 19.9536 16.0863 20.1261 16.2587C20.2985 16.4311 20.3846 16.6461 20.3846 16.9038V17.7885C20.3846 18.0462 20.2985 18.2612 20.1261 18.4337C19.9536 18.6061 19.7385 18.6923 19.4809 18.6923H17.5771V19.6152H20.3846V20.5H16.6924ZM4.44238 18.6923L8.84638 11.8212L4.77713 5.5H6.74438L9.95963 10.5962H10.0214L13.2501 5.5H15.2329L11.1194 11.8212L15.5579 18.6923H13.5751L10.0214 13.123H9.95963L6.42513 18.6923H4.44238Z",
        fill: "currentColor",
      }),
    ),
    format_list_bulleted: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M9.30775 18.75V17.25H20.5V18.75H9.30775ZM9.30775 12.75V11.25H20.5V12.75H9.30775ZM9.30775 6.75005V5.25005H20.5V6.75005H9.30775ZM5.1635 19.6635C4.706 19.6635 4.31442 19.5006 3.98875 19.1748C3.66292 18.8491 3.5 18.4575 3.5 18C3.5 17.5425 3.66292 17.151 3.98875 16.8253C4.31442 16.4995 4.706 16.3365 5.1635 16.3365C5.621 16.3365 6.01258 16.4995 6.33825 16.8253C6.66408 17.151 6.827 17.5425 6.827 18C6.827 18.4575 6.66408 18.8491 6.33825 19.1748C6.01258 19.5006 5.621 19.6635 5.1635 19.6635ZM5.1635 13.6635C4.706 13.6635 4.31442 13.5006 3.98875 13.1748C3.66292 12.8491 3.5 12.4575 3.5 12C3.5 11.5425 3.66292 11.151 3.98875 10.8253C4.31442 10.4995 4.706 10.3365 5.1635 10.3365C5.621 10.3365 6.01258 10.4995 6.33825 10.8253C6.66408 11.151 6.827 11.5425 6.827 12C6.827 12.4575 6.66408 12.8491 6.33825 13.1748C6.01258 13.5006 5.621 13.6635 5.1635 13.6635ZM5.1635 7.66355C4.706 7.66355 4.31442 7.50063 3.98875 7.1748C3.66292 6.84913 3.5 6.45755 3.5 6.00005C3.5 5.54255 3.66292 5.15096 3.98875 4.8253C4.31442 4.49946 4.706 4.33655 5.1635 4.33655C5.621 4.33655 6.01258 4.49946 6.33825 4.8253C6.66408 5.15096 6.827 5.54255 6.827 6.00005C6.827 6.45755 6.66408 6.84913 6.33825 7.1748C6.01258 7.50063 5.621 7.66355 5.1635 7.66355Z",
        fill: "currentColor",
      }),
    ),
    format_list_numbered: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M3.5 21.5V20.3078H6V19.25H4.5V18.0577H6V17H3.5V15.8077H6.34625C6.58592 15.8077 6.78683 15.8888 6.949 16.051C7.11117 16.2132 7.19225 16.4141 7.19225 16.6538V17.8462C7.19225 18.0859 7.11117 18.2868 6.949 18.449C6.78683 18.6112 6.58592 18.6923 6.34625 18.6923C6.58592 18.6923 6.78683 18.7733 6.949 18.9355C7.11117 19.0977 7.19225 19.2987 7.19225 19.5385V20.6538C7.19225 20.8936 7.11117 21.0946 6.949 21.2568C6.78683 21.4189 6.58592 21.5 6.34625 21.5H3.5ZM3.5 14.8463V12.25C3.5 12.0103 3.58108 11.8093 3.74325 11.647C3.90542 11.4848 4.10642 11.4038 4.34625 11.4038H6V10.3462H3.5V9.15375H6.34625C6.58592 9.15375 6.78683 9.23483 6.949 9.397C7.11117 9.55933 7.19225 9.76033 7.19225 10V11.75C7.19225 11.9897 7.11117 12.1907 6.949 12.353C6.78683 12.5152 6.58592 12.5963 6.34625 12.5963H4.69225V13.6538H7.19225V14.8463H3.5ZM5 8.19225V3.69225H3.5V2.5H6.19225V8.19225H5ZM9.30775 18.75V17.25H20.5V18.75H9.30775ZM9.30775 12.75V11.25H20.5V12.75H9.30775ZM9.30775 6.75V5.25H20.5V6.75H9.30775Z",
        fill: "currentColor",
      }),
    ),
    format_list_checked: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M5.69425 18.452L2.5 15.2578L3.54425 14.2135L5.66925 16.3385L9.91925 12.0885L10.9635 13.1578L5.69425 18.452ZM5.69425 10.8365L2.5 7.64227L3.54425 6.59802L5.66925 8.72302L9.91925 4.47302L10.9635 5.54227L5.69425 10.8365ZM13.0095 16.5578V15.0578H21.5095V16.5578H13.0095ZM13.0095 8.94227V7.44227H21.5095V8.94227H13.0095Z",
        fill: "currentColor",
      }),
    ),
    link: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M10.8077 16.5385H7.0385C5.78283 16.5385 4.7125 16.096 3.8275 15.211C2.9425 14.3262 2.5 13.256 2.5 12.0005C2.5 10.745 2.9425 9.67471 3.8275 8.78955C4.7125 7.90421 5.78283 7.46155 7.0385 7.46155H10.8077V8.96155H7.0385C6.19867 8.96155 5.48233 9.25805 4.8895 9.85105C4.2965 10.444 4 11.1604 4 12C4 12.8397 4.2965 13.556 4.8895 14.149C5.48233 14.742 6.19867 15.0385 7.0385 15.0385H10.8077V16.5385ZM8.25 12.75V11.25H15.75V12.75H8.25ZM13.1923 16.5385V15.0385H16.9615C17.8013 15.0385 18.5177 14.742 19.1105 14.149C19.7035 13.556 20 12.8397 20 12C20 11.1604 19.7035 10.444 19.1105 9.85105C18.5177 9.25805 17.8013 8.96155 16.9615 8.96155H13.1923V7.46155H16.9615C18.2172 7.46155 19.2875 7.90405 20.1725 8.78905C21.0575 9.67388 21.5 10.744 21.5 11.9995C21.5 13.255 21.0575 14.3254 20.1725 15.2105C19.2875 16.0959 18.2172 16.5385 16.9615 16.5385H13.1923Z",
        fill: "currentColor",
      }),
    ),
    add_photo: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M5.11537 20.5C4.6182 20.5 4.19262 20.323 3.83862 19.969C3.48462 19.615 3.30762 19.1894 3.30762 18.6922V5.30773C3.30762 4.81056 3.48462 4.38498 3.83862 4.03098C4.19262 3.67698 4.6182 3.49998 5.11537 3.49998H13.8076V4.99998H5.11537C5.02553 4.99998 4.95178 5.02881 4.89412 5.08648C4.83645 5.14415 4.80762 5.2179 4.80762 5.30773V18.6922C4.80762 18.7821 4.83645 18.8558 4.89412 18.9135C4.95178 18.9711 5.02553 19 5.11537 19H18.4999C18.5895 19 18.6633 18.9711 18.7211 18.9135C18.7788 18.8558 18.8076 18.7821 18.8076 18.6922V9.99998H20.3076V18.6922C20.3076 19.1894 20.1306 19.615 19.7766 19.969C19.4226 20.323 18.997 20.5 18.4999 20.5H5.11537ZM17.1921 8.61523V6.61523H15.1921V5.11548H17.1921V3.11548H18.6921V5.11548H20.6921V6.61523H18.6921V8.61523H17.1921ZM6.55762 16.75H17.1344L13.8459 12.3655L11.0384 16.0192L9.03837 13.4615L6.55762 16.75Z",
        fill: "currentColor",
      }),
    ),
    table: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M3.5 18.6923V5.30775C3.5 4.81058 3.677 4.385 4.031 4.031C4.385 3.677 4.81058 3.5 5.30775 3.5H18.6923C19.1894 3.5 19.615 3.677 19.969 4.031C20.323 4.385 20.5 4.81058 20.5 5.30775V18.6923C20.5 19.1894 20.323 19.615 19.969 19.969C19.615 20.323 19.1894 20.5 18.6923 20.5H5.30775C4.81058 20.5 4.385 20.323 4.031 19.969C3.677 19.615 3.5 19.1894 3.5 18.6923ZM5 9.077H19V5.30775C19 5.21792 18.9712 5.14417 18.9135 5.0865C18.8558 5.02883 18.7821 5 18.6923 5H5.30775C5.21792 5 5.14417 5.02883 5.0865 5.0865C5.02883 5.14417 5 5.21792 5 5.30775V9.077ZM10.1615 14.0385H13.8385V10.577H10.1615V14.0385ZM10.1615 19H13.8385V15.5385H10.1615V19ZM5 14.0385H8.6615V10.577H5V14.0385ZM15.3385 14.0385H19V10.577H15.3385V14.0385ZM5.30775 19H8.6615V15.5385H5V18.6923C5 18.7821 5.02883 18.8558 5.0865 18.9135C5.14417 18.9712 5.21792 19 5.30775 19ZM15.3385 19H18.6923C18.7821 19 18.8558 18.9712 18.9135 18.9135C18.9712 18.8558 19 18.7821 19 18.6923V15.5385H15.3385V19Z",
        fill: "currentColor",
      }),
    ),
    horizontal_rule: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", { d: "M4.5 12.75V11.25H19.5V12.75H4.5Z", fill: "currentColor" }),
    ),
    frontmatter: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", { d: "M4.5 8.75V7.25H8.5V8.75H4.5Z", fill: "currentColor" }),
      C.createElement("path", { d: "M4.5 14.75V13.25H8.5V14.75H4.5Z", fill: "currentColor" }),
      C.createElement("path", { d: "M9.5 8.75V7.25H13.5V8.75H9.5Z", fill: "currentColor" }),
      C.createElement("path", { d: "M9.5 14.75V13.25H13.5V14.75H9.5Z", fill: "currentColor" }),
      C.createElement("path", { d: "M14.5 8.75V7.25H18.5V8.75H14.5Z", fill: "currentColor" }),
      C.createElement("path", { d: "M14.5 14.75V13.25H18.5V14.75H14.5Z", fill: "currentColor" }),
    ),
    frame_source: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M8.6 15.2443L5.35575 12L8.6 8.75575L9.64425 9.825L7.46925 12L9.64425 14.175L8.6 15.2443ZM15.4 15.2443L14.3558 14.175L16.5307 12L14.3558 9.825L15.4 8.75575L18.6443 12L15.4 15.2443ZM5.30775 20.5C4.80258 20.5 4.375 20.325 4.025 19.975C3.675 19.625 3.5 19.1974 3.5 18.6923V15H5V18.6923C5 18.7692 5.03208 18.8398 5.09625 18.9038C5.16025 18.9679 5.23075 19 5.30775 19H9V20.5H5.30775ZM15 20.5V19H18.6923C18.7692 19 18.8398 18.9679 18.9038 18.9038C18.9679 18.8398 19 18.7692 19 18.6923V15H20.5V18.6923C20.5 19.1974 20.325 19.625 19.975 19.975C19.625 20.325 19.1974 20.5 18.6923 20.5H15ZM3.5 9V5.30775C3.5 4.80258 3.675 4.375 4.025 4.025C4.375 3.675 4.80258 3.5 5.30775 3.5H9V5H5.30775C5.23075 5 5.16025 5.03208 5.09625 5.09625C5.03208 5.16025 5 5.23075 5 5.30775V9H3.5ZM19 9V5.30775C19 5.23075 18.9679 5.16025 18.9038 5.09625C18.8398 5.03208 18.7692 5 18.6923 5H15V3.5H18.6923C19.1974 3.5 19.625 3.675 19.975 4.025C20.325 4.375 20.5 4.80258 20.5 5.30775V9H19Z",
        fill: "currentColor",
      }),
    ),
    arrow_drop_down: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", { d: "M11.9999 14.6537L7.59619 10.25H16.4037L11.9999 14.6537Z", fill: "currentColor" }),
    ),
    admonition: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M12.0001 21.4C11.7654 21.4 11.5385 21.3548 11.3193 21.2645C11.1002 21.174 10.9002 21.0435 10.7193 20.873L3.1271 13.2807C2.9566 13.0999 2.8261 12.8999 2.7356 12.6807C2.64526 12.4616 2.6001 12.2346 2.6001 12C2.6001 11.7653 2.64526 11.5358 2.7356 11.3115C2.8261 11.0871 2.9566 10.8897 3.1271 10.7192L10.7193 3.12698C10.9002 2.94614 11.1002 2.81314 11.3193 2.72798C11.5385 2.64264 11.7654 2.59998 12.0001 2.59998C12.2348 2.59998 12.4643 2.64264 12.6886 2.72798C12.9129 2.81314 13.1103 2.94614 13.2808 3.12698L20.8731 10.7192C21.0539 10.8897 21.1869 11.0871 21.2721 11.3115C21.3574 11.5358 21.4001 11.7653 21.4001 12C21.4001 12.2346 21.3574 12.4616 21.2721 12.6807C21.1869 12.8999 21.0539 13.0999 20.8731 13.2807L13.2808 20.873C13.1103 21.0435 12.9129 21.174 12.6886 21.2645C12.4643 21.3548 12.2348 21.4 12.0001 21.4ZM12.2213 19.8037L19.8039 12.2212C19.8552 12.1699 19.8808 12.0961 19.8808 12C19.8808 11.9038 19.8552 11.8301 19.8039 11.7787L12.2213 4.19623C12.17 4.14489 12.0963 4.11923 12.0001 4.11923C11.9039 4.11923 11.8302 4.14489 11.7788 4.19623L4.19635 11.7787C4.14501 11.8301 4.11935 11.9038 4.11935 12C4.11935 12.0961 4.14501 12.1699 4.19635 12.2212L11.7788 19.8037C11.8302 19.8551 11.9039 19.8807 12.0001 19.8807C12.0963 19.8807 12.17 19.8551 12.2213 19.8037ZM11.2501 13.0865H12.7501V7.47123H11.2501V13.0865ZM12.0001 15.702C12.2258 15.702 12.4168 15.6237 12.5731 15.4672C12.7296 15.3109 12.8078 15.1199 12.8078 14.8942C12.8078 14.6686 12.7296 14.4776 12.5731 14.3212C12.4168 14.1647 12.2258 14.0865 12.0001 14.0865C11.7744 14.0865 11.5834 14.1647 11.4271 14.3212C11.2706 14.4776 11.1923 14.6686 11.1923 14.8942C11.1923 15.1199 11.2706 15.3109 11.4271 15.4672C11.5834 15.6237 11.7744 15.702 12.0001 15.702Z",
        fill: "currentColor",
      }),
    ),
    sandpack: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M12.9999 22.5C12.4947 22.5 12.0671 22.325 11.7171 21.975C11.3671 21.625 11.1921 21.1974 11.1921 20.6922V7.30775C11.1921 6.80258 11.3671 6.375 11.7171 6.025C12.0671 5.675 12.4947 5.5 12.9999 5.5H16.3844C16.8895 5.5 17.3171 5.675 17.6671 6.025C18.0171 6.375 18.1921 6.80258 18.1921 7.30775V20.6922C18.1921 21.1974 18.0171 21.625 17.6671 21.975C17.3171 22.325 16.8895 22.5 16.3844 22.5H12.9999ZM12.6921 7.30775V20.6922C12.6921 20.7692 12.7242 20.8398 12.7884 20.9038C12.8524 20.9679 12.9229 21 12.9999 21H16.3844C16.4614 21 16.5319 20.9679 16.5959 20.9038C16.66 20.8398 16.6921 20.7692 16.6921 20.6922V7.30775C16.6921 7.23075 16.66 7.16025 16.5959 7.09625C16.5319 7.03208 16.4614 7 16.3844 7H12.9999C12.9229 7 12.8524 7.03208 12.7884 7.09625C12.7242 7.16025 12.6921 7.23075 12.6921 7.30775ZM6.61537 18.5C6.1102 18.5 5.68262 18.325 5.33262 17.975C4.98262 17.625 4.80762 17.1974 4.80762 16.6923V3.30775C4.80762 2.80258 4.98262 2.375 5.33262 2.025C5.68262 1.675 6.1102 1.5 6.61537 1.5H9.99987C10.505 1.5 10.9326 1.675 11.2826 2.025C11.6326 2.375 11.8076 2.80258 11.8076 3.30775V16.6923C11.8076 17.1974 11.6326 17.625 11.2826 17.975C10.9326 18.325 10.505 18.5 9.99987 18.5H6.61537ZM6.30762 3.30775V16.6923C6.30762 16.7692 6.3397 16.8398 6.40387 16.9038C6.46787 16.9679 6.53837 17 6.61537 17H9.99987C10.0769 17 10.1474 16.9679 10.2114 16.9038C10.2755 16.8398 10.3076 16.7692 10.3076 16.6923V3.30775C10.3076 3.23075 10.2755 3.16025 10.2114 3.09625C10.1474 3.03208 10.0769 3 9.99987 3H6.61537C6.53837 3 6.46787 3.03208 6.40387 3.09625C6.3397 3.16025 6.30762 3.23075 6.30762 3.30775Z",
        fill: "currentColor",
      }),
    ),
    rich_text: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M5.30775 20.5C4.80258 20.5 4.375 20.325 4.025 19.975C3.675 19.625 3.5 19.1974 3.5 18.6923V5.30775C3.5 4.80258 3.675 4.375 4.025 4.025C4.375 3.675 4.80258 3.5 5.30775 3.5H18.6923C19.1974 3.5 19.625 3.675 19.975 4.025C20.325 4.375 20.5 4.80258 20.5 5.30775V18.6923C20.5 19.1974 20.325 19.625 19.975 19.975C19.625 20.325 19.1974 20.5 18.6923 20.5H5.30775ZM5.30775 19H18.6923C18.7692 19 18.8398 18.9679 18.9038 18.9038C18.9679 18.8398 19 18.7692 19 18.6923V5.30775C19 5.23075 18.9679 5.16025 18.9038 5.09625C18.8398 5.03208 18.7692 5 18.6923 5H5.30775C5.23075 5 5.16025 5.03208 5.09625 5.09625C5.03208 5.16025 5 5.23075 5 5.30775V18.6923C5 18.7692 5.03208 18.8398 5.09625 18.9038C5.16025 18.9679 5.23075 19 5.30775 19ZM6.75 17H17.3268L14 12.3655L11.2308 16.0192L9 13.4615L6.75 17Z",
        fill: "currentColor",
      }),
      C.createElement("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M6 12V6.5H9.1925C9.5925 6.5 9.9425 6.65 10.2425 6.95C10.5425 7.25 10.6925 7.6 10.6925 8V8.6925C10.6925 9.03733 10.605 9.32675 10.43 9.56075C10.255 9.79458 10.0168 9.97817 9.7155 10.1115L10.6155 12H9.404L8.504 10.1925H7.1925V12H6ZM9.1925 9H7.1925V7.6925H9.1925C9.26933 7.6925 9.33983 7.7245 9.404 7.7885C9.468 7.85267 9.5 7.92317 9.5 8V8.6925C9.5 8.76933 9.468 8.83983 9.404 8.904C9.33983 8.968 9.26933 9 9.1925 9Z",
        fill: "currentColor",
      }),
      C.createElement("path", { d: "M12.5 7H17.5V8.25H12.5V7Z", fill: "currentColor" }),
      C.createElement("path", { d: "M12.5 9.25H17.5V10.5H12.5V9.25Z", fill: "currentColor" }),
    ),
    difference: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M5.30775 20.5C4.80258 20.5 4.375 20.325 4.025 19.975C3.675 19.625 3.5 19.1974 3.5 18.6923V5.30775C3.5 4.80258 3.675 4.375 4.025 4.025C4.375 3.675 4.80258 3.5 5.30775 3.5H18.6923C19.1974 3.5 19.625 3.675 19.975 4.025C20.325 4.375 20.5 4.80258 20.5 5.30775V18.6923C20.5 19.1974 20.325 19.625 19.975 19.975C19.625 20.325 19.1974 20.5 18.6923 20.5H5.30775ZM18.6923 19H5.30775C5.23075 19 5.16025 18.9679 5.09625 18.9038C5.03208 18.8398 5 18.7692 5 18.6923V5.30775C5 5.23075 5.03208 5.16025 5.09625 5.09625C5.16025 5.03208 5.23075 5 5.30775 5H18.6923C18.7692 5 18.8398 5.03208 18.9038 5.09625C18.9679 5.16025 19 5.23075 19 5.30775V18.6923C19 18.7692 18.9679 18.8398 18.9038 18.9038C18.8398 18.9679 18.7692 19 18.6923 19Z",
        fill: "currentColor",
      }),
      C.createElement("rect", { x: "9", y: "10", width: "5.5", height: "1.5", fill: "currentColor" }),
      C.createElement("rect", { x: "9", y: "15", width: "5.5", height: "1.5", fill: "currentColor" }),
      C.createElement("rect", { x: "11", y: "8", width: "1.5", height: "5.5", fill: "currentColor" }),
    ),
    markdown: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M5.30775 20.5C4.80258 20.5 4.375 20.325 4.025 19.975C3.675 19.625 3.5 19.1974 3.5 18.6923V5.30775C3.5 4.80258 3.675 4.375 4.025 4.025C4.375 3.675 4.80258 3.5 5.30775 3.5H18.6923C19.1974 3.5 19.625 3.675 19.975 4.025C20.325 4.375 20.5 4.80258 20.5 5.30775V18.6923C20.5 19.1974 20.325 19.625 19.975 19.975C19.625 20.325 19.1974 20.5 18.6923 20.5H5.30775ZM18.6923 19H5.30775C5.23075 19 5.16025 18.9679 5.09625 18.9038C5.03208 18.8398 5 18.7692 5 18.6923V5.30775C5 5.23075 5.03208 5.16025 5.09625 5.09625C5.16025 5.03208 5.23075 5 5.30775 5H18.6923C18.7692 5 18.8398 5.03208 18.9038 5.09625C18.9679 5.16025 19 5.23075 19 5.30775V18.6923C19 18.7692 18.9679 18.8398 18.9038 18.9038C18.8398 18.9679 18.7692 19 18.6923 19Z",
        fill: "currentColor",
      }),
      C.createElement("path", {
        d: "M13 15H11.5V11L9.5 14L7.5 11V15H6V8H7.5L9.5 11L11.5 8H13V15Z",
        fill: "currentColor",
      }),
      C.createElement("path", {
        d: "M15.9921 15.5833L13.2886 12.8797L14.0546 12.1137L15.4504 13.5016V7.99597L16.5336 7.99993V13.5016L17.9296 12.1137L18.6954 12.8797L15.9921 15.5833Z",
        fill: "currentColor",
      }),
    ),
    open_in_new: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M5.30775 20.5C4.80258 20.5 4.375 20.325 4.025 19.975C3.675 19.625 3.5 19.1974 3.5 18.6923V5.30775C3.5 4.80258 3.675 4.375 4.025 4.025C4.375 3.675 4.80258 3.5 5.30775 3.5H11.6152V5H5.30775C5.23075 5 5.16025 5.03208 5.09625 5.09625C5.03208 5.16025 5 5.23075 5 5.30775V18.6923C5 18.7692 5.03208 18.8398 5.09625 18.9038C5.16025 18.9679 5.23075 19 5.30775 19H18.6923C18.7692 19 18.8398 18.9679 18.9038 18.9038C18.9679 18.8398 19 18.7692 19 18.6923V12.3848H20.5V18.6923C20.5 19.1974 20.325 19.625 19.975 19.975C19.625 20.325 19.1974 20.5 18.6923 20.5H5.30775ZM9.71925 15.3345L8.6655 14.2808L17.9462 5H14V3.5H20.5V10H19V6.05375L9.71925 15.3345Z",
        fill: "currentColor",
      }),
    ),
    link_off: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M18.8843 16.1038L17.7498 14.9385C18.4228 14.7552 18.9661 14.3946 19.3796 13.8568C19.7931 13.319 19.9998 12.7 19.9998 12C19.9998 11.1604 19.705 10.444 19.1153 9.85105C18.5255 9.25805 17.8139 8.96155 16.9806 8.96155H13.1728V7.46155H16.9806C18.2293 7.46155 19.2947 7.90422 20.1768 8.78955C21.0588 9.67472 21.4998 10.7449 21.4998 12C21.4998 12.8859 21.262 13.6951 20.7863 14.4278C20.3107 15.1606 19.6767 15.7193 18.8843 16.1038ZM15.5806 12.75L14.0806 11.25H15.7306V12.75H15.5806ZM20.1461 22.2538L1.74609 3.8538L2.79984 2.80005L21.1998 21.2L20.1461 22.2538ZM10.8268 16.5386H7.03834C5.78318 16.5386 4.71301 16.0959 3.82784 15.2105C2.94251 14.3254 2.49984 13.2552 2.49984 12C2.49984 10.8885 2.85784 9.91322 3.57384 9.07405C4.28984 8.23505 5.18826 7.72838 6.26909 7.55405H6.49984L7.90759 8.96155H7.03834C6.19851 8.96155 5.48218 9.25805 4.88934 9.85105C4.29634 10.444 3.99984 11.1604 3.99984 12C3.99984 12.8397 4.29634 13.556 4.88934 14.149C5.48218 14.742 6.19851 15.0385 7.03834 15.0385H10.8268V16.5386ZM8.26909 12.75V11.25H10.2113L11.6863 12.75H8.26909Z",
        fill: "currentColor",
      }),
    ),
    edit: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M5 19H6.2615L16.498 8.7635L15.2365 7.502L5 17.7385V19ZM3.5 20.5V17.1155L16.6905 3.93075C16.8417 3.79342 17.0086 3.68733 17.1913 3.6125C17.3741 3.5375 17.5658 3.5 17.7663 3.5C17.9668 3.5 18.1609 3.53558 18.3488 3.60675C18.5367 3.67792 18.7032 3.79108 18.848 3.94625L20.0693 5.18275C20.2244 5.32758 20.335 5.49425 20.401 5.68275C20.467 5.87125 20.5 6.05975 20.5 6.24825C20.5 6.44942 20.4657 6.64133 20.397 6.824C20.3283 7.00683 20.2191 7.17383 20.0693 7.325L6.8845 20.5H3.5ZM15.8562 8.14375L15.2365 7.502L16.498 8.7635L15.8562 8.14375Z",
        fill: "currentColor",
      }),
    ),
    content_copy: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M9.05775 17.5C8.55258 17.5 8.125 17.325 7.775 16.975C7.425 16.625 7.25 16.1974 7.25 15.6923V4.30775C7.25 3.80258 7.425 3.375 7.775 3.025C8.125 2.675 8.55258 2.5 9.05775 2.5H17.4423C17.9474 2.5 18.375 2.675 18.725 3.025C19.075 3.375 19.25 3.80258 19.25 4.30775V15.6923C19.25 16.1974 19.075 16.625 18.725 16.975C18.375 17.325 17.9474 17.5 17.4423 17.5H9.05775ZM9.05775 16H17.4423C17.5192 16 17.5898 15.9679 17.6538 15.9038C17.7179 15.8398 17.75 15.7692 17.75 15.6923V4.30775C17.75 4.23075 17.7179 4.16025 17.6538 4.09625C17.5898 4.03208 17.5192 4 17.4423 4H9.05775C8.98075 4 8.91025 4.03208 8.84625 4.09625C8.78208 4.16025 8.75 4.23075 8.75 4.30775V15.6923C8.75 15.7692 8.78208 15.8398 8.84625 15.9038C8.91025 15.9679 8.98075 16 9.05775 16ZM5.55775 21C5.05258 21 4.625 20.825 4.275 20.475C3.925 20.125 3.75 19.6974 3.75 19.1923V6.30775H5.25V19.1923C5.25 19.2693 5.28208 19.3398 5.34625 19.4038C5.41025 19.4679 5.48075 19.5 5.55775 19.5H15.4423V21H5.55775Z",
        fill: "currentColor",
      }),
    ),
    more_horiz: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M6.23096 13.5C5.81846 13.5 5.46537 13.3531 5.17171 13.0592C4.87787 12.7656 4.73096 12.4125 4.73096 12C4.73096 11.5875 4.87787 11.2344 5.17171 10.9408C5.46537 10.6469 5.81846 10.5 6.23096 10.5C6.64346 10.5 6.99662 10.6469 7.29046 10.9408C7.58412 11.2344 7.73096 11.5875 7.73096 12C7.73096 12.4125 7.58412 12.7656 7.29046 13.0592C6.99662 13.3531 6.64346 13.5 6.23096 13.5ZM12.0002 13.5C11.5877 13.5 11.2346 13.3531 10.941 13.0592C10.6471 12.7656 10.5002 12.4125 10.5002 12C10.5002 11.5875 10.6471 11.2344 10.941 10.9408C11.2346 10.6469 11.5877 10.5 12.0002 10.5C12.4127 10.5 12.7658 10.6469 13.0595 10.9408C13.3533 11.2344 13.5002 11.5875 13.5002 12C13.5002 12.4125 13.3533 12.7656 13.0595 13.0592C12.7658 13.3531 12.4127 13.5 12.0002 13.5ZM17.7695 13.5C17.357 13.5 17.0038 13.3531 16.71 13.0592C16.4163 12.7656 16.2695 12.4125 16.2695 12C16.2695 11.5875 16.4163 11.2344 16.71 10.9408C17.0038 10.6469 17.357 10.5 17.7695 10.5C18.182 10.5 18.535 10.6469 18.8287 10.9408C19.1225 11.2344 19.2695 11.5875 19.2695 12C19.2695 12.4125 19.1225 12.7656 18.8287 13.0592C18.535 13.3531 18.182 13.5 17.7695 13.5Z",
        fill: "currentColor",
      }),
    ),
    more_vert: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M12 19.2692C11.5875 19.2692 11.2344 19.1223 10.9408 18.8285C10.6469 18.5348 10.5 18.1817 10.5 17.7692C10.5 17.3567 10.6469 17.0035 10.9408 16.7097C11.2344 16.416 11.5875 16.2692 12 16.2692C12.4125 16.2692 12.7656 16.416 13.0592 16.7097C13.3531 17.0035 13.5 17.3567 13.5 17.7692C13.5 18.1817 13.3531 18.5348 13.0592 18.8285C12.7656 19.1223 12.4125 19.2692 12 19.2692ZM12 13.5C11.5875 13.5 11.2344 13.353 10.9408 13.0592C10.6469 12.7655 10.5 12.4125 10.5 12C10.5 11.5875 10.6469 11.2344 10.9408 10.9407C11.2344 10.6469 11.5875 10.5 12 10.5C12.4125 10.5 12.7656 10.6469 13.0592 10.9407C13.3531 11.2344 13.5 11.5875 13.5 12C13.5 12.4125 13.3531 12.7655 13.0592 13.0592C12.7656 13.353 12.4125 13.5 12 13.5ZM12 7.73071C11.5875 7.73071 11.2344 7.58388 10.9408 7.29021C10.6469 6.99638 10.5 6.64321 10.5 6.23071C10.5 5.81821 10.6469 5.46513 10.9408 5.17146C11.2344 4.87763 11.5875 4.73071 12 4.73071C12.4125 4.73071 12.7656 4.87763 13.0592 5.17146C13.3531 5.46513 13.5 5.81821 13.5 6.23071C13.5 6.64321 13.3531 6.99638 13.0592 7.29021C12.7656 7.58388 12.4125 7.73071 12 7.73071Z",
        fill: "currentColor",
      }),
    ),
    close: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M6.39994 18.6538L5.34619 17.6L10.9462 12L5.34619 6.4L6.39994 5.34625L11.9999 10.9463L17.5999 5.34625L18.6537 6.4L13.0537 12L18.6537 17.6L17.5999 18.6538L11.9999 13.0538L6.39994 18.6538Z",
        fill: "currentColor",
      }),
    ),
    settings: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M9.69225 21.5L9.3115 18.4538C9.04367 18.3641 8.769 18.2385 8.4875 18.077C8.20617 17.9153 7.95459 17.7422 7.73275 17.5577L4.9115 18.75L2.604 14.75L5.04425 12.9058C5.02125 12.7571 5.00492 12.6077 4.99525 12.4578C4.98559 12.3078 4.98075 12.1583 4.98075 12.0095C4.98075 11.8673 4.98559 11.7228 4.99525 11.576C5.00492 11.4292 5.02125 11.2686 5.04425 11.0943L2.604 9.25L4.9115 5.26925L7.723 6.452C7.96417 6.261 8.22159 6.08633 8.49525 5.928C8.76892 5.76967 9.03784 5.64242 9.302 5.54625L9.69225 2.5H14.3078L14.6885 5.55575C14.9885 5.66475 15.2599 5.792 15.5028 5.9375C15.7458 6.083 15.991 6.2545 16.2385 6.452L19.0885 5.26925L21.396 9.25L18.9173 11.123C18.9531 11.2845 18.9727 11.4355 18.976 11.576C18.9792 11.7163 18.9808 11.8577 18.9808 12C18.9808 12.1358 18.9775 12.274 18.971 12.4145C18.9647 12.5548 18.9417 12.7154 18.902 12.8963L21.3615 14.75L19.0538 18.75L16.2385 17.548C15.991 17.7455 15.7384 17.9202 15.4808 18.072C15.2231 18.224 14.959 18.3481 14.6885 18.4443L14.3078 21.5H9.69225ZM11 20H12.9655L13.325 17.3212C13.8353 17.1879 14.3017 16.9985 14.724 16.753C15.1465 16.5073 15.5539 16.1916 15.9463 15.8057L18.4308 16.85L19.4155 15.15L17.2463 13.5155C17.3296 13.2565 17.3863 13.0026 17.4163 12.7537C17.4464 12.5051 17.4615 12.2538 17.4615 12C17.4615 11.7397 17.4464 11.4884 17.4163 11.2463C17.3863 11.0039 17.3296 10.7564 17.2463 10.5038L19.4345 8.85L18.45 7.15L15.9365 8.2095C15.6018 7.85183 15.2009 7.53583 14.7338 7.2615C14.2664 6.98717 13.7937 6.79292 13.3155 6.67875L13 4H11.0155L10.6845 6.66925C10.1743 6.78975 9.70325 6.97433 9.27125 7.223C8.83909 7.47183 8.42684 7.79233 8.0345 8.1845L5.55 7.15L4.5655 8.85L6.725 10.4595C6.64167 10.6968 6.58334 10.9437 6.55 11.2C6.51667 11.4563 6.5 11.7262 6.5 12.0095C6.5 12.2698 6.51667 12.525 6.55 12.775C6.58334 13.025 6.6385 13.2718 6.7155 13.5155L4.5655 15.15L5.55 16.85L8.025 15.8C8.4045 16.1897 8.81025 16.5089 9.24225 16.7578C9.67442 17.0064 10.152 17.1974 10.675 17.3307L11 20ZM12.0115 15C12.8435 15 13.5515 14.708 14.1355 14.124C14.7195 13.54 15.0115 12.832 15.0115 12C15.0115 11.168 14.7195 10.46 14.1355 9.876C13.5515 9.292 12.8435 9 12.0115 9C11.1692 9 10.4586 9.292 9.87975 9.876C9.30092 10.46 9.0115 11.168 9.0115 12C9.0115 12.832 9.30092 13.54 9.87975 14.124C10.4586 14.708 11.1692 15 12.0115 15Z",
        fill: "currentColor",
      }),
    ),
    delete_big: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M7.30775 20.5C6.80908 20.5 6.38308 20.3234 6.02975 19.9702C5.67658 19.6169 5.5 19.1909 5.5 18.6922V5.99998H4.5V4.49998H9V3.61548H15V4.49998H19.5V5.99998H18.5V18.6922C18.5 19.1974 18.325 19.625 17.975 19.975C17.625 20.325 17.1974 20.5 16.6923 20.5H7.30775ZM17 5.99998H7V18.6922C7 18.7821 7.02883 18.8558 7.0865 18.9135C7.14417 18.9711 7.21792 19 7.30775 19H16.6923C16.7692 19 16.8398 18.9679 16.9038 18.9037C16.9679 18.8397 17 18.7692 17 18.6922V5.99998ZM9.404 17H10.9037V7.99998H9.404V17ZM13.0962 17H14.596V7.99998H13.0962V17Z",
        fill: "currentColor",
      }),
    ),
    delete_small: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M7.30775 20.5C6.80908 20.5 6.38308 20.3234 6.02975 19.9702C5.67658 19.6169 5.5 19.1909 5.5 18.6922V5.99998H4.5V4.49998H9V3.61548H15V4.49998H19.5V5.99998H18.5V18.6922C18.5 19.1974 18.325 19.625 17.975 19.975C17.625 20.325 17.1974 20.5 16.6923 20.5H7.30775ZM17 5.99998H7V18.6922C7 18.7821 7.02883 18.8558 7.0865 18.9135C7.14417 18.9711 7.21792 19 7.30775 19H16.6923C16.7692 19 16.8398 18.9679 16.9038 18.9037C16.9679 18.8397 17 18.7692 17 18.6922V5.99998ZM9.404 17H10.9037V7.99998H9.404V17ZM13.0962 17H14.596V7.99998H13.0962V17Z",
        fill: "currentColor",
      }),
    ),
    format_align_center: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M3.5 20.5V19H20.5V20.5H3.5ZM7.5 16.625V15.125H16.5V16.625H7.5ZM3.5 12.75V11.25H20.5V12.75H3.5ZM7.5 8.875V7.375H16.5V8.875H7.5ZM3.5 5V3.5H20.5V5H3.5Z",
        fill: "currentColor",
      }),
    ),
    format_align_left: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M3.5 20.5V19H20.5V20.5H3.5ZM3.5 16.625V15.125H14.5V16.625H3.5ZM3.5 12.75V11.25H20.5V12.75H3.5ZM3.5 8.875V7.375H14.5V8.875H3.5ZM3.5 5V3.5H20.5V5H3.5Z",
        fill: "currentColor",
      }),
    ),
    format_align_right: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M3.5 5V3.5H20.5V5H3.5ZM9.5 8.875V7.375H20.5V8.875H9.5ZM3.5 12.75V11.25H20.5V12.75H3.5ZM9.5 16.625V15.125H20.5V16.625H9.5ZM3.5 20.5V19H20.5V20.5H3.5Z",
        fill: "currentColor",
      }),
    ),
    add_row: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M4.025 10.2077C4.375 9.85775 4.80258 9.68275 5.30775 9.68275H6.5V11.1827H5.30775C5.21792 11.1827 5.14417 11.2116 5.0865 11.2693C5.02883 11.3269 5 11.4007 5 11.4905V16.1923C5 16.2821 5.02883 16.3558 5.0865 16.4135C5.14417 16.4712 5.21792 16.5 5.30775 16.5H18.6923C18.7821 16.5 18.8558 16.4712 18.9135 16.4135C18.9712 16.3558 19 16.2821 19 16.1923V11.4905C19 11.4007 18.9712 11.3269 18.9135 11.2693C18.8558 11.2116 18.7821 11.1827 18.6923 11.1827H17.6923V9.68275H18.6923C19.1974 9.68275 19.625 9.85775 19.975 10.2077C20.325 10.5577 20.5 10.9853 20.5 11.4905V16.1923C20.5 16.6974 20.325 17.125 19.975 17.475C19.625 17.825 19.1974 18 18.6923 18H5.30775C4.80258 18 4.375 17.825 4.025 17.475C3.675 17.125 3.5 16.6974 3.5 16.1923V11.4905C3.5 10.9853 3.675 10.5577 4.025 10.2077Z",
        fill: "currentColor",
      }),
      C.createElement("path", {
        d: "M11.3848 9.68275V7.5H12.8848V9.68275H15V11.1827H12.8848V13.2307H11.3848V11.1827H9.26925V9.68275H11.3848Z",
        fill: "currentColor",
      }),
    ),
    add_column: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M9.70775 4.025C9.35775 4.375 9.18275 4.80258 9.18275 5.30775V6.5H10.6827V5.30775C10.6827 5.21792 10.7116 5.14417 10.7693 5.0865C10.8269 5.02883 10.9007 5 10.9905 5H15.6923C15.7821 5 15.8558 5.02883 15.9135 5.0865C15.9712 5.14417 16 5.21792 16 5.30775V18.6923C16 18.7821 15.9712 18.8558 15.9135 18.9135C15.8558 18.9712 15.7821 19 15.6923 19H10.9905C10.9007 19 10.8269 18.9712 10.7693 18.9135C10.7116 18.8558 10.6827 18.7821 10.6827 18.6923V17.6923H9.18275V18.6923C9.18275 19.1974 9.35775 19.625 9.70775 19.975C10.0577 20.325 10.4853 20.5 10.9905 20.5H15.6923C16.1974 20.5 16.625 20.325 16.975 19.975C17.325 19.625 17.5 19.1974 17.5 18.6923V5.30775C17.5 4.80258 17.325 4.375 16.975 4.025C16.625 3.675 16.1974 3.5 15.6923 3.5H10.9905C10.4853 3.5 10.0577 3.675 9.70775 4.025Z",
        fill: "currentColor",
      }),
      C.createElement("path", {
        d: "M9.18275 11.3848H7V12.8848H9.18275V15H10.6827V12.8848H12.7307V11.3848H10.6827V9.26925H9.18275V11.3848Z",
        fill: "currentColor",
      }),
    ),
    insert_col_left: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M13.0001 20.1152H8.67713H8.75388H8.69238H13.0001ZM7.19238 19.8075C7.19238 20.3127 7.36738 20.7402 7.71738 21.0902C8.06738 21.4402 8.49497 21.6152 9.00013 21.6152H12.6924C13.1975 21.6152 13.6251 21.4402 13.9751 21.0902C14.3251 20.7402 14.5001 20.3127 14.5001 19.8075V10.423H13.0001V19.8075C13.0001 19.8973 12.9713 19.9711 12.9136 20.0287C12.856 20.0864 12.7822 20.1152 12.6924 20.1152H9.00013C8.9103 20.1152 8.83655 20.0864 8.77888 20.0287C8.72122 19.9711 8.69238 19.8973 8.69238 19.8075V4.69223C8.26422 4.74357 7.90722 4.93299 7.62138 5.26048C7.33538 5.58798 7.19238 5.97548 7.19238 6.42298V19.8075ZM13.0001 2.49998V4.61523H10.8846V6.11523H13.0001V8.23073H14.5001V6.11523H16.6154V4.61523H14.5001V2.49998H13.0001Z",
        fill: "currentColor",
      }),
    ),
    insert_row_above: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M20.1152 9.99987V14.3229V14.2461V14.3076V9.99987ZM19.8075 15.8076C20.3127 15.8076 20.7402 15.6326 21.0902 15.2826C21.4402 14.9326 21.6152 14.505 21.6152 13.9999V10.3076C21.6152 9.80245 21.4402 9.37487 21.0902 9.02487C20.7402 8.67487 20.3127 8.49987 19.8075 8.49987H10.423V9.99987H19.8075C19.8973 9.99987 19.9711 10.0287 20.0287 10.0864C20.0864 10.144 20.1152 10.2178 20.1152 10.3076V13.9999C20.1152 14.0897 20.0864 14.1635 20.0287 14.2211C19.9711 14.2788 19.8973 14.3076 19.8075 14.3076H4.69223C4.74357 14.7358 4.93299 15.0928 5.26048 15.3786C5.58798 15.6646 5.97548 15.8076 6.42298 15.8076H19.8075ZM2.49998 9.99987H4.61523V12.1154H6.11523V9.99987H8.23073V8.49987H6.11523V6.38462H4.61523V8.49987H2.49998V9.99987Z",
        fill: "currentColor",
      }),
    ),
    insert_row_below: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M20.1152 14.1924V9.86939V9.94614V9.88464V14.1924ZM19.8075 8.38464C20.3127 8.38464 20.7402 8.55964 21.0902 8.90964C21.4402 9.25964 21.6152 9.68723 21.6152 10.1924V13.8846C21.6152 14.3898 21.4402 14.8174 21.0902 15.1674C20.7402 15.5174 20.3127 15.6924 19.8075 15.6924H10.423V14.1924H19.8075C19.8973 14.1924 19.9711 14.1636 20.0287 14.1059C20.0864 14.0482 20.1152 13.9745 20.1152 13.8846V10.1924C20.1152 10.1026 20.0864 10.0288 20.0287 9.97114C19.9711 9.91348 19.8973 9.88464 19.8075 9.88464H4.69223C4.74357 9.45648 4.93299 9.09948 5.26048 8.81364C5.58798 8.52764 5.97548 8.38464 6.42298 8.38464H19.8075ZM2.49998 14.1924H4.61523V12.0769H6.11523V14.1924H8.23073V15.6924H6.11523V17.8076H4.61523V15.6924H2.49998V14.1924Z",
        fill: "currentColor",
      }),
    ),
    insert_col_right: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M10.8075 20.1152H15.1305H15.0537H15.1152H10.8075ZM16.6152 19.8075C16.6152 20.3127 16.4402 20.7402 16.0902 21.0902C15.7402 21.4402 15.3127 21.6152 14.8075 21.6152H11.1152C10.6101 21.6152 10.1825 21.4402 9.83248 21.0902C9.48248 20.7402 9.30748 20.3127 9.30748 19.8075V10.423H10.8075V19.8075C10.8075 19.8973 10.8363 19.9711 10.894 20.0287C10.9517 20.0864 11.0254 20.1152 11.1152 20.1152H14.8075C14.8973 20.1152 14.9711 20.0864 15.0287 20.0287C15.0864 19.9711 15.1152 19.8973 15.1152 19.8075V4.69223C15.5434 4.74357 15.9004 4.93299 16.1862 5.26048C16.4722 5.58798 16.6152 5.97548 16.6152 6.42298V19.8075ZM10.8075 2.49998V4.61523H12.923V6.11523H10.8075V8.23073H9.30748V6.11523H7.19223V4.61523H9.30748V2.49998H10.8075Z",
        fill: "currentColor",
      }),
    ),
    check: C.createElement(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      C.createElement("path", {
        d: "M9.54983 17.6537L4.21533 12.3192L5.28433 11.25L9.54983 15.5155L18.7153 6.34998L19.7843 7.41923L9.54983 17.6537Z",
        fill: "currentColor",
      }),
    ),
  };
function Uc(e, t) {
  return (
    (Uc = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function (n, r) {
          return (n.__proto__ = r), n;
        }),
    Uc(e, t)
  );
}
var Hg = { error: null },
  Y7 = (function (e) {
    var t, n;
    function r() {
      for (var o, s = arguments.length, l = new Array(s), a = 0; a < s; a++) l[a] = arguments[a];
      return (
        ((o = e.call.apply(e, [this].concat(l)) || this).state = Hg),
        (o.resetErrorBoundary = function () {
          for (var u, c = arguments.length, d = new Array(c), f = 0; f < c; f++) d[f] = arguments[f];
          o.props.onReset == null || (u = o.props).onReset.apply(u, d), o.reset();
        }),
        o
      );
    }
    (n = e),
      ((t = r).prototype = Object.create(n.prototype)),
      (t.prototype.constructor = t),
      Uc(t, n),
      (r.getDerivedStateFromError = function (o) {
        return { error: o };
      });
    var i = r.prototype;
    return (
      (i.reset = function () {
        this.setState(Hg);
      }),
      (i.componentDidCatch = function (o, s) {
        var l, a;
        (l = (a = this.props).onError) == null || l.call(a, o, s);
      }),
      (i.componentDidUpdate = function (o, s) {
        var l,
          a,
          u,
          c,
          d = this.state.error,
          f = this.props.resetKeys;
        d !== null &&
          s.error !== null &&
          ((u = o.resetKeys) === void 0 && (u = []),
          (c = f) === void 0 && (c = []),
          u.length !== c.length ||
            u.some(function (h, p) {
              return !Object.is(h, c[p]);
            })) &&
          ((l = (a = this.props).onResetKeysChange) == null || l.call(a, o.resetKeys, f), this.reset());
      }),
      (i.render = function () {
        var o = this.state.error,
          s = this.props,
          l = s.fallbackRender,
          a = s.FallbackComponent,
          u = s.fallback;
        if (o !== null) {
          var c = { error: o, resetErrorBoundary: this.resetErrorBoundary };
          if (E.isValidElement(u)) return u;
          if (typeof l == "function") return l(c);
          if (a) return E.createElement(a, c);
          throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
        }
        return this.props.children;
      }),
      r
    );
  })(E.Component);
function Df({ children: e, onError: t }) {
  return O.jsx(Y7, {
    fallback: O.jsx("div", {
      style: { border: "1px solid #f00", color: "#f00", padding: "8px" },
      children: "An error was thrown.",
    }),
    onError: t,
    children: e,
  });
}
const X7 = ({ children: e }) => {
    const t = qe(Ht),
      n = C.useMemo(() => [t, L1(null, ka)], [t]);
    return C.createElement(al.Provider, { value: n }, e);
  },
  Q7 = () => {
    const e = Fe(),
      t = Ie(W3),
      n = (c) => {
        t({ current: c });
      },
      [r, i, o, s, l, a, u] = Le(Pc, Dc, Kx, Jx, Zx, $c, Gx);
    return C.createElement(
      C.Fragment,
      null,
      s.map((c, d) => C.createElement(c, { key: d })),
      C.createElement(
        rv,
        { wrappers: l },
        C.createElement(
          "div",
          { className: we(D.rootContentEditableWrapper, "mdxeditor-root-contenteditable") },
          C.createElement(Pf, {
            contentEditable: C.createElement(
              "div",
              { ref: n },
              C.createElement(Rf, {
                className: we(D.contentEditable, r),
                ariaLabel: e("contentArea.editableMarkdown", "editable markdown"),
                spellCheck: i,
              }),
            ),
            placeholder: C.createElement(
              "div",
              { className: we(D.contentEditable, D.placeholder, r) },
              C.createElement("p", null, a),
            ),
            ErrorBoundary: Df,
          }),
        ),
      ),
      o.map((c, d) => C.createElement(c, { key: d })),
      u.map((c, d) => C.createElement(c, { key: d })),
    );
  },
  e6 = { listItemIndent: "one" },
  t6 = (e) => q7[e];
function n6(e, t, n = {}) {
  let r = t;
  for (const [i, o] of Object.entries(n)) r = r.replaceAll(`{{${i}}}`, String(o));
  return r;
}
const rv = ({ wrappers: e, children: t }) => {
    if (e.length === 0) return C.createElement(C.Fragment, null, t);
    const n = e[0];
    return C.createElement(n, null, C.createElement(rv, { wrappers: e.slice(1) }, t));
  },
  r6 = ({ children: e, className: t, overlayContainer: n }) => {
    const r = C.useRef(null),
      i = Ie(wr);
    return (
      C.useEffect(() => {
        const o = document.createElement("div");
        return (
          o.classList.add(
            "mdxeditor-popup-container",
            D.editorRoot,
            D.popupContainer,
            ...(t ?? "").trim().split(" ").filter(Boolean),
          ),
          (n ?? document.body).appendChild(o),
          (r.current = o),
          i(r),
          () => {
            o.remove();
          }
        );
      }, [t, r, n, i]),
      C.createElement("div", { className: we("mdxeditor", D.editorRoot, D.editorWrapper, t) }, e)
    );
  },
  i6 = ({ mdxRef: e }) => {
    const t = Gi();
    return (
      C.useImperativeHandle(
        e,
        () => ({
          getMarkdown: () => {
            const n = t.getValue(mr);
            return n === "source" || n === "diff" ? t.getValue(zi) : t.getValue(In);
          },
          setMarkdown: (n) => {
            t.pub(Mf, n);
          },
          insertMarkdown: (n) => {
            t.pub(Vx, n);
          },
          focus: (n, r) => {
            var i;
            (i = t.getValue(Ht)) == null || i.focus(n, r);
          },
        }),
        [t],
      ),
      null
    );
  },
  o6 = C.forwardRef((e, t) =>
    C.createElement(
      PC,
      {
        plugins: [
          q3({
            contentEditableClassName: e.contentEditableClassName ?? "",
            spellCheck: e.spellCheck ?? !0,
            initialMarkdown: e.markdown,
            onChange: e.onChange ?? Pr,
            onBlur: e.onBlur ?? Pr,
            toMarkdownOptions: e.toMarkdownOptions ?? e6,
            autoFocus: e.autoFocus ?? !1,
            placeholder: e.placeholder ?? "",
            readOnly: !!e.readOnly,
            iconComponentFor: e.iconComponentFor ?? t6,
            suppressHtmlProcessing: e.suppressHtmlProcessing ?? !1,
            onError: e.onError ?? Pr,
            translation: e.translation ?? n6,
            trim: e.trim ?? !0,
            lexicalTheme: e.lexicalTheme,
          }),
          ...(e.plugins ?? []),
        ],
      },
      C.createElement(
        r6,
        { className: e.className, overlayContainer: e.overlayContainer },
        C.createElement(X7, null, C.createElement(Q7, null)),
      ),
      C.createElement(i6, { mdxRef: t }),
    ),
  ),
  iv = typeof window < "u" && typeof window.document.createElement < "u",
  Ml = iv && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
function s6(e, t) {
  return Ml ? e : t;
}
const l6 = {
    testLexicalNode: ba,
    visitLexicalNode: ({ lexicalNode: e, actions: t }) => {
      const n = parseInt(e.getTag()[1], 10);
      t.addAndStepInto("heading", { depth: n });
    },
  },
  a6 = {
    testNode: "heading",
    visitNode: function ({ mdastNode: e, actions: t }) {
      t.addAndStepInto(wn(`h${e.depth}`));
    },
  },
  u6 = [48, 49, 50, 51, 52, 53, 54],
  ov = [1, 2, 3, 4, 5, 6],
  c6 = { 49: 1, 50: 2, 51: 3, 52: 4, 53: 5, 54: 6 },
  Oa = ne(ov, (e) => {
    e.pub(La, (t) =>
      t.registerCommand(
        Hd,
        (n) => {
          const { keyCode: r, ctrlKey: i, metaKey: o, altKey: s } = n;
          return u6.includes(r) && s6(o, i) && s
            ? (n.preventDefault(),
              t.update(() => {
                if (r === 48) e.pub(Nl, () => Se());
                else {
                  const l = e.getValue(Oa),
                    a = c6[r];
                  l.includes(a) || e.pub(Nl, () => wn(`h${a}`));
                }
              }),
              !0)
            : !1;
        },
        He,
      ),
    );
  }),
  d6 = vt({
    init(e) {
      e.pubIn({ [ro]: "headings", [Gt]: a6, [fn]: ms, [hn]: l6 });
    },
    update(e, t) {
      e.pub(Oa, (t == null ? void 0 : t.allowedHeadingLevels) ?? ov);
    },
  });
function Vg(e, t) {
  return e.getEditorState().read(() => {
    const n = Oe(t);
    return n !== null && n.isSelected();
  });
}
function sv(e) {
  const [t] = bt(),
    [n, r] = E.useState(() => Vg(t, e));
  return (
    E.useEffect(() => {
      let i = !0;
      const o = t.registerUpdateListener(() => {
        i && r(Vg(t, e));
      });
      return () => {
        (i = !1), o();
      };
    }, [t, e]),
    [
      n,
      E.useCallback(
        (i) => {
          t.update(() => {
            let o = J();
            Je(o) || ((o = qd()), Ye(o)), Je(o) && (i ? o.add(e) : o.delete(e));
          });
        },
        [t, e],
      ),
      E.useCallback(() => {
        t.update(() => {
          const i = J();
          Je(i) && i.clear();
        });
      }, [t]),
    ]
  );
}
const lv = ae("INSERT_HORIZONTAL_RULE_COMMAND");
function f6({ nodeKey: e }) {
  const [t] = bt(),
    [n, r, i] = sv(e);
  return (
    E.useEffect(
      () =>
        yt(
          t.registerCommand(
            Ql,
            (o) => {
              const s = t.getElementByKey(e);
              return o.target === s && (o.shiftKey || i(), r(!n), !0);
            },
            He,
          ),
        ),
      [i, t, n, e, r],
    ),
    E.useEffect(() => {
      const o = t.getElementByKey(e),
        s = t._config.theme.hrSelected ?? "selected";
      o !== null && (n ? un(o, s) : va(o, s));
    }, [t, n, e]),
    null
  );
}
let bs = class av extends Cr {
  static getType() {
    return "horizontalrule";
  }
  static clone(t) {
    return new av(t.__key);
  }
  static importJSON(t) {
    return io().updateFromJSON(t);
  }
  static importDOM() {
    return { hr: () => ({ conversion: h6, priority: 0 }) };
  }
  exportDOM() {
    return { element: document.createElement("hr") };
  }
  createDOM(t) {
    const n = document.createElement("hr");
    return un(n, t.theme.hr), n;
  }
  getTextContent() {
    return `
`;
  }
  isInline() {
    return !1;
  }
  updateDOM() {
    return !1;
  }
  decorate() {
    return O.jsx(f6, { nodeKey: this.__key });
  }
};
function h6() {
  return { node: io() };
}
function io() {
  return Mt(new bs());
}
function $f(e) {
  return e instanceof bs;
}
function p6() {
  const [e] = bt();
  return (
    E.useEffect(
      () =>
        e.registerCommand(
          lv,
          (t) => {
            const n = J();
            if (!H(n)) return !1;
            if (n.focus.getNode() !== null) {
              const r = io();
              j0(r);
            }
            return !0;
          },
          be,
        ),
      [e],
    ),
    null
  );
}
const g6 = {
    testLexicalNode: $f,
    visitLexicalNode({ actions: e }) {
      e.addAndStepInto("thematicBreak");
    },
  },
  m6 = {
    testNode: "thematicBreak",
    visitNode({ actions: e }) {
      e.addAndStepInto(io());
    },
  },
  uv = Nn((e) => {
    e.sub(e.pipe(uv, Ve(je)), ([, t]) => {
      t == null || t.dispatchCommand(lv, void 0);
    });
  }),
  x6 = vt({
    init(e) {
      e.pubIn({ [ro]: "thematicBreak", [Gt]: m6, [fn]: bs, [hn]: g6, [ai]: p6 });
    },
  });
function yn(e, ...t) {
  const n = new URL("https://lexical.dev/docs/error"),
    r = new URLSearchParams();
  r.append("code", e);
  for (const i of t) r.append("v", i);
  throw (
    ((n.search = r.toString()),
    Error(
      `Minified Lexical error #${e}; visit ${n.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`,
    ))
  );
}
function Yo(e) {
  let t = 1,
    n = e.getParent();
  for (; n != null; ) {
    if (xe(n)) {
      const r = n.getParent();
      if (ue(r)) {
        t++, (n = r.getParent());
        continue;
      }
      yn(40);
    }
    return t;
  }
  return t;
}
function Wc(e) {
  let t = e.getParent();
  ue(t) || yn(40);
  let n = t;
  for (; n !== null; ) (n = n.getParent()), ue(n) && (t = n);
  return t;
}
function cv(e) {
  let t = [];
  const n = e.getChildren().filter(xe);
  for (let r = 0; r < n.length; r++) {
    const i = n[r],
      o = i.getFirstChild();
    ue(o) ? (t = t.concat(cv(o))) : t.push(i);
  }
  return t;
}
function Cn(e) {
  return xe(e) && ue(e.getFirstChild());
}
function zg(e) {
  return mt().append(e);
}
function dv(e, t) {
  return xe(e) && (t.length === 0 || (t.length === 1 && e.is(t[0]) && e.getChildrenSize() === 0));
}
function Kc(e) {
  const t = J();
  if (t !== null) {
    let n = t.getNodes();
    if (H(t)) {
      const i = t.getStartEndPoints();
      i === null && yn(143);
      const [o] = i,
        s = o.getNode(),
        l = s.getParent();
      if (tt(s)) {
        const a = s.getFirstChild();
        if (a) n = a.selectStart().getNodes();
        else {
          const u = Se();
          s.append(u), (n = u.select().getNodes());
        }
      } else if (dv(s, n)) {
        const a = gt(e);
        if (tt(l)) {
          s.replace(a);
          const u = mt();
          P(s) && (u.setFormat(s.getFormatType()), u.setIndent(s.getIndent())), a.append(u);
        } else if (xe(s)) {
          const u = s.getParentOrThrow();
          ei(a, u.getChildren()), u.replace(a);
        }
        return;
      }
    }
    const r = new Set();
    for (let i = 0; i < n.length; i++) {
      const o = n[i];
      if (P(o) && o.isEmpty() && !xe(o) && !r.has(o.getKey())) {
        jg(o, e);
        continue;
      }
      let s = x0(o) ? o.getParent() : xe(o) && o.isEmpty() ? o : null;
      for (; s != null; ) {
        const l = s.getKey();
        if (ue(s)) {
          if (!r.has(l)) {
            const a = gt(e);
            ei(a, s.getChildren()), s.replace(a), r.add(l);
          }
          break;
        }
        {
          const a = s.getParent();
          if (tt(a) && !r.has(l)) {
            r.add(l), jg(s, e);
            break;
          }
          s = a;
        }
      }
    }
  }
}
function ei(e, t) {
  e.splice(e.getChildrenSize(), 0, t);
}
function jg(e, t) {
  if (ue(e)) return e;
  const n = e.getPreviousSibling(),
    r = e.getNextSibling(),
    i = mt();
  let o;
  if ((ei(i, e.getChildren()), ue(n) && t === n.getListType()))
    n.append(i), ue(r) && t === r.getListType() && (ei(n, r.getChildren()), r.remove()), (o = n);
  else if (ue(r) && t === r.getListType()) r.getFirstChildOrThrow().insertBefore(i), (o = r);
  else {
    const s = gt(t);
    s.append(i), e.replace(s), (o = s);
  }
  return i.setFormat(e.getFormatType()), i.setIndent(e.getIndent()), e.remove(), o;
}
function Bf(e, t) {
  const n = e.getLastChild(),
    r = t.getFirstChild();
  n && r && Cn(n) && Cn(r) && (Bf(n.getFirstChild(), r.getFirstChild()), r.remove());
  const i = t.getChildren();
  i.length > 0 && e.append(...i), t.remove();
}
function v6() {
  const e = J();
  if (H(e)) {
    const t = new Set(),
      n = e.getNodes(),
      r = e.anchor.getNode();
    if (dv(r, n)) t.add(Wc(r));
    else
      for (let i = 0; i < n.length; i++) {
        const o = n[i];
        if (x0(o)) {
          const s = z0(o, nr);
          s != null && t.add(Wc(s));
        }
      }
    for (const i of t) {
      let o = i;
      const s = cv(i);
      for (const l of s) {
        const a = Se().setTextStyle(e.style).setTextFormat(e.format);
        ei(a, l.getChildren()),
          o.insertAfter(a),
          (o = a),
          l.__key === e.anchor.key && Xr(e.anchor, Pt(an(a, "next"))),
          l.__key === e.focus.key && Xr(e.focus, Pt(an(a, "next"))),
          l.remove();
      }
      i.remove();
    }
  }
}
function b6(e) {
  const t = new Set();
  if (Cn(e) || t.has(e.getKey())) return;
  const n = e.getParent(),
    r = e.getNextSibling(),
    i = e.getPreviousSibling();
  if (Cn(r) && Cn(i)) {
    const o = i.getFirstChild();
    if (ue(o)) {
      o.append(e);
      const s = r.getFirstChild();
      ue(s) && (ei(o, s.getChildren()), r.remove(), t.add(r.getKey()));
    }
  } else if (Cn(r)) {
    const o = r.getFirstChild();
    if (ue(o)) {
      const s = o.getFirstChild();
      s !== null && s.insertBefore(e);
    }
  } else if (Cn(i)) {
    const o = i.getFirstChild();
    ue(o) && o.append(e);
  } else if (ue(n)) {
    const o = mt().setTextFormat(e.getTextFormat()).setTextStyle(e.getTextStyle()),
      s = gt(n.getListType()).setTextFormat(n.getTextFormat()).setTextStyle(n.getTextStyle());
    o.append(s), s.append(e), i ? i.insertAfter(o) : r ? r.insertBefore(o) : n.append(o);
  }
}
function y6(e) {
  if (Cn(e)) return;
  const t = e.getParent(),
    n = t ? t.getParent() : void 0;
  if (ue(n ? n.getParent() : void 0) && xe(n) && ue(t)) {
    const r = t ? t.getFirstChild() : void 0,
      i = t ? t.getLastChild() : void 0;
    if (e.is(r)) n.insertBefore(e), t.isEmpty() && n.remove();
    else if (e.is(i)) n.insertAfter(e), t.isEmpty() && n.remove();
    else {
      const o = t.getListType(),
        s = mt(),
        l = gt(o);
      s.append(l), e.getPreviousSiblings().forEach((c) => l.append(c));
      const a = mt(),
        u = gt(o);
      a.append(u), ei(u, e.getNextSiblings()), n.insertBefore(s), n.insertAfter(a), n.replace(e);
    }
  }
}
function C6() {
  const e = J();
  if (!H(e) || !e.isCollapsed()) return !1;
  const t = e.anchor.getNode();
  if (!xe(t) || t.getChildrenSize() !== 0) return !1;
  const n = Wc(t),
    r = t.getParent();
  ue(r) || yn(40);
  const i = r.getParent();
  let o;
  if (tt(i)) (o = Se()), n.insertAfter(o);
  else {
    if (!xe(i)) return !1;
    (o = mt()), i.insertAfter(o);
  }
  o.setTextStyle(e.style).setTextFormat(e.format).select();
  const s = t.getNextSiblings();
  if (s.length > 0) {
    const l = gt(r.getListType());
    if (xe(o)) {
      const a = mt();
      a.append(l), o.insertAfter(a);
    } else o.insertAfter(l);
    l.append(...s);
  }
  return (
    (function (l) {
      let a = l;
      for (; a.getNextSibling() == null && a.getPreviousSibling() == null; ) {
        const u = a.getParent();
        if (u == null || (!xe(u) && !ue(u))) break;
        a = u;
      }
      a.remove();
    })(t),
    !0
  );
}
function Ol(...e) {
  const t = [];
  for (const n of e) if (n && typeof n == "string") for (const [r] of n.matchAll(/\S+/g)) t.push(r);
  return t;
}
let nr = class fv extends dn {
  static getType() {
    return "listitem";
  }
  static clone(t) {
    return new fv(t.__value, t.__checked, t.__key);
  }
  constructor(t, n, r) {
    super(r), (this.__value = t === void 0 ? 1 : t), (this.__checked = n);
  }
  createDOM(t) {
    const n = document.createElement("li");
    return this.updateListItemDOM(null, n, t), n;
  }
  updateListItemDOM(t, n, r) {
    const i = this.getParent();
    ue(i) &&
      i.getListType() === "check" &&
      (function (l, a, u, c) {
        ue(a.getFirstChild())
          ? (l.removeAttribute("role"), l.removeAttribute("tabIndex"), l.removeAttribute("aria-checked"))
          : (l.setAttribute("role", "checkbox"),
            l.setAttribute("tabIndex", "-1"),
            (u && a.__checked === u.__checked) || l.setAttribute("aria-checked", a.getChecked() ? "true" : "false"));
      })(n, this, t),
      (n.value = this.__value),
      (function (l, a, u) {
        const c = [],
          d = [],
          f = a.list,
          h = f ? f.listitem : void 0;
        let p;
        if ((f && f.nested && (p = f.nested.listitem), h !== void 0 && c.push(...Ol(h)), f)) {
          const g = u.getParent(),
            x = ue(g) && g.getListType() === "check",
            b = u.getChecked();
          (x && !b) || d.push(f.listitemUnchecked),
            (x && b) || d.push(f.listitemChecked),
            x && c.push(b ? f.listitemChecked : f.listitemUnchecked);
        }
        if (p !== void 0) {
          const g = Ol(p);
          u.getChildren().some((x) => ue(x)) ? c.push(...g) : d.push(...g);
        }
        d.length > 0 && va(l, ...d), c.length > 0 && un(l, ...c);
      })(n, r.theme, this);
    const o = t ? t.__style : "",
      s = this.__style;
    o !== s && (s === "" ? n.removeAttribute("style") : (n.style.cssText = s)),
      (function (l, a, u) {
        const c = zp(a.__textStyle);
        for (const d in c) l.style.setProperty(`--listitem-marker-${d}`, c[d]);
        if (u) for (const d in zp(u.__textStyle)) d in c || l.style.removeProperty(`--listitem-marker-${d}`);
      })(n, this, t);
  }
  updateDOM(t, n, r) {
    const i = n;
    return this.updateListItemDOM(t, i, r), !1;
  }
  static transform() {
    return (t) => {
      if ((xe(t) || yn(144), t.__checked == null)) return;
      const n = t.getParent();
      ue(n) && n.getListType() !== "check" && t.getChecked() != null && t.setChecked(void 0);
    };
  }
  static importDOM() {
    return { li: () => ({ conversion: _6, priority: 0 }) };
  }
  static importJSON(t) {
    return mt().updateFromJSON(t);
  }
  updateFromJSON(t) {
    return super.updateFromJSON(t).setValue(t.value).setChecked(t.checked);
  }
  exportDOM(t) {
    const n = this.createDOM(t._config),
      r = this.getFormatType();
    r && (n.style.textAlign = r);
    const i = this.getDirection();
    return i && (n.dir = i), { element: n };
  }
  exportJSON() {
    return { ...super.exportJSON(), checked: this.getChecked(), value: this.getValue() };
  }
  append(...t) {
    for (let n = 0; n < t.length; n++) {
      const r = t[n];
      if (P(r) && this.canMergeWith(r)) {
        const i = r.getChildren();
        this.append(...i), r.remove();
      } else super.append(r);
    }
    return this;
  }
  replace(t, n) {
    if (xe(t)) return super.replace(t);
    this.setIndent(0);
    const r = this.getParentOrThrow();
    if (!ue(r)) return t;
    if (r.__first === this.getKey()) r.insertBefore(t);
    else if (r.__last === this.getKey()) r.insertAfter(t);
    else {
      const i = gt(r.getListType());
      let o = this.getNextSibling();
      for (; o; ) {
        const s = o;
        (o = o.getNextSibling()), i.append(s);
      }
      r.insertAfter(t), t.insertAfter(i);
    }
    return (
      n &&
        (P(t) || yn(139),
        this.getChildren().forEach((i) => {
          t.append(i);
        })),
      this.remove(),
      r.getChildrenSize() === 0 && r.remove(),
      t
    );
  }
  insertAfter(t, n = !0) {
    const r = this.getParentOrThrow();
    if ((ue(r) || yn(39), xe(t))) return super.insertAfter(t, n);
    const i = this.getNextSiblings();
    if ((r.insertAfter(t, n), i.length !== 0)) {
      const o = gt(r.getListType());
      i.forEach((s) => o.append(s)), t.insertAfter(o, n);
    }
    return t;
  }
  remove(t) {
    const n = this.getPreviousSibling(),
      r = this.getNextSibling();
    super.remove(t), n && r && Cn(n) && Cn(r) && (Bf(n.getFirstChild(), r.getFirstChild()), r.remove());
  }
  insertNewAfter(t, n = !0) {
    const r = mt()
      .updateFromJSON(this.exportJSON())
      .setChecked(!this.getChecked() && void 0);
    return this.insertAfter(r, n), r;
  }
  collapseAtStart(t) {
    const n = Se();
    this.getChildren().forEach((s) => n.append(s));
    const r = this.getParentOrThrow(),
      i = r.getParentOrThrow(),
      o = xe(i);
    if (r.getChildrenSize() === 1)
      if (o) r.remove(), i.select();
      else {
        r.insertBefore(n), r.remove();
        const s = t.anchor,
          l = t.focus,
          a = n.getKey();
        s.type === "element" && s.getNode().is(this) && s.set(a, s.offset, "element"),
          l.type === "element" && l.getNode().is(this) && l.set(a, l.offset, "element");
      }
    else r.insertBefore(n), this.remove();
    return !0;
  }
  getValue() {
    return this.getLatest().__value;
  }
  setValue(t) {
    const n = this.getWritable();
    return (n.__value = t), n;
  }
  getChecked() {
    const t = this.getLatest();
    let n;
    const r = this.getParent();
    return ue(r) && (n = r.getListType()), n === "check" ? !!t.__checked : void 0;
  }
  setChecked(t) {
    const n = this.getWritable();
    return (n.__checked = t), n;
  }
  toggleChecked() {
    const t = this.getWritable();
    return t.setChecked(!t.__checked);
  }
  getIndent() {
    const t = this.getParent();
    if (t === null || !this.isAttached()) return this.getLatest().__indent;
    let n = t.getParentOrThrow(),
      r = 0;
    for (; xe(n); ) (n = n.getParentOrThrow().getParentOrThrow()), r++;
    return r;
  }
  setIndent(t) {
    typeof t != "number" && yn(117), (t = Math.floor(t)) >= 0 || yn(199);
    let n = this.getIndent();
    for (; n !== t; ) n < t ? (b6(this), n++) : (y6(this), n--);
    return this;
  }
  canInsertAfter(t) {
    return xe(t);
  }
  canReplaceWith(t) {
    return xe(t);
  }
  canMergeWith(t) {
    return xe(t) || nf(t);
  }
  extractWithChild(t, n) {
    if (!H(n)) return !1;
    const r = n.anchor.getNode(),
      i = n.focus.getNode();
    return this.isParentOf(r) && this.isParentOf(i) && this.getTextContent().length === n.getTextContent().length;
  }
  isParentRequired() {
    return !0;
  }
  createParentElementNode() {
    return gt("bullet");
  }
  canMergeWhenEmpty() {
    return !0;
  }
};
function _6(e) {
  if (e.classList.contains("task-list-item")) {
    for (const n of e.children) if (n.tagName === "INPUT") return w6(n);
  }
  const t = e.getAttribute("aria-checked");
  return { node: mt(t === "true" || (t !== "false" && void 0)) };
}
function w6(e) {
  return e.getAttribute("type") !== "checkbox" ? { node: null } : { node: mt(e.hasAttribute("checked")) };
}
function mt(e) {
  return Mt(new nr(void 0, e));
}
function xe(e) {
  return e instanceof nr;
}
let rr = class hv extends dn {
  static getType() {
    return "list";
  }
  static clone(t) {
    const n = t.__listType || Kg[t.__tag];
    return new hv(n, t.__start, t.__key);
  }
  constructor(t = "number", n = 1, r) {
    super(r);
    const i = Kg[t] || t;
    (this.__listType = i), (this.__tag = i === "number" ? "ol" : "ul"), (this.__start = n);
  }
  getTag() {
    return this.__tag;
  }
  setListType(t) {
    const n = this.getWritable();
    return (n.__listType = t), (n.__tag = t === "number" ? "ol" : "ul"), n;
  }
  getListType() {
    return this.__listType;
  }
  getStart() {
    return this.__start;
  }
  setStart(t) {
    const n = this.getWritable();
    return (n.__start = t), n;
  }
  createDOM(t, n) {
    const r = this.__tag,
      i = document.createElement(r);
    return (
      this.__start !== 1 && i.setAttribute("start", String(this.__start)),
      (i.__lexicalListType = this.__listType),
      Ug(i, t.theme, this),
      i
    );
  }
  updateDOM(t, n, r) {
    return t.__tag !== this.__tag || (Ug(n, r.theme, this), !1);
  }
  static transform() {
    return (t) => {
      ue(t) || yn(163),
        (function (n) {
          const r = n.getNextSibling();
          ue(r) && n.getListType() === r.getListType() && Bf(n, r);
        })(t),
        (function (n) {
          const r = n.getListType() !== "check";
          let i = n.getStart();
          for (const o of n.getChildren())
            xe(o) &&
              (o.getValue() !== i && o.setValue(i),
              r && o.getLatest().__checked != null && o.setChecked(void 0),
              ue(o.getFirstChild()) || i++);
        })(t);
    };
  }
  static importDOM() {
    return { ol: () => ({ conversion: Wg, priority: 0 }), ul: () => ({ conversion: Wg, priority: 0 }) };
  }
  static importJSON(t) {
    return gt().updateFromJSON(t);
  }
  updateFromJSON(t) {
    return super.updateFromJSON(t).setListType(t.listType).setStart(t.start);
  }
  exportDOM(t) {
    const n = this.createDOM(t._config, t);
    return (
      We(n) &&
        (this.__start !== 1 && n.setAttribute("start", String(this.__start)),
        this.__listType === "check" && n.setAttribute("__lexicalListType", "check")),
      { element: n }
    );
  }
  exportJSON() {
    return { ...super.exportJSON(), listType: this.getListType(), start: this.getStart(), tag: this.getTag() };
  }
  canBeEmpty() {
    return !1;
  }
  canIndent() {
    return !1;
  }
  splice(t, n, r) {
    let i = r;
    for (let o = 0; o < r.length; o++) {
      const s = r[o];
      xe(s) ||
        (i === r && (i = [...r]), (i[o] = mt().append(!P(s) || ue(s) || s.isInline() ? s : Be(s.getTextContent()))));
    }
    return super.splice(t, n, i);
  }
  extractWithChild(t) {
    return xe(t);
  }
};
function Ug(e, t, n) {
  const r = [],
    i = [],
    o = t.list;
  if (o !== void 0) {
    const s = o[`${n.__tag}Depth`] || [],
      l = Yo(n) - 1,
      a = l % s.length,
      u = s[a],
      c = o[n.__tag];
    let d;
    const f = o.nested,
      h = o.checklist;
    if (
      (f !== void 0 && f.list && (d = f.list),
      c !== void 0 && r.push(c),
      h !== void 0 && n.__listType === "check" && r.push(h),
      u !== void 0)
    ) {
      r.push(...Ol(u));
      for (let p = 0; p < s.length; p++) p !== a && i.push(n.__tag + p);
    }
    if (d !== void 0) {
      const p = Ol(d);
      l > 1 ? r.push(...p) : i.push(...p);
    }
  }
  i.length > 0 && va(e, ...i), r.length > 0 && un(e, ...r);
}
function E6(e) {
  const t = [];
  for (let n = 0; n < e.length; n++) {
    const r = e[n];
    if (xe(r)) {
      t.push(r);
      const i = r.getChildren();
      i.length > 1 &&
        i.forEach((o) => {
          ue(o) && t.push(zg(o));
        });
    } else t.push(zg(r));
  }
  return t;
}
function Wg(e) {
  const t = e.nodeName.toLowerCase();
  let n = null;
  return (
    t === "ol"
      ? (n = gt("number", e.start))
      : t === "ul" &&
        (n = (function (r) {
          if (r.getAttribute("__lexicallisttype") === "check" || r.classList.contains("contains-task-list")) return !0;
          for (const i of r.childNodes) if (We(i) && i.hasAttribute("aria-checked")) return !0;
          return !1;
        })(e)
          ? gt("check")
          : gt("bullet")),
    { after: E6, node: n }
  );
}
const Kg = { ol: "number", ul: "bullet" };
function gt(e = "number", t = 1) {
  return Mt(new rr(e, t));
}
function ue(e) {
  return e instanceof rr;
}
const pv = ae("INSERT_CHECK_LIST_COMMAND");
function k6(e) {
  return yt(
    e.registerCommand(pv, () => (Kc("check"), !0), He),
    e.registerCommand(jd, (t) => Zg(t, e, !1), He),
    e.registerCommand(zd, (t) => Zg(t, e, !0), He),
    e.registerCommand(
      ls,
      () => {
        if (Jc() != null) {
          const t = e.getRootElement();
          return t != null && t.focus(), !0;
        }
        return !1;
      },
      He,
    ),
    e.registerCommand(
      Ud,
      (t) => {
        const n = Jc();
        return (
          !(n == null || !e.isEditable()) &&
          (e.update(() => {
            const r = An(n);
            xe(r) && (t.preventDefault(), r.toggleChecked());
          }),
          !0)
        );
      },
      He,
    ),
    e.registerCommand(
      Vd,
      (t) =>
        e.getEditorState().read(() => {
          const n = J();
          if (H(n) && n.isCollapsed()) {
            const { anchor: r } = n,
              i = r.type === "element";
            if (i || r.offset === 0) {
              const o = r.getNode(),
                s = on(o, (l) => P(l) && !l.isInline());
              if (xe(s)) {
                const l = s.getParent();
                if (ue(l) && l.getListType() === "check" && (i || s.getFirstDescendant() === o)) {
                  const a = e.getElementByKey(s.__key);
                  if (a != null && document.activeElement !== a) return a.focus(), t.preventDefault(), !0;
                }
              }
            }
          }
          return !1;
        }),
      He,
    ),
    e.registerRootListener((t, n) => {
      t !== null && (t.addEventListener("click", Jg), t.addEventListener("pointerdown", Gg)),
        n !== null && (n.removeEventListener("click", Jg), n.removeEventListener("pointerdown", Gg));
    }),
  );
}
function gv(e, t) {
  const n = e.target;
  if (!We(n)) return;
  const r = n.firstChild;
  if (We(r) && (r.tagName === "UL" || r.tagName === "OL")) return;
  const i = n.parentNode;
  if (!i || i.__lexicalListType !== "check") return;
  const o = n.getBoundingClientRect(),
    s = e.pageX / yw(n),
    l = window.getComputedStyle ? window.getComputedStyle(n, "::before") : { width: "0px" },
    a = parseFloat(l.width);
  (n.dir === "rtl" ? s < o.right && s > o.right - a : s > o.left && s < o.left + a) && t();
}
function Jg(e) {
  gv(e, () => {
    if (We(e.target)) {
      const t = e.target,
        n = lf(t);
      n != null &&
        n.isEditable() &&
        n.update(() => {
          const r = An(t);
          xe(r) && (t.focus(), r.toggleChecked());
        });
    }
  });
}
function Gg(e) {
  gv(e, () => {
    e.preventDefault();
  });
}
function Jc() {
  const e = document.activeElement;
  return We(e) && e.tagName === "LI" && e.parentNode != null && e.parentNode.__lexicalListType === "check" ? e : null;
}
function Zg(e, t, n) {
  const r = Jc();
  return (
    r != null &&
      t.update(() => {
        const i = An(r);
        if (!xe(i)) return;
        const o = (function (s, l) {
          let a = l ? s.getPreviousSibling() : s.getNextSibling(),
            u = s;
          for (; a == null && xe(u); )
            (u = u.getParentOrThrow().getParent()), u != null && (a = l ? u.getPreviousSibling() : u.getNextSibling());
          for (; xe(a); ) {
            const c = l ? a.getLastChild() : a.getFirstChild();
            if (!ue(c)) return a;
            a = l ? c.getLastChild() : c.getFirstChild();
          }
          return null;
        })(i, n);
        if (o != null) {
          o.selectStart();
          const s = t.getElementByKey(o.__key);
          s != null &&
            (e.preventDefault(),
            setTimeout(() => {
              s.focus();
            }, 0));
        }
      }),
    !1
  );
}
const mv = ae("INSERT_UNORDERED_LIST_COMMAND"),
  xv = ae("INSERT_ORDERED_LIST_COMMAND"),
  vv = ae("REMOVE_LIST_COMMAND");
function S6(e) {
  return yt(
    e.registerCommand(xv, () => (Kc("number"), !0), He),
    e.registerCommand(mv, () => (Kc("bullet"), !0), He),
    e.registerCommand(vv, () => (v6(), !0), He),
    e.registerCommand(jo, () => C6(), He),
    e.registerNodeTransform(nr, (t) => {
      const n = t.getFirstChild();
      if (n) {
        if (Z(n)) {
          const r = n.getStyle(),
            i = n.getFormat();
          t.getTextStyle() !== r && t.setTextStyle(r), t.getTextFormat() !== i && t.setTextFormat(i);
        }
      } else {
        const r = J();
        H(r) &&
          (r.style !== t.getTextStyle() || r.format !== t.getTextFormat()) &&
          r.isCollapsed() &&
          t.is(r.anchor.getNode()) &&
          t.setTextStyle(r.style).setTextFormat(r.format);
      }
    }),
    e.registerNodeTransform(Ln, (t) => {
      const n = t.getParent();
      if (xe(n) && t.is(n.getFirstChild())) {
        const r = t.getStyle(),
          i = t.getFormat();
        (r === n.getTextStyle() && i === n.getTextFormat()) || n.setTextStyle(r).setTextFormat(i);
      }
    }),
  );
}
function T6(e) {
  const t = (n) => {
    const r = n.getParent();
    if (ue(n.getFirstChild()) || !ue(r)) return;
    const i = on(n, (o) => xe(o) && ue(o.getParent()) && xe(o.getPreviousSibling()));
    if (i === null && n.getIndent() > 0) n.setIndent(0);
    else if (xe(i)) {
      const o = i.getPreviousSibling();
      if (xe(o)) {
        const s = (function (a) {
            let u = a,
              c = u.getFirstChild();
            for (; ue(c); ) {
              const d = c.getLastChild();
              if (!xe(d)) break;
              (u = d), (c = u.getFirstChild());
            }
            return u;
          })(o),
          l = s.getParent();
        if (ue(l)) {
          const a = Yo(l);
          a + 1 < Yo(r) && n.setIndent(a);
        }
      }
    }
  };
  return e.registerNodeTransform(rr, (n) => {
    const r = [n];
    for (; r.length > 0; ) {
      const i = r.shift();
      if (ue(i)) {
        for (const o of i.getChildren())
          if (xe(o)) {
            t(o);
            const s = o.getFirstChild();
            ue(s) && r.push(s);
          }
      }
    }
  });
}
const A6 = {
    testNode: "list",
    visitNode: function ({ mdastNode: e, lexicalParent: t, actions: n }) {
      const r = e.children.some((o) => typeof o.checked == "boolean") ? "check" : e.ordered ? "number" : "bullet",
        i = gt(r);
      if (xe(t)) {
        const o = mt();
        o.append(i), t.insertAfter(o);
      } else t.append(i);
      n.visitChildren(e, i);
    },
  },
  I6 = {
    testNode: "listItem",
    visitNode({ mdastNode: e, actions: t, lexicalParent: n }) {
      const r = n.getListType() === "check" ? e.checked ?? !1 : void 0;
      t.addAndStepInto(mt(r));
    },
  },
  N6 = {
    testLexicalNode: ue,
    visitLexicalNode: ({ lexicalNode: e, actions: t }) => {
      t.addAndStepInto("list", { ordered: e.getListType() === "number", spread: !1 });
    },
  },
  L6 = {
    testLexicalNode: xe,
    visitLexicalNode: ({ lexicalNode: e, mdastParent: t, actions: n }) => {
      const r = e.getChildren(),
        i = r[0];
      if (r.length === 1 && ue(i)) {
        const o = t.children.at(-1);
        o ? n.visitChildren(e, o) : n.visitChildren(i, t);
      } else {
        const o = e.getParent(),
          s = n.appendToParent(t, {
            type: "listItem",
            checked: o.getListType() === "check" ? !!e.getChecked() : void 0,
            spread: !1,
            children: [],
          });
        let l = null;
        for (const a of e.getChildren())
          Z(a) || rn(a) || (a.isInline() && (P(a) || Te(a)))
            ? (l || (l = n.appendToParent(s, { type: "paragraph", children: [] })), n.visit(a, l))
            : ((l = null), n.visit(a, s));
      }
    },
  };
function M6(e, t) {
  return yt(
    e.registerCommand(
      ra,
      (n) => {
        const r = J();
        if (!H(r)) return !1;
        n.preventDefault();
        const i = (function (o) {
          const s = o.getNodes();
          if (bw(s, (f) => (bl(f) && f.canIndent() ? f : null)).length > 0) return !0;
          const l = o.anchor,
            a = o.focus,
            u = a.isBefore(l) ? a : l,
            c = u.getNode(),
            d = Ec(c);
          if (d.canIndent()) {
            const f = d.getKey();
            let h = qi();
            if ((h.anchor.set(f, 0, "element"), h.focus.set(f, 0, "element"), (h = Kr(h)), h.anchor.is(u))) return !0;
          }
          return !1;
        })(r)
          ? n.shiftKey
            ? cc
            : xl
          : G1;
        return e.dispatchCommand(i, void 0);
      },
      be,
    ),
    e.registerCommand(
      xl,
      () => {
        if (t == null) return !1;
        const n = J();
        if (!H(n)) return !1;
        const r = n.getNodes().map((i) => Ec(i).getIndent());
        return Math.max(...r) + 1 >= t;
      },
      Bt,
    ),
  );
}
function qg({ maxIndent: e }) {
  const [t] = bt();
  return E.useEffect(() => M6(t, e), [t, e]), null;
}
function Yg() {
  const [e] = bt();
  return E.useEffect(() => k6(e), [e]), null;
}
function Xg({ hasStrictIndent: e = !1 }) {
  const [t] = bt();
  return (
    E.useEffect(() => {
      if (!t.hasNodes([rr, nr])) throw new Error("ListPlugin: ListNode and/or ListItemNode not registered on editor");
    }, [t]),
    E.useEffect(() => {
      if (e) return T6(t);
    }, [t, e]),
    (function (n) {
      E.useEffect(() => S6(n), [n]);
    })(t),
    null
  );
}
const O6 = { tokenize: R6 };
function F6() {
  return { text: { 91: O6 } };
}
function R6(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return r.previous !== null || !r._gfmTasklistFirstContentOfListItem
      ? n(a)
      : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(a), e.exit("taskListCheckMarker"), o);
  }
  function o(a) {
    return Ae(a)
      ? (e.enter("taskListCheckValueUnchecked"), e.consume(a), e.exit("taskListCheckValueUnchecked"), s)
      : a === 88 || a === 120
        ? (e.enter("taskListCheckValueChecked"), e.consume(a), e.exit("taskListCheckValueChecked"), s)
        : n(a);
  }
  function s(a) {
    return a === 93
      ? (e.enter("taskListCheckMarker"), e.consume(a), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), l)
      : n(a);
  }
  function l(a) {
    return ee(a) ? t(a) : fe(a) ? e.check({ tokenize: P6 }, t, n)(a) : n(a);
  }
}
function P6(e, t, n) {
  return ve(e, r, "whitespace");
  function r(i) {
    return i === null ? n(i) : t(i);
  }
}
function D6() {
  return { exit: { taskListCheckValueChecked: Qg, taskListCheckValueUnchecked: Qg, paragraph: B6 } };
}
function $6() {
  return { unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }], handlers: { listItem: H6 } };
}
function Qg(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, (t.checked = e.type === "taskListCheckValueChecked");
}
function B6(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r = n.children[0];
    if (r && r.type === "text") {
      const i = t.children;
      let o = -1,
        s;
      for (; ++o < i.length; ) {
        const l = i[o];
        if (l.type === "paragraph") {
          s = l;
          break;
        }
      }
      s === n &&
        ((r.value = r.value.slice(1)),
        r.value.length === 0
          ? n.children.shift()
          : n.position &&
            r.position &&
            typeof r.position.start.offset == "number" &&
            (r.position.start.column++,
            r.position.start.offset++,
            (n.position.start = Object.assign({}, r.position.start))));
    }
  }
  this.exit(e);
}
function H6(e, t, n, r) {
  const i = e.children[0],
    o = typeof e.checked == "boolean" && i && i.type === "paragraph",
    s = "[" + (e.checked ? "x" : " ") + "] ",
    l = n.createTracker(r);
  o && l.move(s);
  let a = Ef.listItem(e, t, n, { ...r, ...l.current() });
  return o && (a = a.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, u)), a;
  function u(c) {
    return c + s;
  }
}
const V6 = new Map([
    ["number", xv],
    ["bullet", mv],
    ["check", pv],
    ["", vv],
  ]),
  Gc = ne("", (e) => {
    e.sub(e.pipe($i, Ve(je)), ([t, n]) => {
      if (!t || !n) return;
      const r = t.anchor.getNode();
      let i =
        r.getKey() === "root"
          ? r
          : on(r, (l) => {
              const a = l.getParent();
              return a !== null && tt(a);
            });
      i === null && (i = r.getTopLevelElementOrThrow());
      const o = i.getKey();
      if (n.getElementByKey(o) !== null)
        if (ue(i)) {
          const l = z0(r, rr),
            a = l ? l.getListType() : i.getListType();
          e.pub(Gc, a);
        } else e.pub(Gc, "");
    });
  }),
  bv = Ze((e) => {
    e.sub(e.pipe(bv, Ve(je)), ([t, n]) => {
      n == null || n.dispatchCommand(V6.get(t), void 0);
    });
  }),
  z6 = vt({
    init(e) {
      var t;
      (t = e.getValue(Ht)) == null || t.registerCommand(xl, () => !U6(7), Bt),
        e.pubIn({
          [ro]: "lists",
          [Vi]: D6(),
          [Hi]: F6(),
          [Gt]: [A6, I6],
          [fn]: [nr, rr],
          [hn]: [N6, L6],
          [vs]: $6(),
          [ai]: [qg, Xg, Yg],
          [Yx]: [qg, Xg, Yg],
        });
    },
  });
function j6(e) {
  const t = e.getNodes();
  return t.length === 0
    ? new Set([e.anchor.getNode().getParentOrThrow(), e.focus.getNode().getParentOrThrow()])
    : new Set(t.map((n) => (P(n) ? n : n.getParentOrThrow())));
}
function U6(e) {
  const t = J();
  if (!H(t)) return !1;
  const n = j6(t);
  let r = 0;
  for (const i of n)
    if (ue(i)) r = Math.max(Yo(i) + 1, r);
    else if (xe(i)) {
      const o = i.getParent();
      if ((o == null ? void 0 : o.getChildren().length) === 1) {
        const s = o.getParent();
        if (xe(s) && s.getChildren().length === 1) return !1;
      }
      if (!ue(o)) throw new Error("ListMaxIndentLevelPlugin: A ListItemNode must have a ListNode for a parent.");
      r = Math.max(Yo(o) + 1, r);
    }
  return r <= e;
}
function W6(e, t = {}) {
  const n = (t.align || []).concat(),
    r = t.stringLength || J6,
    i = [],
    o = [],
    s = [],
    l = [];
  let a = 0,
    u = -1;
  for (; ++u < e.length; ) {
    const p = [],
      g = [];
    let x = -1;
    for (e[u].length > a && (a = e[u].length); ++x < e[u].length; ) {
      const b = K6(e[u][x]);
      if (t.alignDelimiters !== !1) {
        const m = r(b);
        (g[x] = m), (l[x] === void 0 || m > l[x]) && (l[x] = m);
      }
      p.push(b);
    }
    (o[u] = p), (s[u] = g);
  }
  let c = -1;
  if (typeof n == "object" && "length" in n) for (; ++c < a; ) i[c] = em(n[c]);
  else {
    const p = em(n);
    for (; ++c < a; ) i[c] = p;
  }
  c = -1;
  const d = [],
    f = [];
  for (; ++c < a; ) {
    const p = i[c];
    let g = "",
      x = "";
    p === 99 ? ((g = ":"), (x = ":")) : p === 108 ? (g = ":") : p === 114 && (x = ":");
    let b = t.alignDelimiters === !1 ? 1 : Math.max(1, l[c] - g.length - x.length);
    const m = g + "-".repeat(b) + x;
    t.alignDelimiters !== !1 && ((b = g.length + b + x.length), b > l[c] && (l[c] = b), (f[c] = b)), (d[c] = m);
  }
  o.splice(1, 0, d), s.splice(1, 0, f), (u = -1);
  const h = [];
  for (; ++u < o.length; ) {
    const p = o[u],
      g = s[u];
    c = -1;
    const x = [];
    for (; ++c < a; ) {
      const b = p[c] || "";
      let m = "",
        v = "";
      if (t.alignDelimiters !== !1) {
        const _ = l[c] - (g[c] || 0),
          k = i[c];
        k === 114
          ? (m = " ".repeat(_))
          : k === 99
            ? _ % 2
              ? ((m = " ".repeat(_ / 2 + 0.5)), (v = " ".repeat(_ / 2 - 0.5)))
              : ((m = " ".repeat(_ / 2)), (v = m))
            : (v = " ".repeat(_));
      }
      t.delimiterStart !== !1 && !c && x.push("|"),
        t.padding !== !1 && !(t.alignDelimiters === !1 && b === "") && (t.delimiterStart !== !1 || c) && x.push(" "),
        t.alignDelimiters !== !1 && x.push(m),
        x.push(b),
        t.alignDelimiters !== !1 && x.push(v),
        t.padding !== !1 && x.push(" "),
        (t.delimiterEnd !== !1 || c !== a - 1) && x.push("|");
    }
    h.push(t.delimiterEnd === !1 ? x.join("").replace(/ +$/, "") : x.join(""));
  }
  return h.join(`
`);
}
function K6(e) {
  return e == null ? "" : String(e);
}
function J6(e) {
  return e.length;
}
function em(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
function G6() {
  return {
    enter: { table: Z6, tableData: tm, tableHeader: tm, tableRow: Y6 },
    exit: { codeText: X6, table: q6, tableData: Eu, tableHeader: Eu, tableRow: Eu },
  };
}
function Z6(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function (n) {
        return n === "none" ? null : n;
      }),
      children: [],
    },
    e,
  ),
    (this.data.inTable = !0);
}
function q6(e) {
  this.exit(e), (this.data.inTable = void 0);
}
function Y6(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function Eu(e) {
  this.exit(e);
}
function tm(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function X6(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, Q6));
  const n = this.stack[this.stack.length - 1];
  n.type, (n.value = t), this.exit(e);
}
function Q6(e, t) {
  return t === "|" ? t : e;
}
function e8(e) {
  const t = e || {},
    n = t.tableCellPadding,
    r = t.tablePipeAlign,
    i = t.stringLength,
    o = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      {
        character: `
`,
        inConstruct: "tableCell",
      },
      { atBreak: !0, character: "|", after: "[	 :-]" },
      { character: "|", inConstruct: "tableCell" },
      { atBreak: !0, character: ":", after: "-" },
      { atBreak: !0, character: "-", after: "[:|-]" },
    ],
    handlers: { inlineCode: f, table: s, tableCell: a, tableRow: l },
  };
  function s(h, p, g, x) {
    return u(c(h, g, x), h.align);
  }
  function l(h, p, g, x) {
    const b = d(h, g, x),
      m = u([b]);
    return m.slice(
      0,
      m.indexOf(`
`),
    );
  }
  function a(h, p, g, x) {
    const b = g.enter("tableCell"),
      m = g.enter("phrasing"),
      v = g.containerPhrasing(h, { ...x, before: o, after: o });
    return m(), b(), v;
  }
  function u(h, p) {
    return W6(h, { align: p, alignDelimiters: r, padding: n, stringLength: i });
  }
  function c(h, p, g) {
    const x = h.children;
    let b = -1;
    const m = [],
      v = p.enter("table");
    for (; ++b < x.length; ) m[b] = d(x[b], p, g);
    return v(), m;
  }
  function d(h, p, g) {
    const x = h.children;
    let b = -1;
    const m = [],
      v = p.enter("tableRow");
    for (; ++b < x.length; ) m[b] = a(x[b], h, p, g);
    return v(), m;
  }
  function f(h, p, g) {
    let x = Ef.inlineCode(h, p, g);
    return g.stack.includes("tableCell") && (x = x.replace(/\|/g, "\\$&")), x;
  }
}
class t8 {
  constructor() {
    this.map = [];
  }
  add(t, n, r) {
    n8(this, t, n, r);
  }
  consume(t) {
    if (
      (this.map.sort(function (o, s) {
        return o[0] - s[0];
      }),
      this.map.length === 0)
    )
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; )
      (n -= 1), r.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), (t.length = this.map[n][0]);
    r.push([...t]), (t.length = 0);
    let i = r.pop();
    for (; i; ) t.push(...i), (i = r.pop());
    this.map.length = 0;
  }
}
function n8(e, t, n, r) {
  let i = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; i < e.map.length; ) {
      if (e.map[i][0] === t) {
        (e.map[i][1] += n), e.map[i][2].push(...r);
        return;
      }
      i += 1;
    }
    e.map.push([t, n, r]);
  }
}
function r8(e, t) {
  let n = !1;
  const r = [];
  for (; t < e.length; ) {
    const i = e[t];
    if (n) {
      if (i[0] === "enter")
        i[1].type === "tableContent" && r.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (i[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const o = r.length - 1;
          r[o] = r[o] === "left" ? "center" : "right";
        }
      } else if (i[1].type === "tableDelimiterRow") break;
    } else i[0] === "enter" && i[1].type === "tableDelimiterRow" && (n = !0);
    t += 1;
  }
  return r;
}
function i8() {
  return { flow: { null: { tokenize: o8, resolveAll: s8 } } };
}
function o8(e, t, n) {
  const r = this;
  let i = 0,
    o = 0,
    s;
  return l;
  function l(A) {
    let F = r.events.length - 1;
    for (; F > -1; ) {
      const B = r.events[F][1].type;
      if (B === "lineEnding" || B === "linePrefix") F--;
      else break;
    }
    const R = F > -1 ? r.events[F][1].type : null,
      V = R === "tableHead" || R === "tableRow" ? w : a;
    return V === w && r.parser.lazy[r.now().line] ? n(A) : V(A);
  }
  function a(A) {
    return e.enter("tableHead"), e.enter("tableRow"), u(A);
  }
  function u(A) {
    return A === 124 || ((s = !0), (o += 1)), c(A);
  }
  function c(A) {
    return A === null
      ? n(A)
      : ee(A)
        ? o > 1
          ? ((o = 0),
            (r.interrupt = !0),
            e.exit("tableRow"),
            e.enter("lineEnding"),
            e.consume(A),
            e.exit("lineEnding"),
            h)
          : n(A)
        : fe(A)
          ? ve(e, c, "whitespace")(A)
          : ((o += 1),
            s && ((s = !1), (i += 1)),
            A === 124
              ? (e.enter("tableCellDivider"), e.consume(A), e.exit("tableCellDivider"), (s = !0), c)
              : (e.enter("data"), d(A)));
  }
  function d(A) {
    return A === null || A === 124 || Ae(A) ? (e.exit("data"), c(A)) : (e.consume(A), A === 92 ? f : d);
  }
  function f(A) {
    return A === 92 || A === 124 ? (e.consume(A), d) : d(A);
  }
  function h(A) {
    return (
      (r.interrupt = !1),
      r.parser.lazy[r.now().line]
        ? n(A)
        : (e.enter("tableDelimiterRow"),
          (s = !1),
          fe(A)
            ? ve(e, p, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(A)
            : p(A))
    );
  }
  function p(A) {
    return A === 45 || A === 58
      ? x(A)
      : A === 124
        ? ((s = !0), e.enter("tableCellDivider"), e.consume(A), e.exit("tableCellDivider"), g)
        : k(A);
  }
  function g(A) {
    return fe(A) ? ve(e, x, "whitespace")(A) : x(A);
  }
  function x(A) {
    return A === 58
      ? ((o += 1), (s = !0), e.enter("tableDelimiterMarker"), e.consume(A), e.exit("tableDelimiterMarker"), b)
      : A === 45
        ? ((o += 1), b(A))
        : A === null || ee(A)
          ? _(A)
          : k(A);
  }
  function b(A) {
    return A === 45 ? (e.enter("tableDelimiterFiller"), m(A)) : k(A);
  }
  function m(A) {
    return A === 45
      ? (e.consume(A), m)
      : A === 58
        ? ((s = !0),
          e.exit("tableDelimiterFiller"),
          e.enter("tableDelimiterMarker"),
          e.consume(A),
          e.exit("tableDelimiterMarker"),
          v)
        : (e.exit("tableDelimiterFiller"), v(A));
  }
  function v(A) {
    return fe(A) ? ve(e, _, "whitespace")(A) : _(A);
  }
  function _(A) {
    return A === 124
      ? p(A)
      : A === null || ee(A)
        ? !s || i !== o
          ? k(A)
          : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(A))
        : k(A);
  }
  function k(A) {
    return n(A);
  }
  function w(A) {
    return e.enter("tableRow"), y(A);
  }
  function y(A) {
    return A === 124
      ? (e.enter("tableCellDivider"), e.consume(A), e.exit("tableCellDivider"), y)
      : A === null || ee(A)
        ? (e.exit("tableRow"), t(A))
        : fe(A)
          ? ve(e, y, "whitespace")(A)
          : (e.enter("data"), S(A));
  }
  function S(A) {
    return A === null || A === 124 || Ae(A) ? (e.exit("data"), y(A)) : (e.consume(A), A === 92 ? T : S);
  }
  function T(A) {
    return A === 92 || A === 124 ? (e.consume(A), S) : S(A);
  }
}
function s8(e, t) {
  let n = -1,
    r = !0,
    i = 0,
    o = [0, 0, 0, 0],
    s = [0, 0, 0, 0],
    l = !1,
    a = 0,
    u,
    c,
    d;
  const f = new t8();
  for (; ++n < e.length; ) {
    const h = e[n],
      p = h[1];
    h[0] === "enter"
      ? p.type === "tableHead"
        ? ((l = !1),
          a !== 0 && (nm(f, t, a, u, c), (c = void 0), (a = 0)),
          (u = { type: "table", start: Object.assign({}, p.start), end: Object.assign({}, p.end) }),
          f.add(n, 0, [["enter", u, t]]))
        : p.type === "tableRow" || p.type === "tableDelimiterRow"
          ? ((r = !0),
            (d = void 0),
            (o = [0, 0, 0, 0]),
            (s = [0, n + 1, 0, 0]),
            l &&
              ((l = !1),
              (c = { type: "tableBody", start: Object.assign({}, p.start), end: Object.assign({}, p.end) }),
              f.add(n, 0, [["enter", c, t]])),
            (i = p.type === "tableDelimiterRow" ? 2 : c ? 3 : 1))
          : i && (p.type === "data" || p.type === "tableDelimiterMarker" || p.type === "tableDelimiterFiller")
            ? ((r = !1),
              s[2] === 0 &&
                (o[1] !== 0 && ((s[0] = s[1]), (d = Hs(f, t, o, i, void 0, d)), (o = [0, 0, 0, 0])), (s[2] = n)))
            : p.type === "tableCellDivider" &&
              (r
                ? (r = !1)
                : (o[1] !== 0 && ((s[0] = s[1]), (d = Hs(f, t, o, i, void 0, d))), (o = s), (s = [o[1], n, 0, 0])))
      : p.type === "tableHead"
        ? ((l = !0), (a = n))
        : p.type === "tableRow" || p.type === "tableDelimiterRow"
          ? ((a = n),
            o[1] !== 0 ? ((s[0] = s[1]), (d = Hs(f, t, o, i, n, d))) : s[1] !== 0 && (d = Hs(f, t, s, i, n, d)),
            (i = 0))
          : i &&
            (p.type === "data" || p.type === "tableDelimiterMarker" || p.type === "tableDelimiterFiller") &&
            (s[3] = n);
  }
  for (a !== 0 && nm(f, t, a, u, c), f.consume(t.events), n = -1; ++n < t.events.length; ) {
    const h = t.events[n];
    h[0] === "enter" && h[1].type === "table" && (h[1]._align = r8(t.events, n));
  }
  return e;
}
function Hs(e, t, n, r, i, o) {
  const s = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData",
    l = "tableContent";
  n[0] !== 0 && ((o.end = Object.assign({}, bi(t.events, n[0]))), e.add(n[0], 0, [["exit", o, t]]));
  const a = bi(t.events, n[1]);
  if (
    ((o = { type: s, start: Object.assign({}, a), end: Object.assign({}, a) }),
    e.add(n[1], 0, [["enter", o, t]]),
    n[2] !== 0)
  ) {
    const u = bi(t.events, n[2]),
      c = bi(t.events, n[3]),
      d = { type: l, start: Object.assign({}, u), end: Object.assign({}, c) };
    if ((e.add(n[2], 0, [["enter", d, t]]), r !== 2)) {
      const f = t.events[n[2]],
        h = t.events[n[3]];
      if (
        ((f[1].end = Object.assign({}, h[1].end)),
        (f[1].type = "chunkText"),
        (f[1].contentType = "text"),
        n[3] > n[2] + 1)
      ) {
        const p = n[2] + 1,
          g = n[3] - n[2] - 1;
        e.add(p, g, []);
      }
    }
    e.add(n[3] + 1, 0, [["exit", d, t]]);
  }
  return i !== void 0 && ((o.end = Object.assign({}, bi(t.events, i))), e.add(i, 0, [["exit", o, t]]), (o = void 0)), o;
}
function nm(e, t, n, r, i) {
  const o = [],
    s = bi(t.events, n);
  i && ((i.end = Object.assign({}, s)), o.push(["exit", i, t])),
    (r.end = Object.assign({}, s)),
    o.push(["exit", r, t]),
    e.add(n + 1, 0, o);
}
function bi(e, t) {
  const n = e[t],
    r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
const rm = [
    ["Cat", "rgb(125, 50, 0)"],
    ["Dog", "rgb(100, 0, 0)"],
    ["Rabbit", "rgb(150, 0, 0)"],
    ["Frog", "rgb(200, 0, 0)"],
    ["Fox", "rgb(200, 75, 0)"],
    ["Hedgehog", "rgb(0, 75, 0)"],
    ["Pigeon", "rgb(0, 125, 0)"],
    ["Squirrel", "rgb(75, 100, 0)"],
    ["Bear", "rgb(125, 100, 0)"],
    ["Tiger", "rgb(0, 0, 150)"],
    ["Leopard", "rgb(0, 0, 200)"],
    ["Zebra", "rgb(0, 0, 250)"],
    ["Wolf", "rgb(0, 100, 150)"],
    ["Owl", "rgb(0, 100, 100)"],
    ["Gull", "rgb(100, 0, 100)"],
    ["Squid", "rgb(150, 0, 150)"],
  ],
  im = rm[Math.floor(Math.random() * rm.length)],
  l8 = E.createContext({ clientID: 0, color: im[1], isCollabActive: !1, name: im[0], yjsDocMap: new Map() });
function a8(e, t) {
  return E.useContext(l8);
}
function om(e) {
  const t = e.transform();
  return new Set(t ? [t] : []);
}
function yv({
  initialEditor: e,
  children: t,
  initialNodes: n,
  initialTheme: r,
  skipCollabChecks: i,
  skipEditableListener: o,
}) {
  const s = E.useRef(!1),
    l = E.useContext(al);
  l == null &&
    (function (p, ...g) {
      const x = new URL("https://lexical.dev/docs/error"),
        b = new URLSearchParams();
      b.append("code", p);
      for (const m of g) b.append("v", m);
      throw (
        ((x.search = b.toString()),
        Error(
          `Minified Lexical error #${p}; visit ${x.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`,
        ))
      );
    })(9);
  const [a, { getTheme: u }] = l,
    c = E.useMemo(() => {
      const p = r || u() || void 0,
        g = L1(l, p);
      p !== void 0 && (e._config.theme = p), (e._parentEditor = e._parentEditor || a);
      const x = e._createEditorArgs,
        b = x && x.namespace;
      if (n) {
        b || (e._config.namespace = a._config.namespace);
        for (let m of n) {
          let v = null,
            _ = null;
          if (typeof m != "function") {
            const w = m;
            (m = w.replace), (v = w.with), (_ = w.withKlass || null);
          }
          const k = e._nodes.get(m.getType());
          e._nodes.set(m.getType(), {
            exportDOM: k ? k.exportDOM : void 0,
            klass: m,
            replace: v,
            replaceWithKlass: _,
            transforms: om(m),
          });
        }
      } else if (x && x.nodes) b || (e._config.namespace = a._config.namespace);
      else {
        const m = (e._nodes = new Map(a._nodes));
        b || (e._config.namespace = a._config.namespace);
        for (const [v, _] of m)
          e._nodes.set(v, {
            exportDOM: _.exportDOM,
            klass: _.klass,
            replace: _.replace,
            replaceWithKlass: _.replaceWithKlass,
            transforms: om(_.klass),
          });
      }
      return [e, g];
    }, []),
    { isCollabActive: d, yjsDocMap: f } = a8(),
    h = i || s.current || f.has(e.getKey());
  return (
    E.useEffect(() => {
      h && (s.current = !0);
    }, [h]),
    E.useEffect(() => {
      if (!o) {
        const p = (g) => e.setEditable(g);
        return p(a.isEditable()), a.registerEditableListener(p);
      }
    }, [e, a, o]),
    O.jsx(al.Provider, { value: c, children: !d || h ? t : null })
  );
}
function ge(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function (i) {
    if ((e == null || e(i), n === !1 || !i.defaultPrevented)) return t == null ? void 0 : t(i);
  };
}
function sm(e, t) {
  if (typeof e == "function") return e(t);
  e != null && (e.current = t);
}
function Cv(...e) {
  return (t) => {
    let n = !1;
    const r = e.map((i) => {
      const o = sm(i, t);
      return !n && typeof o == "function" && (n = !0), o;
    });
    if (n)
      return () => {
        for (let i = 0; i < r.length; i++) {
          const o = r[i];
          typeof o == "function" ? o() : sm(e[i], null);
        }
      };
  };
}
function ze(...e) {
  return E.useCallback(Cv(...e), e);
}
function u8(e, t) {
  const n = E.createContext(t),
    r = (o) => {
      const { children: s, ...l } = o,
        a = E.useMemo(() => l, Object.values(l));
      return O.jsx(n.Provider, { value: a, children: s });
    };
  r.displayName = e + "Provider";
  function i(o) {
    const s = E.useContext(n);
    if (s) return s;
    if (t !== void 0) return t;
    throw new Error(`\`${o}\` must be used within \`${e}\``);
  }
  return [r, i];
}
function ir(e, t = []) {
  let n = [];
  function r(o, s) {
    const l = E.createContext(s),
      a = n.length;
    n = [...n, s];
    const u = (d) => {
      var b;
      const { scope: f, children: h, ...p } = d,
        g = ((b = f == null ? void 0 : f[e]) == null ? void 0 : b[a]) || l,
        x = E.useMemo(() => p, Object.values(p));
      return O.jsx(g.Provider, { value: x, children: h });
    };
    u.displayName = o + "Provider";
    function c(d, f) {
      var g;
      const h = ((g = f == null ? void 0 : f[e]) == null ? void 0 : g[a]) || l,
        p = E.useContext(h);
      if (p) return p;
      if (s !== void 0) return s;
      throw new Error(`\`${d}\` must be used within \`${o}\``);
    }
    return [u, c];
  }
  const i = () => {
    const o = n.map((s) => E.createContext(s));
    return function (l) {
      const a = (l == null ? void 0 : l[e]) || o;
      return E.useMemo(() => ({ [`__scope${e}`]: { ...l, [e]: a } }), [l, a]);
    };
  };
  return (i.scopeName = e), [r, c8(i, ...t)];
}
function c8(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((i) => ({ useScope: i(), scopeName: i.scopeName }));
    return function (o) {
      const s = r.reduce((l, { useScope: a, scopeName: u }) => {
        const d = a(o)[`__scope${u}`];
        return { ...l, ...d };
      }, {});
      return E.useMemo(() => ({ [`__scope${t.scopeName}`]: s }), [s]);
    };
  };
  return (n.scopeName = t.scopeName), n;
}
function ji(e) {
  const t = d8(e),
    n = E.forwardRef((r, i) => {
      const { children: o, ...s } = r,
        l = E.Children.toArray(o),
        a = l.find(h8);
      if (a) {
        const u = a.props.children,
          c = l.map((d) =>
            d === a
              ? E.Children.count(u) > 1
                ? E.Children.only(null)
                : E.isValidElement(u)
                  ? u.props.children
                  : null
              : d,
          );
        return O.jsx(t, { ...s, ref: i, children: E.isValidElement(u) ? E.cloneElement(u, void 0, c) : null });
      }
      return O.jsx(t, { ...s, ref: i, children: o });
    });
  return (n.displayName = `${e}.Slot`), n;
}
function d8(e) {
  const t = E.forwardRef((n, r) => {
    const { children: i, ...o } = n;
    if (E.isValidElement(i)) {
      const s = g8(i),
        l = p8(o, i.props);
      return i.type !== E.Fragment && (l.ref = r ? Cv(r, s) : s), E.cloneElement(i, l);
    }
    return E.Children.count(i) > 1 ? E.Children.only(null) : null;
  });
  return (t.displayName = `${e}.SlotClone`), t;
}
var _v = Symbol("radix.slottable");
function f8(e) {
  const t = ({ children: n }) => O.jsx(O.Fragment, { children: n });
  return (t.displayName = `${e}.Slottable`), (t.__radixId = _v), t;
}
function h8(e) {
  return E.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === _v;
}
function p8(e, t) {
  const n = { ...t };
  for (const r in t) {
    const i = e[r],
      o = t[r];
    /^on[A-Z]/.test(r)
      ? i && o
        ? (n[r] = (...l) => {
            const a = o(...l);
            return i(...l), a;
          })
        : i && (n[r] = i)
      : r === "style"
        ? (n[r] = { ...i, ...o })
        : r === "className" && (n[r] = [i, o].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function g8(e) {
  var r, i;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get,
    n = t && "isReactWarning" in t && t.isReactWarning;
  return n
    ? e.ref
    : ((t = (i = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : i.get),
      (n = t && "isReactWarning" in t && t.isReactWarning),
      n ? e.props.ref : e.props.ref || e.ref);
}
var m8 = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "select",
    "span",
    "svg",
    "ul",
  ],
  _e = m8.reduce((e, t) => {
    const n = ji(`Primitive.${t}`),
      r = E.forwardRef((i, o) => {
        const { asChild: s, ...l } = i,
          a = s ? n : t;
        return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), O.jsx(a, { ...l, ref: o });
      });
    return (r.displayName = `Primitive.${t}`), { ...e, [t]: r };
  }, {});
function x8(e, t) {
  e && Ni.flushSync(() => e.dispatchEvent(t));
}
function xr(e) {
  const t = E.useRef(e);
  return (
    E.useEffect(() => {
      t.current = e;
    }),
    E.useMemo(
      () =>
        (...n) => {
          var r;
          return (r = t.current) == null ? void 0 : r.call(t, ...n);
        },
      [],
    )
  );
}
function v8(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = xr(e);
  E.useEffect(() => {
    const r = (i) => {
      i.key === "Escape" && n(i);
    };
    return (
      t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 })
    );
  }, [n, t]);
}
var b8 = "DismissableLayer",
  Zc = "dismissableLayer.update",
  y8 = "dismissableLayer.pointerDownOutside",
  C8 = "dismissableLayer.focusOutside",
  lm,
  wv = E.createContext({ layers: new Set(), layersWithOutsidePointerEventsDisabled: new Set(), branches: new Set() }),
  ys = E.forwardRef((e, t) => {
    const {
        disableOutsidePointerEvents: n = !1,
        onEscapeKeyDown: r,
        onPointerDownOutside: i,
        onFocusOutside: o,
        onInteractOutside: s,
        onDismiss: l,
        ...a
      } = e,
      u = E.useContext(wv),
      [c, d] = E.useState(null),
      f = (c == null ? void 0 : c.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document),
      [, h] = E.useState({}),
      p = ze(t, (y) => d(y)),
      g = Array.from(u.layers),
      [x] = [...u.layersWithOutsidePointerEventsDisabled].slice(-1),
      b = g.indexOf(x),
      m = c ? g.indexOf(c) : -1,
      v = u.layersWithOutsidePointerEventsDisabled.size > 0,
      _ = m >= b,
      k = E8((y) => {
        const S = y.target,
          T = [...u.branches].some((A) => A.contains(S));
        !_ || T || (i == null || i(y), s == null || s(y), y.defaultPrevented || l == null || l());
      }, f),
      w = k8((y) => {
        const S = y.target;
        [...u.branches].some((A) => A.contains(S)) ||
          (o == null || o(y), s == null || s(y), y.defaultPrevented || l == null || l());
      }, f);
    return (
      v8((y) => {
        m === u.layers.size - 1 && (r == null || r(y), !y.defaultPrevented && l && (y.preventDefault(), l()));
      }, f),
      E.useEffect(() => {
        if (c)
          return (
            n &&
              (u.layersWithOutsidePointerEventsDisabled.size === 0 &&
                ((lm = f.body.style.pointerEvents), (f.body.style.pointerEvents = "none")),
              u.layersWithOutsidePointerEventsDisabled.add(c)),
            u.layers.add(c),
            am(),
            () => {
              n && u.layersWithOutsidePointerEventsDisabled.size === 1 && (f.body.style.pointerEvents = lm);
            }
          );
      }, [c, f, n, u]),
      E.useEffect(
        () => () => {
          c && (u.layers.delete(c), u.layersWithOutsidePointerEventsDisabled.delete(c), am());
        },
        [c, u],
      ),
      E.useEffect(() => {
        const y = () => h({});
        return document.addEventListener(Zc, y), () => document.removeEventListener(Zc, y);
      }, []),
      O.jsx(_e.div, {
        ...a,
        ref: p,
        style: { pointerEvents: v ? (_ ? "auto" : "none") : void 0, ...e.style },
        onFocusCapture: ge(e.onFocusCapture, w.onFocusCapture),
        onBlurCapture: ge(e.onBlurCapture, w.onBlurCapture),
        onPointerDownCapture: ge(e.onPointerDownCapture, k.onPointerDownCapture),
      })
    );
  });
ys.displayName = b8;
var _8 = "DismissableLayerBranch",
  w8 = E.forwardRef((e, t) => {
    const n = E.useContext(wv),
      r = E.useRef(null),
      i = ze(t, r);
    return (
      E.useEffect(() => {
        const o = r.current;
        if (o)
          return (
            n.branches.add(o),
            () => {
              n.branches.delete(o);
            }
          );
      }, [n.branches]),
      O.jsx(_e.div, { ...e, ref: i })
    );
  });
w8.displayName = _8;
function E8(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = xr(e),
    r = E.useRef(!1),
    i = E.useRef(() => {});
  return (
    E.useEffect(() => {
      const o = (l) => {
          if (l.target && !r.current) {
            let a = function () {
              Ev(y8, n, u, { discrete: !0 });
            };
            const u = { originalEvent: l };
            l.pointerType === "touch"
              ? (t.removeEventListener("click", i.current),
                (i.current = a),
                t.addEventListener("click", i.current, { once: !0 }))
              : a();
          } else t.removeEventListener("click", i.current);
          r.current = !1;
        },
        s = window.setTimeout(() => {
          t.addEventListener("pointerdown", o);
        }, 0);
      return () => {
        window.clearTimeout(s), t.removeEventListener("pointerdown", o), t.removeEventListener("click", i.current);
      };
    }, [t, n]),
    { onPointerDownCapture: () => (r.current = !0) }
  );
}
function k8(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = xr(e),
    r = E.useRef(!1);
  return (
    E.useEffect(() => {
      const i = (o) => {
        o.target && !r.current && Ev(C8, n, { originalEvent: o }, { discrete: !1 });
      };
      return t.addEventListener("focusin", i), () => t.removeEventListener("focusin", i);
    }, [t, n]),
    { onFocusCapture: () => (r.current = !0), onBlurCapture: () => (r.current = !1) }
  );
}
function am() {
  const e = new CustomEvent(Zc);
  document.dispatchEvent(e);
}
function Ev(e, t, n, { discrete: r }) {
  const i = n.originalEvent.target,
    o = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
  t && i.addEventListener(e, t, { once: !0 }), r ? x8(i, o) : i.dispatchEvent(o);
}
var ku = 0;
function Hf() {
  E.useEffect(() => {
    const e = document.querySelectorAll("[data-radix-focus-guard]");
    return (
      document.body.insertAdjacentElement("afterbegin", e[0] ?? um()),
      document.body.insertAdjacentElement("beforeend", e[1] ?? um()),
      ku++,
      () => {
        ku === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), ku--;
      }
    );
  }, []);
}
function um() {
  const e = document.createElement("span");
  return (
    e.setAttribute("data-radix-focus-guard", ""),
    (e.tabIndex = 0),
    (e.style.outline = "none"),
    (e.style.opacity = "0"),
    (e.style.position = "fixed"),
    (e.style.pointerEvents = "none"),
    e
  );
}
var Su = "focusScope.autoFocusOnMount",
  Tu = "focusScope.autoFocusOnUnmount",
  cm = { bubbles: !1, cancelable: !0 },
  S8 = "FocusScope",
  Fa = E.forwardRef((e, t) => {
    const { loop: n = !1, trapped: r = !1, onMountAutoFocus: i, onUnmountAutoFocus: o, ...s } = e,
      [l, a] = E.useState(null),
      u = xr(i),
      c = xr(o),
      d = E.useRef(null),
      f = ze(t, (g) => a(g)),
      h = E.useRef({
        paused: !1,
        pause() {
          this.paused = !0;
        },
        resume() {
          this.paused = !1;
        },
      }).current;
    E.useEffect(() => {
      if (r) {
        let g = function (v) {
            if (h.paused || !l) return;
            const _ = v.target;
            l.contains(_) ? (d.current = _) : ur(d.current, { select: !0 });
          },
          x = function (v) {
            if (h.paused || !l) return;
            const _ = v.relatedTarget;
            _ !== null && (l.contains(_) || ur(d.current, { select: !0 }));
          },
          b = function (v) {
            if (document.activeElement === document.body) for (const k of v) k.removedNodes.length > 0 && ur(l);
          };
        document.addEventListener("focusin", g), document.addEventListener("focusout", x);
        const m = new MutationObserver(b);
        return (
          l && m.observe(l, { childList: !0, subtree: !0 }),
          () => {
            document.removeEventListener("focusin", g), document.removeEventListener("focusout", x), m.disconnect();
          }
        );
      }
    }, [r, l, h.paused]),
      E.useEffect(() => {
        if (l) {
          fm.add(h);
          const g = document.activeElement;
          if (!l.contains(g)) {
            const b = new CustomEvent(Su, cm);
            l.addEventListener(Su, u),
              l.dispatchEvent(b),
              b.defaultPrevented || (T8(M8(kv(l)), { select: !0 }), document.activeElement === g && ur(l));
          }
          return () => {
            l.removeEventListener(Su, u),
              setTimeout(() => {
                const b = new CustomEvent(Tu, cm);
                l.addEventListener(Tu, c),
                  l.dispatchEvent(b),
                  b.defaultPrevented || ur(g ?? document.body, { select: !0 }),
                  l.removeEventListener(Tu, c),
                  fm.remove(h);
              }, 0);
          };
        }
      }, [l, u, c, h]);
    const p = E.useCallback(
      (g) => {
        if ((!n && !r) || h.paused) return;
        const x = g.key === "Tab" && !g.altKey && !g.ctrlKey && !g.metaKey,
          b = document.activeElement;
        if (x && b) {
          const m = g.currentTarget,
            [v, _] = A8(m);
          v && _
            ? !g.shiftKey && b === _
              ? (g.preventDefault(), n && ur(v, { select: !0 }))
              : g.shiftKey && b === v && (g.preventDefault(), n && ur(_, { select: !0 }))
            : b === m && g.preventDefault();
        }
      },
      [n, r, h.paused],
    );
    return O.jsx(_e.div, { tabIndex: -1, ...s, ref: f, onKeyDown: p });
  });
Fa.displayName = S8;
function T8(e, { select: t = !1 } = {}) {
  const n = document.activeElement;
  for (const r of e) if ((ur(r, { select: t }), document.activeElement !== n)) return;
}
function A8(e) {
  const t = kv(e),
    n = dm(t, e),
    r = dm(t.reverse(), e);
  return [n, r];
}
function kv(e) {
  const t = [],
    n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (r) => {
        const i = r.tagName === "INPUT" && r.type === "hidden";
        return r.disabled || r.hidden || i
          ? NodeFilter.FILTER_SKIP
          : r.tabIndex >= 0
            ? NodeFilter.FILTER_ACCEPT
            : NodeFilter.FILTER_SKIP;
      },
    });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function dm(e, t) {
  for (const n of e) if (!I8(n, { upTo: t })) return n;
}
function I8(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function N8(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function ur(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), e !== n && N8(e) && t && e.select();
  }
}
var fm = L8();
function L8() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && (n == null || n.pause()), (e = hm(e, t)), e.unshift(t);
    },
    remove(t) {
      var n;
      (e = hm(e, t)), (n = e[0]) == null || n.resume();
    },
  };
}
function hm(e, t) {
  const n = [...e],
    r = n.indexOf(t);
  return r !== -1 && n.splice(r, 1), n;
}
function M8(e) {
  return e.filter((t) => t.tagName !== "A");
}
var xt = globalThis != null && globalThis.document ? E.useLayoutEffect : () => {},
  O8 = _1[" useId ".trim().toString()] || (() => {}),
  F8 = 0;
function Zn(e) {
  const [t, n] = E.useState(O8());
  return (
    xt(() => {
      n((r) => r ?? String(F8++));
    }, [e]),
    t ? `radix-${t}` : ""
  );
}
var il = typeof document < "u" ? E.useLayoutEffect : E.useEffect;
function Fl(e, t) {
  if (e === t) return !0;
  if (typeof e != typeof t) return !1;
  if (typeof e == "function" && e.toString() === t.toString()) return !0;
  let n, r, i;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (((n = e.length), n !== t.length)) return !1;
      for (r = n; r-- !== 0; ) if (!Fl(e[r], t[r])) return !1;
      return !0;
    }
    if (((i = Object.keys(e)), (n = i.length), n !== Object.keys(t).length)) return !1;
    for (r = n; r-- !== 0; ) if (!{}.hasOwnProperty.call(t, i[r])) return !1;
    for (r = n; r-- !== 0; ) {
      const o = i[r];
      if (!(o === "_owner" && e.$$typeof) && !Fl(e[o], t[o])) return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function Sv(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function pm(e, t) {
  const n = Sv(e);
  return Math.round(t * n) / n;
}
function gm(e) {
  const t = E.useRef(e);
  return (
    il(() => {
      t.current = e;
    }),
    t
  );
}
function R8(e) {
  e === void 0 && (e = {});
  const {
      placement: t = "bottom",
      strategy: n = "absolute",
      middleware: r = [],
      platform: i,
      elements: { reference: o, floating: s } = {},
      transform: l = !0,
      whileElementsMounted: a,
      open: u,
    } = e,
    [c, d] = E.useState({ x: 0, y: 0, strategy: n, placement: t, middlewareData: {}, isPositioned: !1 }),
    [f, h] = E.useState(r);
  Fl(f, r) || h(r);
  const [p, g] = E.useState(null),
    [x, b] = E.useState(null),
    m = E.useCallback((U) => {
      U !== w.current && ((w.current = U), g(U));
    }, []),
    v = E.useCallback((U) => {
      U !== y.current && ((y.current = U), b(U));
    }, []),
    _ = o || p,
    k = s || x,
    w = E.useRef(null),
    y = E.useRef(null),
    S = E.useRef(c),
    T = a != null,
    A = gm(a),
    F = gm(i),
    R = E.useCallback(() => {
      if (!w.current || !y.current) return;
      const U = { placement: t, strategy: n, middleware: f };
      F.current && (U.platform = F.current),
        Z5(w.current, y.current, U).then((X) => {
          const te = { ...X, isPositioned: !0 };
          V.current &&
            !Fl(S.current, te) &&
            ((S.current = te),
            Ni.flushSync(() => {
              d(te);
            }));
        });
    }, [f, t, n, F]);
  il(() => {
    u === !1 && S.current.isPositioned && ((S.current.isPositioned = !1), d((U) => ({ ...U, isPositioned: !1 })));
  }, [u]);
  const V = E.useRef(!1);
  il(
    () => (
      (V.current = !0),
      () => {
        V.current = !1;
      }
    ),
    [],
  ),
    il(() => {
      if ((_ && (w.current = _), k && (y.current = k), _ && k)) {
        if (A.current) return A.current(_, k, R);
        R();
      }
    }, [_, k, R, A, T]);
  const B = E.useMemo(() => ({ reference: w, floating: y, setReference: m, setFloating: v }), [m, v]),
    N = E.useMemo(() => ({ reference: _, floating: k }), [_, k]),
    G = E.useMemo(() => {
      const U = { position: n, left: 0, top: 0 };
      if (!N.floating) return U;
      const X = pm(N.floating, c.x),
        te = pm(N.floating, c.y);
      return l
        ? {
            ...U,
            transform: "translate(" + X + "px, " + te + "px)",
            ...(Sv(N.floating) >= 1.5 && { willChange: "transform" }),
          }
        : { position: n, left: X, top: te };
    }, [n, l, N.floating, c.x, c.y]);
  return E.useMemo(() => ({ ...c, update: R, refs: B, elements: N, floatingStyles: G }), [c, R, B, N, G]);
}
const P8 = (e) => {
    function t(n) {
      return {}.hasOwnProperty.call(n, "current");
    }
    return {
      name: "arrow",
      options: e,
      fn(n) {
        const { element: r, padding: i } = typeof e == "function" ? e(n) : e;
        return r && t(r)
          ? r.current != null
            ? qh({ element: r.current, padding: i }).fn(n)
            : {}
          : r
            ? qh({ element: r, padding: i }).fn(n)
            : {};
      },
    };
  },
  D8 = (e, t) => ({ ...q5(e), options: [e, t] }),
  $8 = (e, t) => ({ ...Y5(e), options: [e, t] }),
  B8 = (e, t) => ({ ...tC(e), options: [e, t] }),
  H8 = (e, t) => ({ ...X5(e), options: [e, t] }),
  V8 = (e, t) => ({ ...Q5(e), options: [e, t] }),
  z8 = (e, t) => ({ ...eC(e), options: [e, t] }),
  j8 = (e, t) => ({ ...P8(e), options: [e, t] });
var U8 = "Arrow",
  Tv = E.forwardRef((e, t) => {
    const { children: n, width: r = 10, height: i = 5, ...o } = e;
    return O.jsx(_e.svg, {
      ...o,
      ref: t,
      width: r,
      height: i,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: e.asChild ? n : O.jsx("polygon", { points: "0,0 30,0 15,10" }),
    });
  });
Tv.displayName = U8;
var W8 = Tv;
function K8(e) {
  const [t, n] = E.useState(void 0);
  return (
    xt(() => {
      if (e) {
        n({ width: e.offsetWidth, height: e.offsetHeight });
        const r = new ResizeObserver((i) => {
          if (!Array.isArray(i) || !i.length) return;
          const o = i[0];
          let s, l;
          if ("borderBoxSize" in o) {
            const a = o.borderBoxSize,
              u = Array.isArray(a) ? a[0] : a;
            (s = u.inlineSize), (l = u.blockSize);
          } else (s = e.offsetWidth), (l = e.offsetHeight);
          n({ width: s, height: l });
        });
        return r.observe(e, { box: "border-box" }), () => r.unobserve(e);
      } else n(void 0);
    }, [e]),
    t
  );
}
var Vf = "Popper",
  [Av, oo] = ir(Vf),
  [J8, Iv] = Av(Vf),
  Nv = (e) => {
    const { __scopePopper: t, children: n } = e,
      [r, i] = E.useState(null);
    return O.jsx(J8, { scope: t, anchor: r, onAnchorChange: i, children: n });
  };
Nv.displayName = Vf;
var Lv = "PopperAnchor",
  Mv = E.forwardRef((e, t) => {
    const { __scopePopper: n, virtualRef: r, ...i } = e,
      o = Iv(Lv, n),
      s = E.useRef(null),
      l = ze(t, s);
    return (
      E.useEffect(() => {
        o.onAnchorChange((r == null ? void 0 : r.current) || s.current);
      }),
      r ? null : O.jsx(_e.div, { ...i, ref: l })
    );
  });
Mv.displayName = Lv;
var zf = "PopperContent",
  [G8, Z8] = Av(zf),
  Ov = E.forwardRef((e, t) => {
    var z, W, Y, Q, oe, he;
    const {
        __scopePopper: n,
        side: r = "bottom",
        sideOffset: i = 0,
        align: o = "center",
        alignOffset: s = 0,
        arrowPadding: l = 0,
        avoidCollisions: a = !0,
        collisionBoundary: u = [],
        collisionPadding: c = 0,
        sticky: d = "partial",
        hideWhenDetached: f = !1,
        updatePositionStrategy: h = "optimized",
        onPlaced: p,
        ...g
      } = e,
      x = Iv(zf, n),
      [b, m] = E.useState(null),
      v = ze(t, (ke) => m(ke)),
      [_, k] = E.useState(null),
      w = K8(_),
      y = (w == null ? void 0 : w.width) ?? 0,
      S = (w == null ? void 0 : w.height) ?? 0,
      T = r + (o !== "center" ? "-" + o : ""),
      A = typeof c == "number" ? c : { top: 0, right: 0, bottom: 0, left: 0, ...c },
      F = Array.isArray(u) ? u : [u],
      R = F.length > 0,
      V = { padding: A, boundary: F.filter(Y8), altBoundary: R },
      {
        refs: B,
        floatingStyles: N,
        placement: G,
        isPositioned: U,
        middlewareData: X,
      } = R8({
        strategy: "fixed",
        placement: T,
        whileElementsMounted: (...ke) => nC(...ke, { animationFrame: h === "always" }),
        elements: { reference: x.anchor },
        middleware: [
          D8({ mainAxis: i + S, alignmentAxis: s }),
          a && $8({ mainAxis: !0, crossAxis: !1, limiter: d === "partial" ? B8() : void 0, ...V }),
          a && H8({ ...V }),
          V8({
            ...V,
            apply: ({ elements: ke, rects: De, availableWidth: Xe, availableHeight: Qe }) => {
              const { width: rt, height: gn } = De.reference,
                st = ke.floating.style;
              st.setProperty("--radix-popper-available-width", `${Xe}px`),
                st.setProperty("--radix-popper-available-height", `${Qe}px`),
                st.setProperty("--radix-popper-anchor-width", `${rt}px`),
                st.setProperty("--radix-popper-anchor-height", `${gn}px`);
            },
          }),
          _ && j8({ element: _, padding: l }),
          X8({ arrowWidth: y, arrowHeight: S }),
          f && z8({ strategy: "referenceHidden", ...V }),
        ],
      }),
      [te, L] = Pv(G),
      se = xr(p);
    xt(() => {
      U && (se == null || se());
    }, [U, se]);
    const pe = (z = X.arrow) == null ? void 0 : z.x,
      M = (W = X.arrow) == null ? void 0 : W.y,
      me = ((Y = X.arrow) == null ? void 0 : Y.centerOffset) !== 0,
      [Ee, ce] = E.useState();
    return (
      xt(() => {
        b && ce(window.getComputedStyle(b).zIndex);
      }, [b]),
      O.jsx("div", {
        ref: B.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...N,
          transform: U ? N.transform : "translate(0, -200%)",
          minWidth: "max-content",
          zIndex: Ee,
          "--radix-popper-transform-origin": [
            (Q = X.transformOrigin) == null ? void 0 : Q.x,
            (oe = X.transformOrigin) == null ? void 0 : oe.y,
          ].join(" "),
          ...(((he = X.hide) == null ? void 0 : he.referenceHidden) && { visibility: "hidden", pointerEvents: "none" }),
        },
        dir: e.dir,
        children: O.jsx(G8, {
          scope: n,
          placedSide: te,
          onArrowChange: k,
          arrowX: pe,
          arrowY: M,
          shouldHideArrow: me,
          children: O.jsx(_e.div, {
            "data-side": te,
            "data-align": L,
            ...g,
            ref: v,
            style: { ...g.style, animation: U ? void 0 : "none" },
          }),
        }),
      })
    );
  });
Ov.displayName = zf;
var Fv = "PopperArrow",
  q8 = { top: "bottom", right: "left", bottom: "top", left: "right" },
  Rv = E.forwardRef(function (t, n) {
    const { __scopePopper: r, ...i } = t,
      o = Z8(Fv, r),
      s = q8[o.placedSide];
    return O.jsx("span", {
      ref: o.onArrowChange,
      style: {
        position: "absolute",
        left: o.arrowX,
        top: o.arrowY,
        [s]: 0,
        transformOrigin: { top: "", right: "0 0", bottom: "center 0", left: "100% 0" }[o.placedSide],
        transform: {
          top: "translateY(100%)",
          right: "translateY(50%) rotate(90deg) translateX(-50%)",
          bottom: "rotate(180deg)",
          left: "translateY(50%) rotate(-90deg) translateX(50%)",
        }[o.placedSide],
        visibility: o.shouldHideArrow ? "hidden" : void 0,
      },
      children: O.jsx(W8, { ...i, ref: n, style: { ...i.style, display: "block" } }),
    });
  });
Rv.displayName = Fv;
function Y8(e) {
  return e !== null;
}
var X8 = (e) => ({
  name: "transformOrigin",
  options: e,
  fn(t) {
    var x, b, m;
    const { placement: n, rects: r, middlewareData: i } = t,
      s = ((x = i.arrow) == null ? void 0 : x.centerOffset) !== 0,
      l = s ? 0 : e.arrowWidth,
      a = s ? 0 : e.arrowHeight,
      [u, c] = Pv(n),
      d = { start: "0%", center: "50%", end: "100%" }[c],
      f = (((b = i.arrow) == null ? void 0 : b.x) ?? 0) + l / 2,
      h = (((m = i.arrow) == null ? void 0 : m.y) ?? 0) + a / 2;
    let p = "",
      g = "";
    return (
      u === "bottom"
        ? ((p = s ? d : `${f}px`), (g = `${-a}px`))
        : u === "top"
          ? ((p = s ? d : `${f}px`), (g = `${r.floating.height + a}px`))
          : u === "right"
            ? ((p = `${-a}px`), (g = s ? d : `${h}px`))
            : u === "left" && ((p = `${r.floating.width + a}px`), (g = s ? d : `${h}px`)),
      { data: { x: p, y: g } }
    );
  },
});
function Pv(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
var jf = Nv,
  Ra = Mv,
  Uf = Ov,
  Wf = Rv,
  Q8 = "Portal",
  Cs = E.forwardRef((e, t) => {
    var l;
    const { container: n, ...r } = e,
      [i, o] = E.useState(!1);
    xt(() => o(!0), []);
    const s = n || (i && ((l = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : l.body));
    return s ? W5.createPortal(O.jsx(_e.div, { ...r, ref: t }), s) : null;
  });
Cs.displayName = Q8;
function e4(e, t) {
  return E.useReducer((n, r) => t[n][r] ?? n, e);
}
var Er = (e) => {
  const { present: t, children: n } = e,
    r = t4(t),
    i = typeof n == "function" ? n({ present: r.isPresent }) : E.Children.only(n),
    o = ze(r.ref, n4(i));
  return typeof n == "function" || r.isPresent ? E.cloneElement(i, { ref: o }) : null;
};
Er.displayName = "Presence";
function t4(e) {
  const [t, n] = E.useState(),
    r = E.useRef(null),
    i = E.useRef(e),
    o = E.useRef("none"),
    s = e ? "mounted" : "unmounted",
    [l, a] = e4(s, {
      mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" },
      unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" },
      unmounted: { MOUNT: "mounted" },
    });
  return (
    E.useEffect(() => {
      const u = Vs(r.current);
      o.current = l === "mounted" ? u : "none";
    }, [l]),
    xt(() => {
      const u = r.current,
        c = i.current;
      if (c !== e) {
        const f = o.current,
          h = Vs(u);
        e
          ? a("MOUNT")
          : h === "none" || (u == null ? void 0 : u.display) === "none"
            ? a("UNMOUNT")
            : a(c && f !== h ? "ANIMATION_OUT" : "UNMOUNT"),
          (i.current = e);
      }
    }, [e, a]),
    xt(() => {
      if (t) {
        let u;
        const c = t.ownerDocument.defaultView ?? window,
          d = (h) => {
            const g = Vs(r.current).includes(h.animationName);
            if (h.target === t && g && (a("ANIMATION_END"), !i.current)) {
              const x = t.style.animationFillMode;
              (t.style.animationFillMode = "forwards"),
                (u = c.setTimeout(() => {
                  t.style.animationFillMode === "forwards" && (t.style.animationFillMode = x);
                }));
            }
          },
          f = (h) => {
            h.target === t && (o.current = Vs(r.current));
          };
        return (
          t.addEventListener("animationstart", f),
          t.addEventListener("animationcancel", d),
          t.addEventListener("animationend", d),
          () => {
            c.clearTimeout(u),
              t.removeEventListener("animationstart", f),
              t.removeEventListener("animationcancel", d),
              t.removeEventListener("animationend", d);
          }
        );
      } else a("ANIMATION_END");
    }, [t, a]),
    {
      isPresent: ["mounted", "unmountSuspended"].includes(l),
      ref: E.useCallback((u) => {
        (r.current = u ? getComputedStyle(u) : null), n(u);
      }, []),
    }
  );
}
function Vs(e) {
  return (e == null ? void 0 : e.animationName) || "none";
}
function n4(e) {
  var r, i;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get,
    n = t && "isReactWarning" in t && t.isReactWarning;
  return n
    ? e.ref
    : ((t = (i = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : i.get),
      (n = t && "isReactWarning" in t && t.isReactWarning),
      n ? e.props.ref : e.props.ref || e.ref);
}
var r4 = _1[" useInsertionEffect ".trim().toString()] || xt;
function Qn({ prop: e, defaultProp: t, onChange: n = () => {}, caller: r }) {
  const [i, o, s] = i4({ defaultProp: t, onChange: n }),
    l = e !== void 0,
    a = l ? e : i;
  {
    const c = E.useRef(e !== void 0);
    E.useEffect(() => {
      const d = c.current;
      d !== l &&
        console.warn(
          `${r} is changing from ${d ? "controlled" : "uncontrolled"} to ${
            l ? "controlled" : "uncontrolled"
          }. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`,
        ),
        (c.current = l);
    }, [l, r]);
  }
  const u = E.useCallback(
    (c) => {
      var d;
      if (l) {
        const f = o4(c) ? c(e) : c;
        f !== e && ((d = s.current) == null || d.call(s, f));
      } else o(c);
    },
    [l, e, o, s],
  );
  return [a, u];
}
function i4({ defaultProp: e, onChange: t }) {
  const [n, r] = E.useState(e),
    i = E.useRef(n),
    o = E.useRef(t);
  return (
    r4(() => {
      o.current = t;
    }, [t]),
    E.useEffect(() => {
      var s;
      i.current !== n && ((s = o.current) == null || s.call(o, n), (i.current = n));
    }, [n, i]),
    [n, r, o]
  );
}
function o4(e) {
  return typeof e == "function";
}
var Pa = "Popover",
  [Dv, sP] = ir(Pa, [oo]),
  _s = oo(),
  [s4, kr] = Dv(Pa),
  $v = (e) => {
    const { __scopePopover: t, children: n, open: r, defaultOpen: i, onOpenChange: o, modal: s = !1 } = e,
      l = _s(t),
      a = E.useRef(null),
      [u, c] = E.useState(!1),
      [d, f] = Qn({ prop: r, defaultProp: i ?? !1, onChange: o, caller: Pa });
    return O.jsx(jf, {
      ...l,
      children: O.jsx(s4, {
        scope: t,
        contentId: Zn(),
        triggerRef: a,
        open: d,
        onOpenChange: f,
        onOpenToggle: E.useCallback(() => f((h) => !h), [f]),
        hasCustomAnchor: u,
        onCustomAnchorAdd: E.useCallback(() => c(!0), []),
        onCustomAnchorRemove: E.useCallback(() => c(!1), []),
        modal: s,
        children: n,
      }),
    });
  };
$v.displayName = Pa;
var Bv = "PopoverAnchor",
  Hv = E.forwardRef((e, t) => {
    const { __scopePopover: n, ...r } = e,
      i = kr(Bv, n),
      o = _s(n),
      { onCustomAnchorAdd: s, onCustomAnchorRemove: l } = i;
    return E.useEffect(() => (s(), () => l()), [s, l]), O.jsx(Ra, { ...o, ...r, ref: t });
  });
Hv.displayName = Bv;
var Vv = "PopoverTrigger",
  Kf = E.forwardRef((e, t) => {
    const { __scopePopover: n, ...r } = e,
      i = kr(Vv, n),
      o = _s(n),
      s = ze(t, i.triggerRef),
      l = O.jsx(_e.button, {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": i.open,
        "aria-controls": i.contentId,
        "data-state": Kv(i.open),
        ...r,
        ref: s,
        onClick: ge(e.onClick, i.onOpenToggle),
      });
    return i.hasCustomAnchor ? l : O.jsx(Ra, { asChild: !0, ...o, children: l });
  });
Kf.displayName = Vv;
var Jf = "PopoverPortal",
  [l4, a4] = Dv(Jf, { forceMount: void 0 }),
  zv = (e) => {
    const { __scopePopover: t, forceMount: n, children: r, container: i } = e,
      o = kr(Jf, t);
    return O.jsx(l4, {
      scope: t,
      forceMount: n,
      children: O.jsx(Er, { present: n || o.open, children: O.jsx(Cs, { asChild: !0, container: i, children: r }) }),
    });
  };
zv.displayName = Jf;
var Ui = "PopoverContent",
  Da = E.forwardRef((e, t) => {
    const n = a4(Ui, e.__scopePopover),
      { forceMount: r = n.forceMount, ...i } = e,
      o = kr(Ui, e.__scopePopover);
    return O.jsx(Er, {
      present: r || o.open,
      children: o.modal ? O.jsx(c4, { ...i, ref: t }) : O.jsx(d4, { ...i, ref: t }),
    });
  });
Da.displayName = Ui;
var u4 = ji("PopoverContent.RemoveScroll"),
  c4 = E.forwardRef((e, t) => {
    const n = kr(Ui, e.__scopePopover),
      r = E.useRef(null),
      i = ze(t, r),
      o = E.useRef(!1);
    return (
      E.useEffect(() => {
        const s = r.current;
        if (s) return Id(s);
      }, []),
      O.jsx(Td, {
        as: u4,
        allowPinchZoom: !0,
        children: O.jsx(jv, {
          ...e,
          ref: i,
          trapFocus: n.open,
          disableOutsidePointerEvents: !0,
          onCloseAutoFocus: ge(e.onCloseAutoFocus, (s) => {
            var l;
            s.preventDefault(), o.current || (l = n.triggerRef.current) == null || l.focus();
          }),
          onPointerDownOutside: ge(
            e.onPointerDownOutside,
            (s) => {
              const l = s.detail.originalEvent,
                a = l.button === 0 && l.ctrlKey === !0,
                u = l.button === 2 || a;
              o.current = u;
            },
            { checkForDefaultPrevented: !1 },
          ),
          onFocusOutside: ge(e.onFocusOutside, (s) => s.preventDefault(), { checkForDefaultPrevented: !1 }),
        }),
      })
    );
  }),
  d4 = E.forwardRef((e, t) => {
    const n = kr(Ui, e.__scopePopover),
      r = E.useRef(!1),
      i = E.useRef(!1);
    return O.jsx(jv, {
      ...e,
      ref: t,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      onCloseAutoFocus: (o) => {
        var s, l;
        (s = e.onCloseAutoFocus) == null || s.call(e, o),
          o.defaultPrevented || (r.current || (l = n.triggerRef.current) == null || l.focus(), o.preventDefault()),
          (r.current = !1),
          (i.current = !1);
      },
      onInteractOutside: (o) => {
        var a, u;
        (a = e.onInteractOutside) == null || a.call(e, o),
          o.defaultPrevented || ((r.current = !0), o.detail.originalEvent.type === "pointerdown" && (i.current = !0));
        const s = o.target;
        ((u = n.triggerRef.current) == null ? void 0 : u.contains(s)) && o.preventDefault(),
          o.detail.originalEvent.type === "focusin" && i.current && o.preventDefault();
      },
    });
  }),
  jv = E.forwardRef((e, t) => {
    const {
        __scopePopover: n,
        trapFocus: r,
        onOpenAutoFocus: i,
        onCloseAutoFocus: o,
        disableOutsidePointerEvents: s,
        onEscapeKeyDown: l,
        onPointerDownOutside: a,
        onFocusOutside: u,
        onInteractOutside: c,
        ...d
      } = e,
      f = kr(Ui, n),
      h = _s(n);
    return (
      Hf(),
      O.jsx(Fa, {
        asChild: !0,
        loop: !0,
        trapped: r,
        onMountAutoFocus: i,
        onUnmountAutoFocus: o,
        children: O.jsx(ys, {
          asChild: !0,
          disableOutsidePointerEvents: s,
          onInteractOutside: c,
          onEscapeKeyDown: l,
          onPointerDownOutside: a,
          onFocusOutside: u,
          onDismiss: () => f.onOpenChange(!1),
          children: O.jsx(Uf, {
            "data-state": Kv(f.open),
            role: "dialog",
            id: f.contentId,
            ...h,
            ...d,
            ref: t,
            style: {
              ...d.style,
              "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
              "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
              "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
              "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
              "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)",
            },
          }),
        }),
      })
    );
  }),
  Uv = "PopoverClose",
  f4 = E.forwardRef((e, t) => {
    const { __scopePopover: n, ...r } = e,
      i = kr(Uv, n);
    return O.jsx(_e.button, { type: "button", ...r, ref: t, onClick: ge(e.onClick, () => i.onOpenChange(!1)) });
  });
f4.displayName = Uv;
var h4 = "PopoverArrow",
  Wv = E.forwardRef((e, t) => {
    const { __scopePopover: n, ...r } = e,
      i = _s(n);
    return O.jsx(Wf, { ...i, ...r, ref: t });
  });
Wv.displayName = h4;
function Kv(e) {
  return e ? "open" : "closed";
}
var Gf = $v,
  p4 = Hv,
  Zf = zv,
  g4 = Da,
  qf = Wv;
function Jv(e) {
  const t = e + "CollectionProvider",
    [n, r] = ir(t),
    [i, o] = n(t, { collectionRef: { current: null }, itemMap: new Map() }),
    s = (g) => {
      const { scope: x, children: b } = g,
        m = C.useRef(null),
        v = C.useRef(new Map()).current;
      return O.jsx(i, { scope: x, itemMap: v, collectionRef: m, children: b });
    };
  s.displayName = t;
  const l = e + "CollectionSlot",
    a = ji(l),
    u = C.forwardRef((g, x) => {
      const { scope: b, children: m } = g,
        v = o(l, b),
        _ = ze(x, v.collectionRef);
      return O.jsx(a, { ref: _, children: m });
    });
  u.displayName = l;
  const c = e + "CollectionItemSlot",
    d = "data-radix-collection-item",
    f = ji(c),
    h = C.forwardRef((g, x) => {
      const { scope: b, children: m, ...v } = g,
        _ = C.useRef(null),
        k = ze(x, _),
        w = o(c, b);
      return (
        C.useEffect(() => (w.itemMap.set(_, { ref: _, ...v }), () => void w.itemMap.delete(_))),
        O.jsx(f, { [d]: "", ref: k, children: m })
      );
    });
  h.displayName = c;
  function p(g) {
    const x = o(e + "CollectionConsumer", g);
    return C.useCallback(() => {
      const m = x.collectionRef.current;
      if (!m) return [];
      const v = Array.from(m.querySelectorAll(`[${d}]`));
      return Array.from(x.itemMap.values()).sort((w, y) => v.indexOf(w.ref.current) - v.indexOf(y.ref.current));
    }, [x.collectionRef, x.itemMap]);
  }
  return [{ Provider: s, Slot: u, ItemSlot: h }, p, r];
}
var m4 = E.createContext(void 0);
function $a(e) {
  const t = E.useContext(m4);
  return e || t || "ltr";
}
var Au = "rovingFocusGroup.onEntryFocus",
  x4 = { bubbles: !1, cancelable: !0 },
  ws = "RovingFocusGroup",
  [qc, Gv, v4] = Jv(ws),
  [b4, Ba] = ir(ws, [v4]),
  [y4, C4] = b4(ws),
  Zv = E.forwardRef((e, t) =>
    O.jsx(qc.Provider, {
      scope: e.__scopeRovingFocusGroup,
      children: O.jsx(qc.Slot, { scope: e.__scopeRovingFocusGroup, children: O.jsx(_4, { ...e, ref: t }) }),
    }),
  );
Zv.displayName = ws;
var _4 = E.forwardRef((e, t) => {
    const {
        __scopeRovingFocusGroup: n,
        orientation: r,
        loop: i = !1,
        dir: o,
        currentTabStopId: s,
        defaultCurrentTabStopId: l,
        onCurrentTabStopIdChange: a,
        onEntryFocus: u,
        preventScrollOnEntryFocus: c = !1,
        ...d
      } = e,
      f = E.useRef(null),
      h = ze(t, f),
      p = $a(o),
      [g, x] = Qn({ prop: s, defaultProp: l ?? null, onChange: a, caller: ws }),
      [b, m] = E.useState(!1),
      v = xr(u),
      _ = Gv(n),
      k = E.useRef(!1),
      [w, y] = E.useState(0);
    return (
      E.useEffect(() => {
        const S = f.current;
        if (S) return S.addEventListener(Au, v), () => S.removeEventListener(Au, v);
      }, [v]),
      O.jsx(y4, {
        scope: n,
        orientation: r,
        dir: p,
        loop: i,
        currentTabStopId: g,
        onItemFocus: E.useCallback((S) => x(S), [x]),
        onItemShiftTab: E.useCallback(() => m(!0), []),
        onFocusableItemAdd: E.useCallback(() => y((S) => S + 1), []),
        onFocusableItemRemove: E.useCallback(() => y((S) => S - 1), []),
        children: O.jsx(_e.div, {
          tabIndex: b || w === 0 ? -1 : 0,
          "data-orientation": r,
          ...d,
          ref: h,
          style: { outline: "none", ...e.style },
          onMouseDown: ge(e.onMouseDown, () => {
            k.current = !0;
          }),
          onFocus: ge(e.onFocus, (S) => {
            const T = !k.current;
            if (S.target === S.currentTarget && T && !b) {
              const A = new CustomEvent(Au, x4);
              if ((S.currentTarget.dispatchEvent(A), !A.defaultPrevented)) {
                const F = _().filter((G) => G.focusable),
                  R = F.find((G) => G.active),
                  V = F.find((G) => G.id === g),
                  N = [R, V, ...F].filter(Boolean).map((G) => G.ref.current);
                Xv(N, c);
              }
            }
            k.current = !1;
          }),
          onBlur: ge(e.onBlur, () => m(!1)),
        }),
      })
    );
  }),
  qv = "RovingFocusGroupItem",
  Yv = E.forwardRef((e, t) => {
    const { __scopeRovingFocusGroup: n, focusable: r = !0, active: i = !1, tabStopId: o, children: s, ...l } = e,
      a = Zn(),
      u = o || a,
      c = C4(qv, n),
      d = c.currentTabStopId === u,
      f = Gv(n),
      { onFocusableItemAdd: h, onFocusableItemRemove: p, currentTabStopId: g } = c;
    return (
      E.useEffect(() => {
        if (r) return h(), () => p();
      }, [r, h, p]),
      O.jsx(qc.ItemSlot, {
        scope: n,
        id: u,
        focusable: r,
        active: i,
        children: O.jsx(_e.span, {
          tabIndex: d ? 0 : -1,
          "data-orientation": c.orientation,
          ...l,
          ref: t,
          onMouseDown: ge(e.onMouseDown, (x) => {
            r ? c.onItemFocus(u) : x.preventDefault();
          }),
          onFocus: ge(e.onFocus, () => c.onItemFocus(u)),
          onKeyDown: ge(e.onKeyDown, (x) => {
            if (x.key === "Tab" && x.shiftKey) {
              c.onItemShiftTab();
              return;
            }
            if (x.target !== x.currentTarget) return;
            const b = k4(x, c.orientation, c.dir);
            if (b !== void 0) {
              if (x.metaKey || x.ctrlKey || x.altKey || x.shiftKey) return;
              x.preventDefault();
              let v = f()
                .filter((_) => _.focusable)
                .map((_) => _.ref.current);
              if (b === "last") v.reverse();
              else if (b === "prev" || b === "next") {
                b === "prev" && v.reverse();
                const _ = v.indexOf(x.currentTarget);
                v = c.loop ? S4(v, _ + 1) : v.slice(_ + 1);
              }
              setTimeout(() => Xv(v));
            }
          }),
          children: typeof s == "function" ? s({ isCurrentTabStop: d, hasTabStop: g != null }) : s,
        }),
      })
    );
  });
Yv.displayName = qv;
var w4 = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last",
};
function E4(e, t) {
  return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function k4(e, t, n) {
  const r = E4(e.key, n);
  if (
    !(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) &&
    !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r))
  )
    return w4[r];
}
function Xv(e, t = !1) {
  const n = document.activeElement;
  for (const r of e) if (r === n || (r.focus({ preventScroll: t }), document.activeElement !== n)) return;
}
function S4(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
var Qv = Zv,
  Yf = Yv,
  T4 = "Separator",
  mm = "horizontal",
  A4 = ["horizontal", "vertical"],
  eb = E.forwardRef((e, t) => {
    const { decorative: n, orientation: r = mm, ...i } = e,
      o = I4(r) ? r : mm,
      l = n ? { role: "none" } : { "aria-orientation": o === "vertical" ? o : void 0, role: "separator" };
    return O.jsx(_e.div, { "data-orientation": o, ...l, ...i, ref: t });
  });
eb.displayName = T4;
function I4(e) {
  return A4.includes(e);
}
var N4 = eb,
  tb = "Toggle",
  nb = E.forwardRef((e, t) => {
    const { pressed: n, defaultPressed: r, onPressedChange: i, ...o } = e,
      [s, l] = Qn({ prop: n, onChange: i, defaultProp: r ?? !1, caller: tb });
    return O.jsx(_e.button, {
      type: "button",
      "aria-pressed": s,
      "data-state": s ? "on" : "off",
      "data-disabled": e.disabled ? "" : void 0,
      ...o,
      ref: t,
      onClick: ge(e.onClick, () => {
        e.disabled || l(!s);
      }),
    });
  });
nb.displayName = tb;
var Sr = "ToggleGroup",
  [rb, ib] = ir(Sr, [Ba]),
  ob = Ba(),
  Xf = C.forwardRef((e, t) => {
    const { type: n, ...r } = e;
    if (n === "single") {
      const i = r;
      return O.jsx(L4, { ...i, ref: t });
    }
    if (n === "multiple") {
      const i = r;
      return O.jsx(M4, { ...i, ref: t });
    }
    throw new Error(`Missing prop \`type\` expected on \`${Sr}\``);
  });
Xf.displayName = Sr;
var [sb, lb] = rb(Sr),
  L4 = C.forwardRef((e, t) => {
    const { value: n, defaultValue: r, onValueChange: i = () => {}, ...o } = e,
      [s, l] = Qn({ prop: n, defaultProp: r ?? "", onChange: i, caller: Sr });
    return O.jsx(sb, {
      scope: e.__scopeToggleGroup,
      type: "single",
      value: C.useMemo(() => (s ? [s] : []), [s]),
      onItemActivate: l,
      onItemDeactivate: C.useCallback(() => l(""), [l]),
      children: O.jsx(ab, { ...o, ref: t }),
    });
  }),
  M4 = C.forwardRef((e, t) => {
    const { value: n, defaultValue: r, onValueChange: i = () => {}, ...o } = e,
      [s, l] = Qn({ prop: n, defaultProp: r ?? [], onChange: i, caller: Sr }),
      a = C.useCallback((c) => l((d = []) => [...d, c]), [l]),
      u = C.useCallback((c) => l((d = []) => d.filter((f) => f !== c)), [l]);
    return O.jsx(sb, {
      scope: e.__scopeToggleGroup,
      type: "multiple",
      value: s,
      onItemActivate: a,
      onItemDeactivate: u,
      children: O.jsx(ab, { ...o, ref: t }),
    });
  });
Xf.displayName = Sr;
var [O4, F4] = rb(Sr),
  ab = C.forwardRef((e, t) => {
    const {
        __scopeToggleGroup: n,
        disabled: r = !1,
        rovingFocus: i = !0,
        orientation: o,
        dir: s,
        loop: l = !0,
        ...a
      } = e,
      u = ob(n),
      c = $a(s),
      d = { role: "group", dir: c, ...a };
    return O.jsx(O4, {
      scope: n,
      rovingFocus: i,
      disabled: r,
      children: i
        ? O.jsx(Qv, { asChild: !0, ...u, orientation: o, dir: c, loop: l, children: O.jsx(_e.div, { ...d, ref: t }) })
        : O.jsx(_e.div, { ...d, ref: t }),
    });
  }),
  Rl = "ToggleGroupItem",
  ub = C.forwardRef((e, t) => {
    const n = lb(Rl, e.__scopeToggleGroup),
      r = F4(Rl, e.__scopeToggleGroup),
      i = ob(e.__scopeToggleGroup),
      o = n.value.includes(e.value),
      s = r.disabled || e.disabled,
      l = { ...e, pressed: o, disabled: s },
      a = C.useRef(null);
    return r.rovingFocus
      ? O.jsx(Yf, { asChild: !0, ...i, focusable: !s, active: o, ref: a, children: O.jsx(xm, { ...l, ref: t }) })
      : O.jsx(xm, { ...l, ref: t });
  });
ub.displayName = Rl;
var xm = C.forwardRef((e, t) => {
    const { __scopeToggleGroup: n, value: r, ...i } = e,
      o = lb(Rl, n),
      s = { role: "radio", "aria-checked": e.pressed, "aria-pressed": void 0 },
      l = o.type === "single" ? s : void 0;
    return O.jsx(nb, {
      ...l,
      ...i,
      ref: t,
      onPressedChange: (a) => {
        a ? o.onItemActivate(r) : o.onItemDeactivate(r);
      },
    });
  }),
  R4 = Xf,
  P4 = ub,
  Qf = "Toolbar",
  [D4, lP] = ir(Qf, [Ba, ib]),
  eh = Ba(),
  cb = ib(),
  [$4, db] = D4(Qf),
  fb = E.forwardRef((e, t) => {
    const { __scopeToolbar: n, orientation: r = "horizontal", dir: i, loop: o = !0, ...s } = e,
      l = eh(n),
      a = $a(i);
    return O.jsx($4, {
      scope: n,
      orientation: r,
      dir: a,
      children: O.jsx(Qv, {
        asChild: !0,
        ...l,
        orientation: r,
        dir: a,
        loop: o,
        children: O.jsx(_e.div, { role: "toolbar", "aria-orientation": r, dir: a, ...s, ref: t }),
      }),
    });
  });
fb.displayName = Qf;
var hb = "ToolbarSeparator",
  pb = E.forwardRef((e, t) => {
    const { __scopeToolbar: n, ...r } = e,
      i = db(hb, n);
    return O.jsx(N4, { orientation: i.orientation === "horizontal" ? "vertical" : "horizontal", ...r, ref: t });
  });
pb.displayName = hb;
var B4 = "ToolbarButton",
  th = E.forwardRef((e, t) => {
    const { __scopeToolbar: n, ...r } = e,
      i = eh(n);
    return O.jsx(Yf, {
      asChild: !0,
      ...i,
      focusable: !e.disabled,
      children: O.jsx(_e.button, { type: "button", ...r, ref: t }),
    });
  });
th.displayName = B4;
var H4 = "ToolbarLink",
  V4 = E.forwardRef((e, t) => {
    const { __scopeToolbar: n, ...r } = e,
      i = eh(n);
    return O.jsx(Yf, {
      asChild: !0,
      ...i,
      focusable: !0,
      children: O.jsx(_e.a, {
        ...r,
        ref: t,
        onKeyDown: ge(e.onKeyDown, (o) => {
          o.key === " " && o.currentTarget.click();
        }),
      }),
    });
  });
V4.displayName = H4;
var gb = "ToolbarToggleGroup",
  mb = E.forwardRef((e, t) => {
    const { __scopeToolbar: n, ...r } = e,
      i = db(gb, n),
      o = cb(n);
    return O.jsx(R4, { "data-orientation": i.orientation, dir: i.dir, ...o, ...r, ref: t, rovingFocus: !1 });
  });
mb.displayName = gb;
var z4 = "ToolbarToggleItem",
  xb = E.forwardRef((e, t) => {
    const { __scopeToolbar: n, ...r } = e,
      i = cb(n),
      o = { __scopeToolbar: e.__scopeToolbar };
    return O.jsx(th, { asChild: !0, ...o, children: O.jsx(P4, { ...i, ...r, ref: t }) });
  });
xb.displayName = z4;
var nh = fb,
  vb = pb,
  hr = th,
  Ha = mb,
  ol = xb;
function rh(e, t) {
  return e === null || e === t
    ? !1
    : e.dataset.editorDialog !== void 0 || e.dataset.toolbarItem !== void 0 || e.dataset.editorDropdown
      ? !0
      : rh(e.parentElement, t);
}
function j4() {
  const e = [...Array(256).keys()].map((n) => n.toString(16).padStart(2, "0")),
    t = crypto.getRandomValues(new Uint8Array(16));
  return (
    (t[6] = (t[6] & 15) | 64),
    (t[8] = (t[8] & 63) | 128),
    [...t.entries()].map(([n, r]) => ([4, 6, 8, 10].includes(n) ? `-${e[r]}` : e[r])).join("")
  );
}
const bb = (e) => (e === 0 ? "th" : "td"),
  yb = { center: D.centeredCell, left: D.leftAlignedCell, right: D.rightAlignedCell },
  U4 = ({ mdastNode: e, parentEditor: t, lexicalTable: n }) => {
    const [r, i] = C.useState(null),
      [o, s] = Le(Ke, ct),
      l = C.useMemo(() => (g) => (g.__cacheKey || (g.__cacheKey = j4()), g.__cacheKey), []),
      a = C.useCallback(
        (g) => {
          const x = n.getColCount();
          if (g === null) {
            i(null);
            return;
          }
          let [b, m] = g;
          if ((b > x - 1 && ((b = 0), m++), b < 0 && ((b = x - 1), (m -= 1)), m > n.getRowCount() - 1)) {
            i(null),
              t.update(() => {
                if (n.getLatest().getNextSibling()) n.getLatest().selectNext();
                else {
                  const _ = Se();
                  n.insertAfter(_), _.select();
                }
              });
            return;
          }
          if (m < 0) {
            i(null),
              t.update(() => {
                n.getLatest().selectPrevious();
              });
            return;
          }
          i([b, m]);
        },
        [n, t],
      );
    C.useEffect(() => {
      n.focusEmitter.subscribe(a);
    }, [n, a]);
    const u = C.useCallback(
        (g) => {
          g.preventDefault(),
            t.update(() => {
              n.addRowToBottom(), i([0, n.getRowCount()]);
            });
        },
        [t, n],
      ),
      c = C.useCallback(
        (g) => {
          g.preventDefault(),
            t.update(() => {
              n.addColumnToRight(), i([n.getColCount(), 0]);
            });
        },
        [t, n],
      ),
      [d, f] = C.useState([-1, -1]),
      h = C.useCallback((g) => {
        let x = g.target;
        for (; x && !["TH", "TD"].includes(x.tagName); ) {
          if (x === g.currentTarget) return;
          x = x.parentElement;
        }
        if (x === null) return;
        const b = x.parentElement,
          v = b.parentElement.tagName === "TFOOT" ? -1 : Array.from(b.children).indexOf(x),
          _ = x.tagName === "TH" ? -1 : Array.from(b.parentElement.children).indexOf(b);
        f([v, _]);
      }, []),
      p = Fe();
    return C.createElement(
      "table",
      {
        className: D.tableEditor,
        onMouseOver: h,
        onMouseLeave: () => {
          f([-1, -1]);
        },
      },
      C.createElement(
        "colgroup",
        null,
        s ? null : C.createElement("col", null),
        Array.from({ length: e.children[0].children.length }, (g, x) => {
          const m = (e.align ?? [])[x] ?? "left",
            v = yb[m];
          return C.createElement("col", { key: x, className: v });
        }),
        s ? null : C.createElement("col", null),
      ),
      s ||
        C.createElement(
          "thead",
          null,
          C.createElement(
            "tr",
            null,
            C.createElement("th", { className: D.tableToolsColumn }),
            Array.from({ length: e.children[0].children.length }, (g, x) =>
              C.createElement(
                "th",
                { key: x, "data-tool-cell": !0 },
                C.createElement(J4, {
                  setActiveCellWithBoundaries: a,
                  parentEditor: t,
                  colIndex: x,
                  highlightedCoordinates: d,
                  lexicalTable: n,
                  align: (e.align ?? [])[x],
                }),
              ),
            ),
            C.createElement(
              "th",
              { className: D.tableToolsColumn, "data-tool-cell": !0 },
              C.createElement(
                "button",
                {
                  className: D.iconButton,
                  type: "button",
                  title: p("table.deleteTable", "Delete table"),
                  onClick: (g) => {
                    g.preventDefault(),
                      t.update(() => {
                        n.selectNext(), n.remove();
                      });
                  },
                },
                o("delete_small"),
              ),
            ),
          ),
        ),
      C.createElement(
        "tbody",
        null,
        e.children.map((g, x) => {
          const b = bb(x);
          return C.createElement(
            "tr",
            { key: x },
            s ||
              C.createElement(
                b,
                { className: D.toolCell, "data-tool-cell": !0 },
                C.createElement(G4, {
                  setActiveCellWithBoundaries: a,
                  parentEditor: t,
                  rowIndex: x,
                  highlightedCoordinates: d,
                  lexicalTable: n,
                }),
              ),
            g.children.map((m, v) => {
              var _;
              return C.createElement(W4, {
                align: (_ = e.align) == null ? void 0 : _[v],
                key: l(m),
                contents: m.children,
                setActiveCell: a,
                rowIndex: x,
                colIndex: v,
                lexicalTable: n,
                parentEditor: t,
                activeCell: s ? [-1, -1] : r,
              });
            }),
            s ||
              (x === 0 &&
                C.createElement(
                  "th",
                  { rowSpan: n.getRowCount(), "data-tool-cell": !0 },
                  C.createElement(
                    "button",
                    { type: "button", className: D.addColumnButton, onClick: c },
                    o("add_column"),
                  ),
                )),
          );
        }),
      ),
      s ||
        C.createElement(
          "tfoot",
          null,
          C.createElement(
            "tr",
            null,
            C.createElement("th", null),
            C.createElement(
              "th",
              { colSpan: n.getColCount() },
              C.createElement("button", { type: "button", className: D.addRowButton, onClick: u }, o("add_row")),
            ),
            C.createElement("th", null),
          ),
        ),
    );
  },
  W4 = ({ align: e, ...t }) => {
    const { activeCell: n, setActiveCell: r } = t,
      i = !!(n && n[0] === t.colIndex && n[1] === t.rowIndex),
      o = yb[e ?? "left"],
      s = bb(t.rowIndex);
    return C.createElement(
      s,
      {
        className: o,
        "data-active": i,
        onClick: () => {
          r([t.colIndex, t.rowIndex]);
        },
      },
      C.createElement(K4, { ...t, focus: i }),
    );
  },
  K4 = ({ focus: e, setActiveCell: t, parentEditor: n, lexicalTable: r, contents: i, colIndex: o, rowIndex: s }) => {
    const [l, a, u, c, d, f, h, p] = Le(Ta, Ia, Aa, Na, Bi, no, Lf, Ht),
      [g] = C.useState(() => {
        const b = rf({ nodes: u, theme: ka });
        return (
          b.update(() => {
            Af({
              root: Ce(),
              mdastRoot: { type: "root", children: [{ type: "paragraph", children: i }] },
              visitors: l,
              jsxComponentDescriptors: c,
              directiveDescriptors: d,
              codeBlockEditorDescriptors: f,
            });
          }),
          b
        );
      }),
      x = C.useCallback(
        (b) => {
          g.getEditorState().read(() => {
            const m = kf({ root: Ce(), jsxComponentDescriptors: c, visitors: a, jsxIsAvailable: h });
            n.update(
              () => {
                r.updateCellContents(o, s, m.children[0].children);
              },
              { discrete: !0 },
            ),
              n.dispatchCommand(Qr, void 0);
          }),
            t(b);
        },
        [o, g, a, c, h, r, n, s, t],
      );
    return (
      C.useEffect(
        () =>
          yt(
            g.registerCommand(
              ra,
              (b) => {
                b.preventDefault();
                const m = b.shiftKey ? [o - 1, s] : [o + 1, s];
                return x(m), !0;
              },
              Bt,
            ),
            g.registerCommand(sa, () => (t([o, s]), !1), He),
            g.registerCommand(
              Oi,
              (b) => {
                b == null || b.preventDefault();
                const m = b != null && b.shiftKey ? [o, s - 1] : [o, s + 1];
                return x(m), !0;
              },
              Bt,
            ),
            g.registerCommand(
              la,
              (b) => {
                const m = b.relatedTarget;
                return rh(m, p.getRootElement()) ? !1 : (x(null), !0);
              },
              be,
            ),
            g.registerCommand(Qr, () => (x(null), !0), be),
          ),
        [o, g, p, s, x, t],
      ),
      C.useEffect(() => {
        e && g.focus();
      }, [e, g]),
      C.createElement(
        yv,
        { initialEditor: g },
        C.createElement(Pf, {
          contentEditable: C.createElement(Rf, null),
          placeholder: C.createElement("div", null),
          ErrorBoundary: Df,
        }),
        C.createElement(W0, null),
      )
    );
  },
  J4 = ({
    parentEditor: e,
    highlightedCoordinates: t,
    align: n,
    lexicalTable: r,
    colIndex: i,
    setActiveCellWithBoundaries: o,
  }) => {
    const [s, l] = Le(wr, Ke),
      a = C.useCallback(
        (f) => {
          e.update(() => {
            r.insertColumnAt(f);
          }),
            o([f, 0]);
        },
        [e, r, o],
      ),
      u = C.useCallback(
        (f) => {
          e.update(() => {
            r.deleteColumnAt(f);
          });
        },
        [e, r],
      ),
      c = C.useCallback(
        (f, h) => {
          e.update(() => {
            r.setColumnAlign(f, h);
          });
        },
        [e, r],
      ),
      d = Fe();
    return C.createElement(
      Gf,
      null,
      C.createElement(
        Kf,
        {
          className: D.tableColumnEditorTrigger,
          "data-active": t[0] === i + 1,
          title: d("table.columnMenu", "Column menu"),
        },
        l("more_horiz"),
      ),
      C.createElement(
        Zf,
        { container: s == null ? void 0 : s.current },
        C.createElement(
          Da,
          {
            className: we(D.tableColumnEditorPopoverContent),
            onOpenAutoFocus: (f) => {
              f.preventDefault();
            },
            sideOffset: 5,
            side: "top",
          },
          C.createElement(
            nh,
            { className: D.tableColumnEditorToolbar },
            C.createElement(
              Ha,
              {
                className: D.toggleGroupRoot,
                onValueChange: (f) => {
                  c(i, f);
                },
                value: n ?? "left",
                type: "single",
                "aria-label": d("table.textAlignment", "Text alignment"),
              },
              C.createElement(ol, { value: "left", title: d("table.alignLeft", "Align left") }, l("format_align_left")),
              C.createElement(
                ol,
                { value: "center", title: d("table.alignCenter", "Align center") },
                l("format_align_center"),
              ),
              C.createElement(
                ol,
                { value: "right", title: d("table.alignRight", "Align right") },
                l("format_align_right"),
              ),
            ),
            C.createElement(vb, null),
            C.createElement(
              hr,
              {
                onClick: a.bind(null, i),
                title: d("table.insertColumnLeft", "Insert a column to the left of this one"),
              },
              l("insert_col_left"),
            ),
            C.createElement(
              hr,
              {
                onClick: a.bind(null, i + 1),
                title: d("table.insertColumnRight", "Insert a column to the right of this one"),
              },
              l("insert_col_right"),
            ),
            C.createElement(
              hr,
              { onClick: u.bind(null, i), title: d("table.deleteColumn", "Delete this column") },
              l("delete_small"),
            ),
          ),
          C.createElement(qf, { className: D.popoverArrow }),
        ),
      ),
    );
  },
  G4 = ({
    parentEditor: e,
    highlightedCoordinates: t,
    lexicalTable: n,
    rowIndex: r,
    setActiveCellWithBoundaries: i,
  }) => {
    const [o, s] = Le(wr, Ke),
      l = C.useCallback(
        (c) => {
          e.update(() => {
            n.insertRowAt(c);
          }),
            i([0, c]);
        },
        [e, n, i],
      ),
      a = C.useCallback(
        (c) => {
          e.update(() => {
            n.deleteRowAt(c);
          });
        },
        [e, n],
      ),
      u = Fe();
    return C.createElement(
      Gf,
      null,
      C.createElement(
        Kf,
        { className: D.tableColumnEditorTrigger, "data-active": t[1] === r, title: u("table.rowMenu", "Row menu") },
        s("more_horiz"),
      ),
      C.createElement(
        Zf,
        { container: o == null ? void 0 : o.current },
        C.createElement(
          Da,
          {
            className: we(D.tableColumnEditorPopoverContent),
            onOpenAutoFocus: (c) => {
              c.preventDefault();
            },
            sideOffset: 5,
            side: "bottom",
          },
          C.createElement(
            nh,
            { className: D.tableColumnEditorToolbar },
            C.createElement(
              hr,
              { onClick: l.bind(null, r), title: u("table.insertRowAbove", "Insert a row above this one") },
              s("insert_row_above"),
            ),
            C.createElement(
              hr,
              { onClick: l.bind(null, r + 1), title: u("table.insertRowBelow", "Insert a row below this one") },
              s("insert_row_below"),
            ),
            C.createElement(
              hr,
              { onClick: a.bind(null, r), title: u("table.deleteRow", "Delete this row") },
              s("delete_small"),
            ),
          ),
          C.createElement(qf, { className: D.popoverArrow }),
        ),
      ),
    );
  };
var Z4 = Object.defineProperty,
  q4 = (e, t, n) => (t in e ? Z4(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (e[t] = n)),
  vm = (e, t, n) => (q4(e, typeof t != "symbol" ? t + "" : t, n), n);
const bm = { type: "tableCell", children: [] };
function Y4() {
  let e = Pr;
  return {
    publish: (t) => {
      e(t);
    },
    subscribe: (t) => {
      e = t;
    },
  };
}
class so extends Cr {
  constructor(t, n) {
    super(n),
      vm(this, "__mdastNode"),
      vm(this, "focusEmitter", Y4()),
      (this.__mdastNode = t ?? { type: "table", children: [] });
  }
  static getType() {
    return "table";
  }
  static clone(t) {
    return new so(structuredClone(t.__mdastNode), t.__key);
  }
  static importJSON(t) {
    return ih(t.mdastNode);
  }
  static importDOM() {
    return { table: () => ({ conversion: Q4, priority: 3 }) };
  }
  exportJSON() {
    return { mdastNode: structuredClone(this.__mdastNode), type: "table", version: 1 };
  }
  getMdastNode() {
    return this.__mdastNode;
  }
  getRowCount() {
    return this.__mdastNode.children.length;
  }
  getColCount() {
    var t;
    return ((t = this.__mdastNode.children[0]) == null ? void 0 : t.children.length) || 0;
  }
  createDOM() {
    return document.createElement("div");
  }
  updateDOM() {
    return !1;
  }
  updateCellContents(t, n, r) {
    const o = this.getWritable().__mdastNode,
      s = o.children[n],
      l = s.children,
      a = l[t],
      u = Array.from(l),
      c = { ...a, children: r },
      d = { ...s, children: u };
    (u[t] = c), (o.children[n] = d);
  }
  insertColumnAt(t) {
    const r = this.getWritable().__mdastNode;
    for (let i = 0; i < r.children.length; i++) {
      const o = r.children[i],
        s = o.children,
        l = Array.from(s),
        a = { ...o, children: l };
      l.splice(t, 0, structuredClone(bm)), (r.children[i] = a);
    }
    r.align && r.align.length > 0 && r.align.splice(t, 0, "left");
  }
  deleteColumnAt(t) {
    const r = this.getWritable().__mdastNode;
    for (let i = 0; i < r.children.length; i++) {
      const o = r.children[i],
        s = o.children,
        l = Array.from(s),
        a = { ...o, children: l };
      l.splice(t, 1), (r.children[i] = a);
    }
  }
  insertRowAt(t) {
    const r = this.getWritable().__mdastNode,
      i = { type: "tableRow", children: Array.from({ length: this.getColCount() }, () => structuredClone(bm)) };
    r.children.splice(t, 0, i);
  }
  deleteRowAt(t) {
    this.getRowCount() === 1
      ? (this.selectNext(), this.remove())
      : this.getWritable().__mdastNode.children.splice(t, 1);
  }
  addRowToBottom() {
    this.insertRowAt(this.getRowCount());
  }
  addColumnToRight() {
    this.insertColumnAt(this.getColCount());
  }
  setColumnAlign(t, n) {
    const i = this.getWritable().__mdastNode;
    i.align == null && (i.align = []), (i.align[t] = n);
  }
  decorate(t) {
    return C.createElement(U4, { lexicalTable: this, mdastNode: this.__mdastNode, parentEditor: t });
  }
  select(t) {
    this.focusEmitter.publish(t ?? [0, 0]);
  }
  isInline() {
    return !1;
  }
}
function X4(e) {
  return e instanceof so;
}
function ih(e) {
  return new so(e);
}
function Q4(e) {
  const t = e.querySelectorAll("tr"),
    n = Array.from(t).map((r) => ({
      type: "tableRow",
      children: Array.from(r.querySelectorAll("td, th")).map((i) => ({
        type: "tableCell",
        children: [{ type: "text", value: i.textContent ?? "" }],
      })),
    }));
  return { node: new so({ type: "table", children: n }) };
}
const eA = {
    testLexicalNode: X4,
    visitLexicalNode({ actions: e, mdastParent: t, lexicalNode: n }) {
      e.appendToParent(t, n.getMdastNode());
    },
  },
  tA = {
    testNode: "table",
    visitNode({ mdastNode: e, lexicalParent: t }) {
      t.append(ih(e));
    },
  };
function nA(e = 1, t = 1) {
  const n = { type: "table", children: [] };
  for (let r = 0; r < e; r++) {
    const i = { type: "tableRow", children: [] };
    for (let o = 0; o < t; o++) {
      const s = { type: "tableCell", children: [] };
      i.children.push(s);
    }
    n.children.push(i);
  }
  return n;
}
const Cb = Ze((e) => {
    e.link(
      e.pipe(
        Cb,
        tn(
          ({ rows: t, columns: n }) =>
            () =>
              ih(nA(t, n)),
        ),
      ),
      Ma,
    );
  }),
  rA = vt({
    init(e, t) {
      e.pubIn({
        [Vi]: G6(),
        [Hi]: i8(),
        [Gt]: tA,
        [fn]: so,
        [hn]: eA,
        [vs]: e8({
          tableCellPadding: (t == null ? void 0 : t.tableCellPadding) ?? !0,
          tablePipeAlign: (t == null ? void 0 : t.tablePipeAlign) ?? !0,
        }),
      });
    },
  }),
  iA = new Set(["http:", "https:", "mailto:", "sms:", "tel:"]);
class or extends dn {
  static getType() {
    return "link";
  }
  static clone(t) {
    return new or(t.__url, { rel: t.__rel, target: t.__target, title: t.__title }, t.__key);
  }
  constructor(t = "", n = {}, r) {
    super(r);
    const { target: i = null, rel: o = null, title: s = null } = n;
    (this.__url = t), (this.__target = i), (this.__rel = o), (this.__title = s);
  }
  createDOM(t) {
    const n = document.createElement("a");
    return this.updateLinkDOM(null, n, t), un(n, t.theme.link), n;
  }
  updateLinkDOM(t, n, r) {
    if (A0(n)) {
      (t && t.__url === this.__url) || (n.href = this.sanitizeUrl(this.__url));
      for (const i of ["target", "rel", "title"]) {
        const o = `__${i}`,
          s = this[o];
        (t && t[o] === s) || (s ? (n[i] = s) : n.removeAttribute(i));
      }
    }
  }
  updateDOM(t, n, r) {
    return this.updateLinkDOM(t, n, r), !1;
  }
  static importDOM() {
    return { a: (t) => ({ conversion: oA, priority: 1 }) };
  }
  static importJSON(t) {
    return vr().updateFromJSON(t);
  }
  updateFromJSON(t) {
    return super
      .updateFromJSON(t)
      .setURL(t.url)
      .setRel(t.rel || null)
      .setTarget(t.target || null)
      .setTitle(t.title || null);
  }
  sanitizeUrl(t) {
    t = _m(t);
    try {
      const n = new URL(_m(t));
      if (!iA.has(n.protocol)) return "about:blank";
    } catch {
      return t;
    }
    return t;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      rel: this.getRel(),
      target: this.getTarget(),
      title: this.getTitle(),
      url: this.getURL(),
    };
  }
  getURL() {
    return this.getLatest().__url;
  }
  setURL(t) {
    const n = this.getWritable();
    return (n.__url = t), n;
  }
  getTarget() {
    return this.getLatest().__target;
  }
  setTarget(t) {
    const n = this.getWritable();
    return (n.__target = t), n;
  }
  getRel() {
    return this.getLatest().__rel;
  }
  setRel(t) {
    const n = this.getWritable();
    return (n.__rel = t), n;
  }
  getTitle() {
    return this.getLatest().__title;
  }
  setTitle(t) {
    const n = this.getWritable();
    return (n.__title = t), n;
  }
  insertNewAfter(t, n = !0) {
    const r = vr(this.__url, { rel: this.__rel, target: this.__target, title: this.__title });
    return this.insertAfter(r, n), r;
  }
  canInsertTextBefore() {
    return !1;
  }
  canInsertTextAfter() {
    return !1;
  }
  canBeEmpty() {
    return !1;
  }
  isInline() {
    return !0;
  }
  extractWithChild(t, n, r) {
    if (!H(n)) return !1;
    const i = n.anchor.getNode(),
      o = n.focus.getNode();
    return this.isParentOf(i) && this.isParentOf(o) && n.getTextContent().length > 0;
  }
  isEmailURI() {
    return this.__url.startsWith("mailto:");
  }
  isWebSiteURI() {
    return this.__url.startsWith("https://") || this.__url.startsWith("http://");
  }
}
function oA(e) {
  let t = null;
  if (A0(e)) {
    const n = e.textContent;
    ((n !== null && n !== "") || e.children.length > 0) &&
      (t = vr(e.getAttribute("href") || "", {
        rel: e.getAttribute("rel"),
        target: e.getAttribute("target"),
        title: e.getAttribute("title"),
      }));
  }
  return { node: t };
}
function vr(e = "", t) {
  return Mt(new or(e, t));
}
function zt(e) {
  return e instanceof or;
}
let Va = class _b extends or {
  constructor(t = "", n = {}, r) {
    super(t, n, r), (this.__isUnlinked = n.isUnlinked !== void 0 && n.isUnlinked !== null && n.isUnlinked);
  }
  static getType() {
    return "autolink";
  }
  static clone(t) {
    return new _b(t.__url, { isUnlinked: t.__isUnlinked, rel: t.__rel, target: t.__target, title: t.__title }, t.__key);
  }
  getIsUnlinked() {
    return this.__isUnlinked;
  }
  setIsUnlinked(t) {
    const n = this.getWritable();
    return (n.__isUnlinked = t), n;
  }
  createDOM(t) {
    return this.__isUnlinked ? document.createElement("span") : super.createDOM(t);
  }
  updateDOM(t, n, r) {
    return super.updateDOM(t, n, r) || t.__isUnlinked !== this.__isUnlinked;
  }
  static importJSON(t) {
    return Yc().updateFromJSON(t);
  }
  updateFromJSON(t) {
    return super.updateFromJSON(t).setIsUnlinked(t.isUnlinked || !1);
  }
  static importDOM() {
    return null;
  }
  exportJSON() {
    return { ...super.exportJSON(), isUnlinked: this.__isUnlinked };
  }
  insertNewAfter(t, n = !0) {
    const r = this.getParentOrThrow().insertNewAfter(t, n);
    if (P(r)) {
      const i = Yc(this.__url, {
        isUnlinked: this.__isUnlinked,
        rel: this.__rel,
        target: this.__target,
        title: this.__title,
      });
      return r.append(i), i;
    }
    return null;
  }
};
function Yc(e = "", t) {
  return Mt(new Va(e, t));
}
function _n(e) {
  return e instanceof Va;
}
const Wi = ae("TOGGLE_LINK_COMMAND");
function ym(e, t) {
  if (e.type === "element") {
    const n = e.getNode();
    return (
      P(n) ||
        (function (r, ...i) {
          const o = new URL("https://lexical.dev/docs/error"),
            s = new URLSearchParams();
          s.append("code", r);
          for (const l of i) s.append("v", l);
          throw (
            ((o.search = s.toString()),
            Error(
              `Minified Lexical error #${r}; visit ${o.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`,
            ))
          );
        })(252),
      n.getChildren()[e.offset + t] || null
    );
  }
  return null;
}
function Iu(e, t = {}) {
  const { target: n, title: r } = t,
    i = t.rel === void 0 ? "noreferrer" : t.rel,
    o = J();
  if (o === null || (!H(o) && !Je(o))) return;
  if (Je(o)) {
    const u = o.getNodes();
    return u.length === 0
      ? void 0
      : void u.forEach((c) => {
          if (e === null) {
            const d = on(c, (f) => !_n(f) && zt(f));
            d && (d.insertBefore(c), d.getChildren().length === 0 && d.remove());
          } else {
            const d = on(c, (f) => !_n(f) && zt(f));
            if (d) d.setURL(e), n !== void 0 && d.setTarget(n), i !== void 0 && d.setRel(i);
            else {
              const f = vr(e, { rel: i, target: n });
              c.insertBefore(f), f.append(c);
            }
          }
        });
  }
  const s = o.extract();
  if (e === null)
    return void s.forEach((u) => {
      const c = on(u, (d) => !_n(d) && zt(d));
      if (c) {
        const d = c.getChildren();
        for (let f = 0; f < d.length; f++) c.insertBefore(d[f]);
        c.remove();
      }
    });
  const l = new Set(),
    a = (u) => {
      l.has(u.getKey()) ||
        (l.add(u.getKey()),
        u.setURL(e),
        n !== void 0 && u.setTarget(n),
        i !== void 0 && u.setRel(i),
        r !== void 0 && u.setTitle(r));
    };
  if (s.length === 1) {
    const u = Cm(s[0], zt);
    if (u !== null) return a(u);
  }
  (function (u) {
    const c = J();
    if (!H(c)) return u();
    const d = Kr(c),
      f = d.isBackward(),
      h = ym(d.anchor, f ? -1 : 0),
      p = ym(d.focus, f ? 0 : -1);
    if ((u(), h || p)) {
      const g = J();
      if (H(g)) {
        const x = g.clone();
        if (h) {
          const b = h.getParent();
          b && x.anchor.set(b.getKey(), h.getIndexWithinParent() + (f ? 1 : 0), "element");
        }
        if (p) {
          const b = p.getParent();
          b && x.focus.set(b.getKey(), p.getIndexWithinParent() + (f ? 0 : 1), "element");
        }
        Ye(Kr(x));
      }
    }
  })(() => {
    let u = null;
    for (const c of s) {
      if (!c.isAttached()) continue;
      const d = Cm(c, zt);
      if (d) {
        a(d);
        continue;
      }
      if (P(c)) {
        if (!c.isInline()) continue;
        if (zt(c)) {
          if (!(_n(c) || (u !== null && u.getParentOrThrow().isParentOf(c)))) {
            a(c), (u = c);
            continue;
          }
          for (const h of c.getChildren()) c.insertBefore(h);
          c.remove();
          continue;
        }
      }
      const f = c.getPreviousSibling();
      zt(f) && f.is(u) ? f.append(c) : ((u = vr(e, { rel: i, target: n, title: r })), c.insertAfter(u), u.append(c));
    }
  });
}
function Cm(e, t) {
  let n = e;
  for (; n !== null && n.getParent() !== null && !t(n); ) n = n.getParentOrThrow();
  return t(n) ? n : null;
}
const sA = /^\+?[0-9\s()-]{5,}$/;
function _m(e) {
  return e.match(/^[a-z][a-z0-9+.-]*:/i) || e.match(/^[/#.]/)
    ? e
    : e.includes("@")
      ? `mailto:${e}`
      : sA.test(e)
        ? `tel:${e}`
        : `https://${e}`;
}
const lA = {
    testNode: "link",
    visitNode({ mdastNode: e, actions: t }) {
      t.addAndStepInto(vr(e.url, { title: e.title }));
    },
  },
  aA = {
    testLexicalNode: zt,
    visitLexicalNode: ({ lexicalNode: e, actions: t }) => {
      t.addAndStepInto("link", { url: e.getURL(), title: e.getTitle() });
    },
  };
function uA({ validateUrl: e, attributes: t }) {
  const [n] = bt();
  return (
    E.useEffect(() => {
      if (!n.hasNodes([or])) throw new Error("LinkPlugin: LinkNode not registered on editor");
      return yt(
        n.registerCommand(
          Wi,
          (r) => {
            if (r === null) return Iu(r), !0;
            if (typeof r == "string") return !(e !== void 0 && !e(r)) && (Iu(r, t), !0);
            {
              const { url: i, target: o, rel: s, title: l } = r;
              return Iu(i, { ...t, rel: s, target: o, title: l }), !0;
            }
          },
          He,
        ),
        e !== void 0
          ? n.registerCommand(
              ss,
              (r) => {
                const i = J();
                if (!H(i) || i.isCollapsed() || !dr(r, ClipboardEvent) || r.clipboardData === null) return !1;
                const o = r.clipboardData.getData("text");
                return (
                  !!e(o) &&
                  !i.getNodes().some((s) => P(s)) &&
                  (n.dispatchCommand(Wi, { ...t, url: o }), r.preventDefault(), !0)
                );
              },
              He,
            )
          : () => {},
      );
    }, [n, e, t]),
    null
  );
}
function wm(e, t = (n) => n) {
  return (n) => {
    const r = e.exec(n);
    return r === null ? null : { index: r.index, length: r[0].length, text: r[0], url: t(r[0]) };
  };
}
function wb(e, t) {
  for (let n = 0; n < t.length; n++) {
    const r = t[n](e);
    if (r) return r;
  }
  return null;
}
const cA = /[.,;\s]/;
function Pl(e) {
  return cA.test(e);
}
function Eb(e) {
  return Pl(e[e.length - 1]);
}
function Xc(e) {
  return Pl(e[0]);
}
function kb(e) {
  let t = e.getPreviousSibling();
  return P(t) && (t = t.getLastDescendant()), t === null || rn(t) || (Z(t) && Eb(t.getTextContent()));
}
function Sb(e) {
  let t = e.getNextSibling();
  return P(t) && (t = t.getFirstDescendant()), t === null || rn(t) || (Z(t) && Xc(t.getTextContent()));
}
function dA(e, t, n, r) {
  return (e > 0 ? Pl(n[e - 1]) : kb(r[0])) ? (t < n.length ? Pl(n[t]) : Sb(r[r.length - 1])) : !1;
}
function fA(e, t, n) {
  const r = [],
    i = [],
    o = [];
  let s = 0,
    l = 0;
  const a = [...e];
  for (; a.length > 0; ) {
    const u = a[0],
      c = u.getTextContent().length,
      d = l;
    l + c <= t ? (r.push(u), (s += c)) : d >= n ? o.push(u) : i.push(u), (l += c), a.shift();
  }
  return [s, r, i, o];
}
function hA(e, t, n, r) {
  const i = Yc(r.url, r.attributes);
  if (e.length === 1) {
    let o,
      s = e[0];
    t === 0 ? ([o, s] = s.splitText(n)) : ([, o, s] = s.splitText(t, n));
    const l = Be(r.text);
    return (
      l.setFormat(o.getFormat()), l.setDetail(o.getDetail()), l.setStyle(o.getStyle()), i.append(l), o.replace(i), s
    );
  }
  if (e.length > 1) {
    const o = e[0];
    let s,
      l = o.getTextContent().length;
    t === 0 ? (s = o) : ([, s] = o.splitText(t));
    const a = [];
    let u;
    for (let h = 1; h < e.length; h++) {
      const p = e[h],
        g = p.getTextContent().length,
        x = l;
      if (x < n)
        if (l + g <= n) a.push(p);
        else {
          const [b, m] = p.splitText(n - x);
          a.push(b), (u = m);
        }
      l += g;
    }
    const c = J(),
      d = c ? c.getNodes().find(Z) : void 0,
      f = Be(s.getTextContent());
    return (
      f.setFormat(s.getFormat()),
      f.setDetail(s.getDetail()),
      f.setStyle(s.getStyle()),
      i.append(f, ...a),
      d &&
        d === s &&
        (H(c) ? f.select(c.anchor.offset, c.focus.offset) : Je(c) && f.select(0, f.getTextContent().length)),
      s.replace(i),
      u
    );
  }
}
function Nu(e, t, n) {
  const r = e.getChildren(),
    i = r.length;
  for (let a = 0; a < i; a++) {
    const u = r[a];
    if (!Z(u) || !u.isSimpleText()) return sl(e), void n(null, e.getURL());
  }
  const o = e.getTextContent(),
    s = wb(o, t);
  if (s === null || s.text !== o || !kb(e) || !Sb(e)) return sl(e), void n(null, e.getURL());
  const l = e.getURL();
  if ((l !== s.url && (e.setURL(s.url), n(s.url, l)), s.attributes)) {
    const a = e.getRel();
    a !== s.attributes.rel && (e.setRel(s.attributes.rel || null), n(s.attributes.rel || null, a));
    const u = e.getTarget();
    u !== s.attributes.target && (e.setTarget(s.attributes.target || null), n(s.attributes.target || null, u));
  }
}
function sl(e) {
  const t = e.getChildren();
  for (let n = t.length - 1; n >= 0; n--) e.insertAfter(t[n]);
  return e.remove(), t.map((n) => n.getLatest());
}
function pA(e, t, n) {
  E.useEffect(() => {
    e.hasNodes([Va]) ||
      (function (i, ...o) {
        const s = new URL("https://lexical.dev/docs/error"),
          l = new URLSearchParams();
        l.append("code", i);
        for (const a of o) l.append("v", a);
        throw (
          ((s.search = l.toString()),
          Error(
            `Minified Lexical error #${i}; visit ${s.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`,
          ))
        );
      })(77);
    const r = (i, o) => {
      n && n(i, o);
    };
    return yt(
      e.registerNodeTransform(Ln, (i) => {
        const o = i.getParentOrThrow(),
          s = i.getPreviousSibling();
        if (_n(o) && !o.getIsUnlinked()) Nu(o, t, r);
        else if (!zt(o)) {
          if (i.isSimpleText() && (Xc(i.getTextContent()) || !_n(s))) {
            const l = (function (a) {
              const u = [a];
              let c = a.getNextSibling();
              for (; c !== null && Z(c) && c.isSimpleText() && (u.push(c), !/[\s]/.test(c.getTextContent())); )
                c = c.getNextSibling();
              return u;
            })(i);
            (function (a, u, c) {
              let d = [...a];
              const f = d.map((x) => x.getTextContent()).join("");
              let h,
                p = f,
                g = 0;
              for (; (h = wb(p, u)) && h !== null; ) {
                const x = h.index,
                  b = x + h.length;
                if (dA(g + x, g + b, f, d)) {
                  const [m, , v, _] = fA(d, g + x, g + b),
                    k = hA(v, g + x - m, g + b - m, h);
                  (d = k ? [k, ..._] : _), c(h.url, null), (g = 0);
                } else g += b;
                p = p.substring(b);
              }
            })(l, t, r);
          }
          (function (l, a, u) {
            const c = l.getPreviousSibling(),
              d = l.getNextSibling(),
              f = l.getTextContent();
            var h;
            !_n(c) ||
              c.getIsUnlinked() ||
              (Xc(f) && ((h = f), !(c.isEmailURI() ? /^\.[a-zA-Z]{2,}/.test(h) : /^\.[a-zA-Z0-9]{1,}/.test(h)))) ||
              (c.append(l), Nu(c, a, u), u(null, c.getURL())),
              !_n(d) || d.getIsUnlinked() || Eb(f) || (sl(d), Nu(d, a, u), u(null, d.getURL()));
          })(i, t, r);
        }
      }),
      e.registerCommand(
        Wi,
        (i) => {
          const o = J();
          return (
            i !== null ||
              !H(o) ||
              o.extract().forEach((s) => {
                const l = s.getParent();
                if (_n(l)) return l.setIsUnlinked(!l.getIsUnlinked()), l.markDirty(), !0;
              }),
            !1
          );
        },
        He,
      ),
    );
  }, [e, t, n]);
}
function gA({ matchers: e, onChange: t }) {
  const [n] = bt();
  return pA(n, e, t), null;
}
const mA =
    /((https?:\/\/(www\.)?)|(www\.))[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)/,
  xA =
    /(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))/,
  vA = [wm(mA, (e) => (e.startsWith("http") ? e : `https://${e}`)), wm(xA, (e) => `mailto:${e}`)],
  bA = () => C.createElement(gA, { matchers: vA }),
  yA = ne(!1),
  CA = vt({
    init(e, t) {
      const n = !!(t != null && t.disableAutoLink),
        r = t != null && t.validateUrl ? { validateUrl: t.validateUrl } : {};
      e.pubIn({
        [ro]: "link",
        [Gt]: lA,
        [fn]: [or, Va],
        [hn]: aA,
        [yA]: n,
        [ai]: () =>
          C.createElement(C.Fragment, null, C.createElement(uA, { ...r }), n ? null : C.createElement(bA, null)),
      });
    },
  });
function _A(e, t) {
  if (e == null) return {};
  var n = {},
    r = Object.keys(e),
    i,
    o;
  for (o = 0; o < r.length; o++) (i = r[o]), !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var wA = ["color"],
  EA = E.forwardRef(function (e, t) {
    var n = e.color,
      r = n === void 0 ? "currentColor" : n,
      i = _A(e, wA);
    return E.createElement(
      "svg",
      Object.assign(
        { width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
        i,
        { ref: t },
      ),
      E.createElement("path", {
        d: "M2.5 1H12.5C13.3284 1 14 1.67157 14 2.5V12.5C14 13.3284 13.3284 14 12.5 14H2.5C1.67157 14 1 13.3284 1 12.5V2.5C1 1.67157 1.67157 1 2.5 1ZM2.5 2C2.22386 2 2 2.22386 2 2.5V8.3636L3.6818 6.6818C3.76809 6.59551 3.88572 6.54797 4.00774 6.55007C4.12975 6.55216 4.24568 6.60372 4.32895 6.69293L7.87355 10.4901L10.6818 7.6818C10.8575 7.50607 11.1425 7.50607 11.3182 7.6818L13 9.3636V2.5C13 2.22386 12.7761 2 12.5 2H2.5ZM2 12.5V9.6364L3.98887 7.64753L7.5311 11.4421L8.94113 13H2.5C2.22386 13 2 12.7761 2 12.5ZM12.5 13H10.155L8.48336 11.153L11 8.6364L13 10.6364V12.5C13 12.7761 12.7761 13 12.5 13ZM6.64922 5.5C6.64922 5.03013 7.03013 4.64922 7.5 4.64922C7.96987 4.64922 8.35078 5.03013 8.35078 5.5C8.35078 5.96987 7.96987 6.35078 7.5 6.35078C7.03013 6.35078 6.64922 5.96987 6.64922 5.5ZM7.5 3.74922C6.53307 3.74922 5.74922 4.53307 5.74922 5.5C5.74922 6.46693 6.53307 7.25078 7.5 7.25078C8.46693 7.25078 9.25078 6.46693 9.25078 5.5C9.25078 4.53307 8.46693 3.74922 7.5 3.74922Z",
        fill: r,
        fillRule: "evenodd",
        clipRule: "evenodd",
      }),
    );
  });
const Em = () => C.createElement("div", { className: D.imagePlaceholder }, C.createElement(EA, null));
function Qc({ nodeKey: e, imageSource: t, initialImagePath: n, title: r, alt: i }) {
  const [o, s, l] = Le(py, Ke, ct),
    [a] = bt(),
    u = Ie(fy),
    c = Fe();
  return C.createElement(
    "div",
    { className: D.editImageToolbar },
    C.createElement(
      "button",
      {
        className: D.iconButton,
        type: "button",
        title: c("imageEditor.deleteImage", "Delete image"),
        disabled: l,
        onClick: (d) => {
          d.preventDefault(),
            a.update(() => {
              var f;
              (f = Oe(e)) == null || f.remove();
            });
        },
      },
      s("delete_small"),
    ),
    !o &&
      C.createElement(
        "button",
        {
          type: "button",
          className: we(D.iconButton, D.editImageButton),
          title: c("imageEditor.editImage", "Edit image"),
          disabled: l,
          onClick: () => {
            u({ nodeKey: e, initialValues: { src: n || t, title: r, altText: i } });
          },
        },
        s("settings"),
      ),
  );
}
var za = "Dialog",
  [Tb, aP] = ir(za),
  [kA, pn] = Tb(za),
  Ab = (e) => {
    const { __scopeDialog: t, children: n, open: r, defaultOpen: i, onOpenChange: o, modal: s = !0 } = e,
      l = E.useRef(null),
      a = E.useRef(null),
      [u, c] = Qn({ prop: r, defaultProp: i ?? !1, onChange: o, caller: za });
    return O.jsx(kA, {
      scope: t,
      triggerRef: l,
      contentRef: a,
      contentId: Zn(),
      titleId: Zn(),
      descriptionId: Zn(),
      open: u,
      onOpenChange: c,
      onOpenToggle: E.useCallback(() => c((d) => !d), [c]),
      modal: s,
      children: n,
    });
  };
Ab.displayName = za;
var Ib = "DialogTrigger",
  SA = E.forwardRef((e, t) => {
    const { __scopeDialog: n, ...r } = e,
      i = pn(Ib, n),
      o = ze(t, i.triggerRef);
    return O.jsx(_e.button, {
      type: "button",
      "aria-haspopup": "dialog",
      "aria-expanded": i.open,
      "aria-controls": i.contentId,
      "data-state": lh(i.open),
      ...r,
      ref: o,
      onClick: ge(e.onClick, i.onOpenToggle),
    });
  });
SA.displayName = Ib;
var oh = "DialogPortal",
  [TA, Nb] = Tb(oh, { forceMount: void 0 }),
  Lb = (e) => {
    const { __scopeDialog: t, forceMount: n, children: r, container: i } = e,
      o = pn(oh, t);
    return O.jsx(TA, {
      scope: t,
      forceMount: n,
      children: E.Children.map(r, (s) =>
        O.jsx(Er, { present: n || o.open, children: O.jsx(Cs, { asChild: !0, container: i, children: s }) }),
      ),
    });
  };
Lb.displayName = oh;
var Dl = "DialogOverlay",
  Mb = E.forwardRef((e, t) => {
    const n = Nb(Dl, e.__scopeDialog),
      { forceMount: r = n.forceMount, ...i } = e,
      o = pn(Dl, e.__scopeDialog);
    return o.modal ? O.jsx(Er, { present: r || o.open, children: O.jsx(IA, { ...i, ref: t }) }) : null;
  });
Mb.displayName = Dl;
var AA = ji("DialogOverlay.RemoveScroll"),
  IA = E.forwardRef((e, t) => {
    const { __scopeDialog: n, ...r } = e,
      i = pn(Dl, n);
    return O.jsx(Td, {
      as: AA,
      allowPinchZoom: !0,
      shards: [i.contentRef],
      children: O.jsx(_e.div, { "data-state": lh(i.open), ...r, ref: t, style: { pointerEvents: "auto", ...r.style } }),
    });
  }),
  ti = "DialogContent",
  Ob = E.forwardRef((e, t) => {
    const n = Nb(ti, e.__scopeDialog),
      { forceMount: r = n.forceMount, ...i } = e,
      o = pn(ti, e.__scopeDialog);
    return O.jsx(Er, {
      present: r || o.open,
      children: o.modal ? O.jsx(NA, { ...i, ref: t }) : O.jsx(LA, { ...i, ref: t }),
    });
  });
Ob.displayName = ti;
var NA = E.forwardRef((e, t) => {
    const n = pn(ti, e.__scopeDialog),
      r = E.useRef(null),
      i = ze(t, n.contentRef, r);
    return (
      E.useEffect(() => {
        const o = r.current;
        if (o) return Id(o);
      }, []),
      O.jsx(Fb, {
        ...e,
        ref: i,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: ge(e.onCloseAutoFocus, (o) => {
          var s;
          o.preventDefault(), (s = n.triggerRef.current) == null || s.focus();
        }),
        onPointerDownOutside: ge(e.onPointerDownOutside, (o) => {
          const s = o.detail.originalEvent,
            l = s.button === 0 && s.ctrlKey === !0;
          (s.button === 2 || l) && o.preventDefault();
        }),
        onFocusOutside: ge(e.onFocusOutside, (o) => o.preventDefault()),
      })
    );
  }),
  LA = E.forwardRef((e, t) => {
    const n = pn(ti, e.__scopeDialog),
      r = E.useRef(!1),
      i = E.useRef(!1);
    return O.jsx(Fb, {
      ...e,
      ref: t,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      onCloseAutoFocus: (o) => {
        var s, l;
        (s = e.onCloseAutoFocus) == null || s.call(e, o),
          o.defaultPrevented || (r.current || (l = n.triggerRef.current) == null || l.focus(), o.preventDefault()),
          (r.current = !1),
          (i.current = !1);
      },
      onInteractOutside: (o) => {
        var a, u;
        (a = e.onInteractOutside) == null || a.call(e, o),
          o.defaultPrevented || ((r.current = !0), o.detail.originalEvent.type === "pointerdown" && (i.current = !0));
        const s = o.target;
        ((u = n.triggerRef.current) == null ? void 0 : u.contains(s)) && o.preventDefault(),
          o.detail.originalEvent.type === "focusin" && i.current && o.preventDefault();
      },
    });
  }),
  Fb = E.forwardRef((e, t) => {
    const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: i, onCloseAutoFocus: o, ...s } = e,
      l = pn(ti, n),
      a = E.useRef(null),
      u = ze(t, a);
    return (
      Hf(),
      O.jsxs(O.Fragment, {
        children: [
          O.jsx(Fa, {
            asChild: !0,
            loop: !0,
            trapped: r,
            onMountAutoFocus: i,
            onUnmountAutoFocus: o,
            children: O.jsx(ys, {
              role: "dialog",
              id: l.contentId,
              "aria-describedby": l.descriptionId,
              "aria-labelledby": l.titleId,
              "data-state": lh(l.open),
              ...s,
              ref: u,
              onDismiss: () => l.onOpenChange(!1),
            }),
          }),
          O.jsxs(O.Fragment, {
            children: [O.jsx(OA, { titleId: l.titleId }), O.jsx(RA, { contentRef: a, descriptionId: l.descriptionId })],
          }),
        ],
      })
    );
  }),
  sh = "DialogTitle",
  Rb = E.forwardRef((e, t) => {
    const { __scopeDialog: n, ...r } = e,
      i = pn(sh, n);
    return O.jsx(_e.h2, { id: i.titleId, ...r, ref: t });
  });
Rb.displayName = sh;
var Pb = "DialogDescription",
  MA = E.forwardRef((e, t) => {
    const { __scopeDialog: n, ...r } = e,
      i = pn(Pb, n);
    return O.jsx(_e.p, { id: i.descriptionId, ...r, ref: t });
  });
MA.displayName = Pb;
var Db = "DialogClose",
  $b = E.forwardRef((e, t) => {
    const { __scopeDialog: n, ...r } = e,
      i = pn(Db, n);
    return O.jsx(_e.button, { type: "button", ...r, ref: t, onClick: ge(e.onClick, () => i.onOpenChange(!1)) });
  });
$b.displayName = Db;
function lh(e) {
  return e ? "open" : "closed";
}
var Bb = "DialogTitleWarning",
  [uP, Hb] = u8(Bb, { contentName: ti, titleName: sh, docsSlug: "dialog" }),
  OA = ({ titleId: e }) => {
    const t = Hb(Bb),
      n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
    return (
      E.useEffect(() => {
        e && (document.getElementById(e) || console.error(n));
      }, [n, e]),
      null
    );
  },
  FA = "DialogDescriptionWarning",
  RA = ({ contentRef: e, descriptionId: t }) => {
    const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${Hb(FA).contentName}}.`;
    return (
      E.useEffect(() => {
        var o;
        const i = (o = e.current) == null ? void 0 : o.getAttribute("aria-describedby");
        t && i && (document.getElementById(t) || console.warn(r));
      }, [r, e, t]),
      null
    );
  },
  Vb = Ab,
  zb = Lb,
  jb = Mb,
  Ub = Ob,
  Wb = Rb,
  Kb = $b;
function _o(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e)
    if ({}.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) >= 0) continue;
      n[r] = e[r];
    }
  return n;
}
function Ue() {
  return (
    (Ue = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
          }
          return e;
        }),
    Ue.apply(null, arguments)
  );
}
let km = (e) => typeof e == "object" && e != null && e.nodeType === 1,
  Sm = (e, t) => (!t || e !== "hidden") && e !== "visible" && e !== "clip",
  Lu = (e, t) => {
    if (e.clientHeight < e.scrollHeight || e.clientWidth < e.scrollWidth) {
      let n = getComputedStyle(e, null);
      return (
        Sm(n.overflowY, t) ||
        Sm(n.overflowX, t) ||
        ((r) => {
          let i = ((o) => {
            if (!o.ownerDocument || !o.ownerDocument.defaultView) return null;
            try {
              return o.ownerDocument.defaultView.frameElement;
            } catch {
              return null;
            }
          })(r);
          return !!i && (i.clientHeight < r.scrollHeight || i.clientWidth < r.scrollWidth);
        })(e)
      );
    }
    return !1;
  },
  zs = (e, t, n, r, i, o, s, l) =>
    (o < e && s > t) || (o > e && s < t)
      ? 0
      : (o <= e && l <= n) || (s >= t && l >= n)
        ? o - e - r
        : (s > t && l < n) || (o < e && l > n)
          ? s - t + i
          : 0,
  PA = (e) => {
    let t = e.parentElement;
    return t ?? (e.getRootNode().host || null);
  };
var DA = (e, t) => {
    var n, r, i, o, s, l;
    if (typeof document > "u") return [];
    let { scrollMode: a, block: u, inline: c, boundary: d, skipOverflowHiddenElements: f } = t,
      h = typeof d == "function" ? d : (B) => B !== d;
    if (!km(e)) throw new TypeError("Invalid target");
    let p = document.scrollingElement || document.documentElement,
      g = [],
      x = e;
    for (; km(x) && h(x); ) {
      if (((x = PA(x)), x === p)) {
        g.push(x);
        break;
      }
      (x != null && x === document.body && Lu(x) && !Lu(document.documentElement)) ||
        (x != null && Lu(x, f) && g.push(x));
    }
    let b = (r = (n = window.visualViewport) == null ? void 0 : n.width) != null ? r : innerWidth,
      m = (o = (i = window.visualViewport) == null ? void 0 : i.height) != null ? o : innerHeight,
      v = (s = window.scrollX) != null ? s : pageXOffset,
      _ = (l = window.scrollY) != null ? l : pageYOffset,
      { height: k, width: w, top: y, right: S, bottom: T, left: A } = e.getBoundingClientRect(),
      F = u === "start" || u === "nearest" ? y : u === "end" ? T : y + k / 2,
      R = c === "center" ? A + w / 2 : c === "end" ? S : A,
      V = [];
    for (let B = 0; B < g.length; B++) {
      let N = g[B],
        { height: G, width: U, top: X, right: te, bottom: L, left: se } = N.getBoundingClientRect();
      if (a === "if-needed" && y >= 0 && A >= 0 && T <= m && S <= b && y >= X && T <= L && A >= se && S <= te) return V;
      let pe = getComputedStyle(N),
        M = parseInt(pe.borderLeftWidth, 10),
        me = parseInt(pe.borderTopWidth, 10),
        Ee = parseInt(pe.borderRightWidth, 10),
        ce = parseInt(pe.borderBottomWidth, 10),
        z = 0,
        W = 0,
        Y = "offsetWidth" in N ? N.offsetWidth - N.clientWidth - M - Ee : 0,
        Q = "offsetHeight" in N ? N.offsetHeight - N.clientHeight - me - ce : 0,
        oe = "offsetWidth" in N ? (N.offsetWidth === 0 ? 0 : U / N.offsetWidth) : 0,
        he = "offsetHeight" in N ? (N.offsetHeight === 0 ? 0 : G / N.offsetHeight) : 0;
      if (p === N)
        (z =
          u === "start"
            ? F
            : u === "end"
              ? F - m
              : u === "nearest"
                ? zs(_, _ + m, m, me, ce, _ + F, _ + F + k, k)
                : F - m / 2),
          (W =
            c === "start"
              ? R
              : c === "center"
                ? R - b / 2
                : c === "end"
                  ? R - b
                  : zs(v, v + b, b, M, Ee, v + R, v + R + w, w)),
          (z = Math.max(0, z + _)),
          (W = Math.max(0, W + v));
      else {
        (z =
          u === "start"
            ? F - X - me
            : u === "end"
              ? F - L + ce + Q
              : u === "nearest"
                ? zs(X, L, G, me, ce + Q, F, F + k, k)
                : F - (X + G / 2) + Q / 2),
          (W =
            c === "start"
              ? R - se - M
              : c === "center"
                ? R - (se + U / 2) + Y / 2
                : c === "end"
                  ? R - te + Ee + Y
                  : zs(se, te, U, M, Ee + Y, R, R + w, w));
        let { scrollLeft: ke, scrollTop: De } = N;
        (z = Math.max(0, Math.min(De + z / he, N.scrollHeight - G / he + Q))),
          (W = Math.max(0, Math.min(ke + W / oe, N.scrollWidth - U / oe + Y))),
          (F += De - z),
          (R += ke - W);
      }
      V.push({ el: N, top: z, left: W });
    }
    return V;
  },
  $A = 0;
function Jb() {}
function BA(e, t) {
  if (e) {
    var n = DA(e, { boundary: t, block: "nearest", scrollMode: "if-needed" });
    n.forEach(function (r) {
      var i = r.el,
        o = r.top,
        s = r.left;
      (i.scrollTop = o), (i.scrollLeft = s);
    });
  }
}
function Tm(e, t, n) {
  var r = e === t || (t instanceof n.Node && e.contains && e.contains(t));
  return r;
}
function Gb(e, t) {
  var n;
  function r() {
    n && clearTimeout(n);
  }
  function i() {
    for (var o = arguments.length, s = new Array(o), l = 0; l < o; l++) s[l] = arguments[l];
    r(),
      (n = setTimeout(function () {
        (n = null), e.apply(void 0, s);
      }, t));
  }
  return (i.cancel = r), i;
}
function Dn() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
  return function (r) {
    for (var i = arguments.length, o = new Array(i > 1 ? i - 1 : 0), s = 1; s < i; s++) o[s - 1] = arguments[s];
    return t.some(function (l) {
      return (
        l && l.apply(void 0, [r].concat(o)),
        r.preventDownshiftDefault || (r.hasOwnProperty("nativeEvent") && r.nativeEvent.preventDownshiftDefault)
      );
    });
  };
}
function js() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
  return function (r) {
    t.forEach(function (i) {
      typeof i == "function" ? i(r) : i && (i.current = r);
    });
  };
}
function HA() {
  return String($A++);
}
function VA(e) {
  var t = e.isOpen,
    n = e.resultCount,
    r = e.previousResultCount;
  return t
    ? n
      ? n !== r
        ? n +
          " result" +
          (n === 1 ? " is" : "s are") +
          " available, use up and down arrow keys to navigate. Press Enter key to select."
        : ""
      : "No results are available."
    : "";
}
function ed(e, t) {
  return Object.keys(e).reduce(function (n, r) {
    return (n[r] = Zb(t, r) ? t[r] : e[r]), n;
  }, {});
}
function Zb(e, t) {
  return e[t] !== void 0;
}
function zA(e) {
  var t = e.key,
    n = e.keyCode;
  return n >= 37 && n <= 40 && t.indexOf("Arrow") !== 0 ? "Arrow" + t : t;
}
function Us(e, t, n, r, i) {
  if ((i === void 0 && (i = !0), n === 0)) return -1;
  var o = n - 1;
  (typeof t != "number" || t < 0 || t >= n) && (t = e > 0 ? -1 : o + 1);
  var s = t + e;
  s < 0 ? (s = i ? o : 0) : s > o && (s = i ? 0 : o);
  var l = Xo(e, s, n, r, i);
  return l === -1 ? (t >= n ? -1 : t) : l;
}
function Xo(e, t, n, r, i) {
  var o = r(t);
  if (!o || !o.hasAttribute("disabled")) return t;
  if (e > 0) {
    for (var s = t + 1; s < n; s++) if (!r(s).hasAttribute("disabled")) return s;
  } else for (var l = t - 1; l >= 0; l--) if (!r(l).hasAttribute("disabled")) return l;
  return i ? (e > 0 ? Xo(1, 0, n, r, !1) : Xo(-1, n - 1, n, r, !1)) : -1;
}
function Am(e, t, n, r) {
  return (
    r === void 0 && (r = !0),
    t.some(function (i) {
      return i && (Tm(i, e, n) || (r && Tm(i, n.document.activeElement, n)));
    })
  );
}
var jA = Gb(function (e) {
  qb(e).textContent = "";
}, 500);
function UA(e, t) {
  var n = qb(t);
  e && ((n.textContent = e), jA(t));
}
function qb(e) {
  e === void 0 && (e = document);
  var t = e.getElementById("a11y-status-message");
  return (
    t ||
    ((t = e.createElement("div")),
    t.setAttribute("id", "a11y-status-message"),
    t.setAttribute("role", "status"),
    t.setAttribute("aria-live", "polite"),
    t.setAttribute("aria-relevant", "additions text"),
    Object.assign(t.style, {
      border: "0",
      clip: "rect(0 0 0 0)",
      height: "1px",
      margin: "-1px",
      overflow: "hidden",
      padding: "0",
      position: "absolute",
      width: "1px",
    }),
    e.body.appendChild(t),
    t)
  );
}
var WA = ["isInitialMount", "highlightedIndex", "items", "environment"],
  Yb = { highlightedIndex: -1, isOpen: !1, selectedItem: null, inputValue: "" };
function KA(e, t, n) {
  var r = e.props,
    i = e.type,
    o = {};
  Object.keys(t).forEach(function (s) {
    JA(s, e, t, n), n[s] !== t[s] && (o[s] = n[s]);
  }),
    r.onStateChange && Object.keys(o).length && r.onStateChange(Ue({ type: i }, o));
}
function JA(e, t, n, r) {
  var i = t.props,
    o = t.type,
    s = "on" + ah(e) + "Change";
  i[s] && r[e] !== void 0 && r[e] !== n[e] && i[s](Ue({ type: o }, r));
}
function GA(e, t) {
  return t.changes;
}
function ZA(e) {
  var t = e.selectedItem,
    n = e.itemToString;
  return t ? n(t) + " has been selected." : "";
}
var qA = Gb(function (e, t) {
    UA(e(), t);
  }, 200),
  YA =
    typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"
      ? E.useLayoutEffect
      : E.useEffect;
function XA(e) {
  var t = e.id,
    n = t === void 0 ? "downshift-" + HA() : t,
    r = e.labelId,
    i = e.menuId,
    o = e.getItemId,
    s = e.toggleButtonId,
    l = e.inputId,
    a = E.useRef({
      labelId: r || n + "-label",
      menuId: i || n + "-menu",
      getItemId:
        o ||
        function (u) {
          return n + "-item-" + u;
        },
      toggleButtonId: s || n + "-toggle-button",
      inputId: l || n + "-input",
    });
  return a.current;
}
function QA(e, t, n, r) {
  var i, o;
  if (e === void 0) {
    if (t === void 0) throw new Error(r);
    (i = n[t]), (o = t);
  } else (o = t === void 0 ? n.indexOf(e) : t), (i = e);
  return [i, o];
}
function eI(e) {
  return e ? String(e) : "";
}
function ah(e) {
  return "" + e.slice(0, 1).toUpperCase() + e.slice(1);
}
function Xb(e) {
  var t = E.useRef(e);
  return (t.current = e), t;
}
function tI(e, t, n) {
  var r = E.useRef(),
    i = E.useRef(),
    o = E.useCallback(
      function (f, h) {
        (i.current = h), (f = ed(f, h.props));
        var p = e(f, h),
          g = h.props.stateReducer(f, Ue({}, h, { changes: p }));
        return g;
      },
      [e],
    ),
    s = E.useReducer(o, t),
    l = s[0],
    a = s[1],
    u = Xb(n),
    c = E.useCallback(
      function (f) {
        return a(Ue({ props: u.current }, f));
      },
      [u],
    ),
    d = i.current;
  return (
    E.useEffect(
      function () {
        d && r.current && r.current !== l && KA(d, ed(r.current, d.props), l), (r.current = l);
      },
      [l, n, d],
    ),
    [l, c]
  );
}
var Po = {
  itemToString: eI,
  stateReducer: GA,
  getA11ySelectionMessage: ZA,
  scrollIntoView: BA,
  environment: typeof window > "u" ? {} : window,
};
function En(e, t, n) {
  n === void 0 && (n = Yb);
  var r = e["default" + ah(t)];
  return r !== void 0 ? r : n[t];
}
function Ws(e, t, n) {
  n === void 0 && (n = Yb);
  var r = e[t];
  if (r !== void 0) return r;
  var i = e["initial" + ah(t)];
  return i !== void 0 ? i : En(e, t, n);
}
function nI(e) {
  var t = Ws(e, "selectedItem"),
    n = Ws(e, "isOpen"),
    r = Ws(e, "highlightedIndex"),
    i = Ws(e, "inputValue");
  return { highlightedIndex: r < 0 && t && n ? e.items.indexOf(t) : r, isOpen: n, selectedItem: t, inputValue: i };
}
function Do(e, t, n) {
  var r = e.items,
    i = e.initialHighlightedIndex,
    o = e.defaultHighlightedIndex,
    s = t.selectedItem,
    l = t.highlightedIndex;
  return r.length === 0
    ? -1
    : i !== void 0 && l === i
      ? i
      : o !== void 0
        ? o
        : s
          ? r.indexOf(s)
          : n === 0
            ? -1
            : n < 0
              ? r.length - 1
              : 0;
}
function rI(e, t, n, r) {
  var i = E.useRef({ isMouseDown: !1, isTouchMove: !1 });
  return (
    E.useEffect(
      function () {
        if ((n == null ? void 0 : n.addEventListener) != null) {
          var o = function () {
              i.current.isMouseDown = !0;
            },
            s = function (d) {
              (i.current.isMouseDown = !1),
                e &&
                  !Am(
                    d.target,
                    t.map(function (f) {
                      return f.current;
                    }),
                    n,
                  ) &&
                  r();
            },
            l = function () {
              i.current.isTouchMove = !1;
            },
            a = function () {
              i.current.isTouchMove = !0;
            },
            u = function (d) {
              e &&
                !i.current.isTouchMove &&
                !Am(
                  d.target,
                  t.map(function (f) {
                    return f.current;
                  }),
                  n,
                  !1,
                ) &&
                r();
            };
          return (
            n.addEventListener("mousedown", o),
            n.addEventListener("mouseup", s),
            n.addEventListener("touchstart", l),
            n.addEventListener("touchmove", a),
            n.addEventListener("touchend", u),
            function () {
              n.removeEventListener("mousedown", o),
                n.removeEventListener("mouseup", s),
                n.removeEventListener("touchstart", l),
                n.removeEventListener("touchmove", a),
                n.removeEventListener("touchend", u);
            }
          );
        }
      },
      [e, n],
    ),
    i
  );
}
var iI = function () {
  return Jb;
};
function Im(e, t, n) {
  var r = n.isInitialMount,
    i = n.highlightedIndex,
    o = n.items,
    s = n.environment,
    l = _o(n, WA);
  E.useEffect(function () {
    r ||
      qA(function () {
        return e(Ue({ highlightedIndex: i, highlightedItem: o[i], resultCount: o.length }, l));
      }, s.document);
  }, t);
}
function oI(e) {
  var t = e.highlightedIndex,
    n = e.isOpen,
    r = e.itemRefs,
    i = e.getItemNodeFromIndex,
    o = e.menuElement,
    s = e.scrollIntoView,
    l = E.useRef(!0);
  return (
    YA(
      function () {
        t < 0 || !n || !Object.keys(r.current).length || (l.current === !1 ? (l.current = !0) : s(i(t), o));
      },
      [t],
    ),
    l
  );
}
var sI = Jb;
function Nm(e, t, n) {
  var r;
  n === void 0 && (n = !0);
  var i = ((r = e.items) == null ? void 0 : r.length) && t >= 0;
  return Ue(
    { isOpen: !1, highlightedIndex: -1 },
    i &&
      Ue(
        { selectedItem: e.items[t], isOpen: En(e, "isOpen"), highlightedIndex: En(e, "highlightedIndex") },
        n && { inputValue: e.itemToString(e.items[t]) },
      ),
  );
}
function lI(e, t, n) {
  var r = t.type,
    i = t.props,
    o;
  switch (r) {
    case n.ItemMouseMove:
      o = { highlightedIndex: t.disabled ? -1 : t.index };
      break;
    case n.MenuMouseLeave:
      o = { highlightedIndex: -1 };
      break;
    case n.ToggleButtonClick:
    case n.FunctionToggleMenu:
      o = { isOpen: !e.isOpen, highlightedIndex: e.isOpen ? -1 : Do(i, e, 0) };
      break;
    case n.FunctionOpenMenu:
      o = { isOpen: !0, highlightedIndex: Do(i, e, 0) };
      break;
    case n.FunctionCloseMenu:
      o = { isOpen: !1 };
      break;
    case n.FunctionSetHighlightedIndex:
      o = { highlightedIndex: t.highlightedIndex };
      break;
    case n.FunctionSetInputValue:
      o = { inputValue: t.inputValue };
      break;
    case n.FunctionReset:
      o = {
        highlightedIndex: En(i, "highlightedIndex"),
        isOpen: En(i, "isOpen"),
        selectedItem: En(i, "selectedItem"),
        inputValue: En(i, "inputValue"),
      };
      break;
    default:
      throw new Error("Reducer called without proper action type.");
  }
  return Ue({}, e, o);
}
q.array.isRequired,
  q.func,
  q.func,
  q.func,
  q.number,
  q.number,
  q.number,
  q.bool,
  q.bool,
  q.bool,
  q.any,
  q.any,
  q.any,
  q.string,
  q.string,
  q.string,
  q.func,
  q.string,
  q.func,
  q.func,
  q.func,
  q.func,
  q.func,
  q.shape({
    addEventListener: q.func,
    removeEventListener: q.func,
    document: q.shape({ getElementById: q.func, activeElement: q.any, body: q.any }),
  });
function aI(e) {
  var t = e.isOpen,
    n = e.resultCount,
    r = e.previousResultCount;
  return t
    ? n
      ? n !== r
        ? ""
            .concat(n, " result")
            .concat(
              n === 1 ? " is" : "s are",
              " available, use up and down arrow keys to navigate. Press Enter or Space Bar keys to select.",
            )
        : ""
      : "No results are available."
    : "";
}
Gh(Gh({}, Po), { getA11yStatusMessage: aI });
var uh = 0,
  ch = 1,
  dh = 2,
  fh = 3,
  hh = 4,
  ph = 5,
  gh = 6,
  mh = 7,
  xh = 8,
  $l = 9,
  vh = 10,
  Qb = 11,
  ey = 12,
  bh = 13,
  ty = 14,
  ny = 15,
  ry = 16,
  iy = 17,
  oy = 18,
  yh = 19,
  sy = 20,
  ly = 21,
  Ch = 22,
  ay = Object.freeze({
    __proto__: null,
    InputKeyDownArrowDown: uh,
    InputKeyDownArrowUp: ch,
    InputKeyDownEscape: dh,
    InputKeyDownHome: fh,
    InputKeyDownEnd: hh,
    InputKeyDownPageUp: ph,
    InputKeyDownPageDown: gh,
    InputKeyDownEnter: mh,
    InputChange: xh,
    InputBlur: $l,
    InputFocus: vh,
    MenuMouseLeave: Qb,
    ItemMouseMove: ey,
    ItemClick: bh,
    ToggleButtonClick: ty,
    FunctionToggleMenu: ny,
    FunctionOpenMenu: ry,
    FunctionCloseMenu: iy,
    FunctionSetHighlightedIndex: oy,
    FunctionSelectItem: yh,
    FunctionSetInputValue: sy,
    FunctionReset: ly,
    ControlledPropUpdatedSelectedItem: Ch,
  });
function uI(e) {
  var t = nI(e),
    n = t.selectedItem,
    r = t.inputValue;
  return (
    r === "" &&
      n &&
      e.defaultInputValue === void 0 &&
      e.initialInputValue === void 0 &&
      e.inputValue === void 0 &&
      (r = e.itemToString(n)),
    Ue({}, t, { inputValue: r })
  );
}
q.array.isRequired,
  q.func,
  q.func,
  q.func,
  q.func,
  q.number,
  q.number,
  q.number,
  q.bool,
  q.bool,
  q.bool,
  q.any,
  q.any,
  q.any,
  q.string,
  q.string,
  q.string,
  q.string,
  q.string,
  q.string,
  q.func,
  q.string,
  q.string,
  q.func,
  q.func,
  q.func,
  q.func,
  q.func,
  q.func,
  q.shape({
    addEventListener: q.func,
    removeEventListener: q.func,
    document: q.shape({ getElementById: q.func, activeElement: q.any, body: q.any }),
  });
function cI(e, t, n) {
  var r = E.useRef(),
    i = tI(e, t, n),
    o = i[0],
    s = i[1];
  return (
    E.useEffect(
      function () {
        Zb(n, "selectedItem") &&
          (n.selectedItemChanged(r.current, n.selectedItem) &&
            s({ type: Ch, inputValue: n.itemToString(n.selectedItem) }),
          (r.current = o.selectedItem === r.current ? n.selectedItem : o.selectedItem));
      },
      [o.selectedItem, n.selectedItem],
    ),
    [ed(o, n), s]
  );
}
var dI = Ue({}, Po, {
  selectedItemChanged: function (t, n) {
    return t !== n;
  },
  getA11yStatusMessage: VA,
});
function fI(e, t) {
  var n,
    r = t.type,
    i = t.props,
    o = t.altKey,
    s;
  switch (r) {
    case bh:
      s = {
        isOpen: En(i, "isOpen"),
        highlightedIndex: En(i, "highlightedIndex"),
        selectedItem: i.items[t.index],
        inputValue: i.itemToString(i.items[t.index]),
      };
      break;
    case uh:
      e.isOpen
        ? (s = { highlightedIndex: Us(1, e.highlightedIndex, i.items.length, t.getItemNodeFromIndex, !0) })
        : (s = {
            highlightedIndex: o && e.selectedItem == null ? -1 : Do(i, e, 1, t.getItemNodeFromIndex),
            isOpen: i.items.length >= 0,
          });
      break;
    case ch:
      e.isOpen
        ? o
          ? (s = Nm(i, e.highlightedIndex))
          : (s = { highlightedIndex: Us(-1, e.highlightedIndex, i.items.length, t.getItemNodeFromIndex, !0) })
        : (s = { highlightedIndex: Do(i, e, -1, t.getItemNodeFromIndex), isOpen: i.items.length >= 0 });
      break;
    case mh:
      s = Nm(i, e.highlightedIndex);
      break;
    case dh:
      s = Ue({ isOpen: !1, highlightedIndex: -1 }, !e.isOpen && { selectedItem: null, inputValue: "" });
      break;
    case ph:
      s = { highlightedIndex: Us(-10, e.highlightedIndex, i.items.length, t.getItemNodeFromIndex, !1) };
      break;
    case gh:
      s = { highlightedIndex: Us(10, e.highlightedIndex, i.items.length, t.getItemNodeFromIndex, !1) };
      break;
    case fh:
      s = { highlightedIndex: Xo(1, 0, i.items.length, t.getItemNodeFromIndex, !1) };
      break;
    case hh:
      s = { highlightedIndex: Xo(-1, i.items.length - 1, i.items.length, t.getItemNodeFromIndex, !1) };
      break;
    case $l:
      s = Ue(
        { isOpen: !1, highlightedIndex: -1 },
        e.highlightedIndex >= 0 &&
          ((n = i.items) == null ? void 0 : n.length) &&
          t.selectItem && {
            selectedItem: i.items[e.highlightedIndex],
            inputValue: i.itemToString(i.items[e.highlightedIndex]),
          },
      );
      break;
    case xh:
      s = { isOpen: !0, highlightedIndex: En(i, "highlightedIndex"), inputValue: t.inputValue };
      break;
    case vh:
      s = { isOpen: !0, highlightedIndex: Do(i, e, 0) };
      break;
    case yh:
      s = { selectedItem: t.selectedItem, inputValue: i.itemToString(t.selectedItem) };
      break;
    case Ch:
      s = { inputValue: t.inputValue };
      break;
    default:
      return lI(e, t, ay);
  }
  return Ue({}, e, s);
}
var hI = ["onMouseLeave", "refKey", "ref"],
  pI = ["item", "index", "refKey", "ref", "onMouseMove", "onMouseDown", "onClick", "onPress", "disabled"],
  gI = ["onClick", "onPress", "refKey", "ref"],
  mI = ["onKeyDown", "onChange", "onInput", "onFocus", "onBlur", "onChangeText", "refKey", "ref"];
uy.stateChangeTypes = ay;
function uy(e) {
  e === void 0 && (e = {});
  var t = Ue({}, dI, e),
    n = t.initialIsOpen,
    r = t.defaultIsOpen,
    i = t.items,
    o = t.scrollIntoView,
    s = t.environment,
    l = t.getA11yStatusMessage,
    a = t.getA11ySelectionMessage,
    u = t.itemToString,
    c = uI(t),
    d = cI(fI, c, t),
    f = d[0],
    h = d[1],
    p = f.isOpen,
    g = f.highlightedIndex,
    x = f.selectedItem,
    b = f.inputValue,
    m = E.useRef(null),
    v = E.useRef({}),
    _ = E.useRef(null),
    k = E.useRef(null),
    w = E.useRef(!0),
    y = XA(t),
    S = E.useRef(),
    T = Xb({ state: f, props: t }),
    A = E.useCallback(
      function (z) {
        return v.current[y.getItemId(z)];
      },
      [y],
    );
  Im(
    l,
    [p, g, b, i],
    Ue({ isInitialMount: w.current, previousResultCount: S.current, items: i, environment: s, itemToString: u }, f),
  ),
    Im(
      a,
      [x],
      Ue({ isInitialMount: w.current, previousResultCount: S.current, items: i, environment: s, itemToString: u }, f),
    );
  var F = oI({
    menuElement: m.current,
    highlightedIndex: g,
    isOpen: p,
    itemRefs: v,
    scrollIntoView: o,
    getItemNodeFromIndex: A,
  });
  sI({ isInitialMount: w.current, props: t, state: f }),
    E.useEffect(function () {
      var z = n || r || p;
      z && _.current && _.current.focus();
    }, []),
    E.useEffect(function () {
      w.current || (S.current = i.length);
    });
  var R = rI(p, [_, m, k], s, function () {
      h({ type: $l, selectItem: !1 });
    }),
    V = iI();
  E.useEffect(function () {
    return (
      (w.current = !1),
      function () {
        w.current = !0;
      }
    );
  }, []),
    E.useEffect(
      function () {
        var z;
        if (!p) v.current = {};
        else if (((z = s.document) == null ? void 0 : z.activeElement) !== _.current) {
          var W;
          _ == null || (W = _.current) == null || W.focus();
        }
      },
      [p, s],
    );
  var B = E.useMemo(
      function () {
        return {
          ArrowDown: function (W) {
            W.preventDefault(), h({ type: uh, altKey: W.altKey, getItemNodeFromIndex: A });
          },
          ArrowUp: function (W) {
            W.preventDefault(), h({ type: ch, altKey: W.altKey, getItemNodeFromIndex: A });
          },
          Home: function (W) {
            T.current.state.isOpen && (W.preventDefault(), h({ type: fh, getItemNodeFromIndex: A }));
          },
          End: function (W) {
            T.current.state.isOpen && (W.preventDefault(), h({ type: hh, getItemNodeFromIndex: A }));
          },
          Escape: function (W) {
            var Y = T.current.state;
            (Y.isOpen || Y.inputValue || Y.selectedItem || Y.highlightedIndex > -1) &&
              (W.preventDefault(), h({ type: dh }));
          },
          Enter: function (W) {
            var Y = T.current.state;
            !Y.isOpen || W.which === 229 || (W.preventDefault(), h({ type: mh, getItemNodeFromIndex: A }));
          },
          PageUp: function (W) {
            T.current.state.isOpen && (W.preventDefault(), h({ type: ph, getItemNodeFromIndex: A }));
          },
          PageDown: function (W) {
            T.current.state.isOpen && (W.preventDefault(), h({ type: gh, getItemNodeFromIndex: A }));
          },
        };
      },
      [h, T, A],
    ),
    N = E.useCallback(
      function (z) {
        return Ue({ id: y.labelId, htmlFor: y.inputId }, z);
      },
      [y],
    ),
    G = E.useCallback(
      function (z, W) {
        var Y,
          Q = z === void 0 ? {} : z,
          oe = Q.onMouseLeave,
          he = Q.refKey,
          ke = he === void 0 ? "ref" : he,
          De = Q.ref,
          Xe = _o(Q, hI),
          Qe = W === void 0 ? {} : W;
        return (
          Qe.suppressRefError,
          Ue(
            ((Y = {}),
            (Y[ke] = js(De, function (rt) {
              m.current = rt;
            })),
            (Y.id = y.menuId),
            (Y.role = "listbox"),
            (Y["aria-labelledby"] = Xe && Xe["aria-label"] ? void 0 : "" + y.labelId),
            (Y.onMouseLeave = Dn(oe, function () {
              h({ type: Qb });
            })),
            Y),
            Xe,
          )
        );
      },
      [h, V, y],
    ),
    U = E.useCallback(
      function (z) {
        var W,
          Y,
          Q = z === void 0 ? {} : z,
          oe = Q.item,
          he = Q.index,
          ke = Q.refKey,
          De = ke === void 0 ? "ref" : ke,
          Xe = Q.ref,
          Qe = Q.onMouseMove,
          rt = Q.onMouseDown,
          gn = Q.onClick;
        Q.onPress;
        var st = Q.disabled,
          mn = _o(Q, pI),
          _t = T.current,
          Ir = _t.props,
          Zt = _t.state,
          Re = QA(oe, he, Ir.items, "Pass either item or index to getItemProps!"),
          Ot = Re[1],
          $ = "onClick",
          j = gn,
          I = function () {
            Ot !== Zt.highlightedIndex && ((F.current = !1), h({ type: ey, index: Ot, disabled: st }));
          },
          de = function () {
            h({ type: bh, index: Ot });
          },
          ye = function (Mn) {
            return Mn.preventDefault();
          };
        return Ue(
          ((W = {}),
          (W[De] = js(Xe, function ($e) {
            $e && (v.current[y.getItemId(Ot)] = $e);
          })),
          (W.disabled = st),
          (W.role = "option"),
          (W["aria-selected"] = "" + (Ot === Zt.highlightedIndex)),
          (W.id = y.getItemId(Ot)),
          W),
          !st && ((Y = {}), (Y[$] = Dn(j, de)), Y),
          { onMouseMove: Dn(Qe, I), onMouseDown: Dn(rt, ye) },
          mn,
        );
      },
      [h, T, F, y],
    ),
    X = E.useCallback(
      function (z) {
        var W,
          Y = z === void 0 ? {} : z,
          Q = Y.onClick;
        Y.onPress;
        var oe = Y.refKey,
          he = oe === void 0 ? "ref" : oe,
          ke = Y.ref,
          De = _o(Y, gI),
          Xe = T.current.state,
          Qe = function () {
            h({ type: ty });
          };
        return Ue(
          ((W = {}),
          (W[he] = js(ke, function (rt) {
            k.current = rt;
          })),
          (W["aria-controls"] = y.menuId),
          (W["aria-expanded"] = Xe.isOpen),
          (W.id = y.toggleButtonId),
          (W.tabIndex = -1),
          W),
          !De.disabled && Ue({}, { onClick: Dn(Q, Qe) }),
          De,
        );
      },
      [h, T, y],
    ),
    te = E.useCallback(
      function (z, W) {
        var Y,
          Q = z === void 0 ? {} : z,
          oe = Q.onKeyDown,
          he = Q.onChange,
          ke = Q.onInput,
          De = Q.onFocus,
          Xe = Q.onBlur;
        Q.onChangeText;
        var Qe = Q.refKey,
          rt = Qe === void 0 ? "ref" : Qe,
          gn = Q.ref,
          st = _o(Q, mI),
          mn = W === void 0 ? {} : W;
        mn.suppressRefError;
        var _t = T.current.state,
          Ir = function (ye) {
            var $e = zA(ye);
            $e && B[$e] && B[$e](ye);
          },
          Zt = function (ye) {
            h({ type: xh, inputValue: ye.target.value });
          },
          Re = function (ye) {
            if (_t.isOpen && !R.current.isMouseDown) {
              var $e = ye.relatedTarget === null && s.document.activeElement !== s.document.body;
              h({ type: $l, selectItem: !$e });
            }
          },
          Ot = function () {
            _t.isOpen || h({ type: vh });
          },
          $ = "onChange",
          j = {};
        if (!st.disabled) {
          var I;
          j =
            ((I = {}),
            (I[$] = Dn(he, ke, Zt)),
            (I.onKeyDown = Dn(oe, Ir)),
            (I.onBlur = Dn(Xe, Re)),
            (I.onFocus = Dn(De, Ot)),
            I);
        }
        return Ue(
          ((Y = {}),
          (Y[rt] = js(gn, function (de) {
            _.current = de;
          })),
          (Y["aria-activedescendant"] = _t.isOpen && _t.highlightedIndex > -1 ? y.getItemId(_t.highlightedIndex) : ""),
          (Y["aria-autocomplete"] = "list"),
          (Y["aria-controls"] = y.menuId),
          (Y["aria-expanded"] = _t.isOpen),
          (Y["aria-labelledby"] = st && st["aria-label"] ? void 0 : "" + y.labelId),
          (Y.autoComplete = "off"),
          (Y.id = y.inputId),
          (Y.role = "combobox"),
          (Y.value = _t.inputValue),
          Y),
          j,
          st,
        );
      },
      [V, T, y, B, h, R, s],
    ),
    L = E.useCallback(
      function () {
        h({ type: ny });
      },
      [h],
    ),
    se = E.useCallback(
      function () {
        h({ type: iy });
      },
      [h],
    ),
    pe = E.useCallback(
      function () {
        h({ type: ry });
      },
      [h],
    ),
    M = E.useCallback(
      function (z) {
        h({ type: oy, highlightedIndex: z });
      },
      [h],
    ),
    me = E.useCallback(
      function (z) {
        h({ type: yh, selectedItem: z });
      },
      [h],
    ),
    Ee = E.useCallback(
      function (z) {
        h({ type: sy, inputValue: z });
      },
      [h],
    ),
    ce = E.useCallback(
      function () {
        h({ type: ly });
      },
      [h],
    );
  return {
    getItemProps: U,
    getLabelProps: N,
    getMenuProps: G,
    getInputProps: te,
    getToggleButtonProps: X,
    toggleMenu: L,
    openMenu: pe,
    closeMenu: se,
    setHighlightedIndex: M,
    setInputValue: Ee,
    selectItem: me,
    reset: ce,
    highlightedIndex: g,
    isOpen: p,
    selectedItem: x,
    inputValue: b,
  };
}
function xI(e) {
  var t = e.removedSelectedItem,
    n = e.itemToString;
  return n(t) + " has been removed.";
}
q.array,
  q.array,
  q.array,
  q.func,
  q.func,
  q.func,
  q.number,
  q.number,
  q.number,
  q.func,
  q.func,
  q.string,
  q.string,
  q.shape({
    addEventListener: q.func,
    removeEventListener: q.func,
    document: q.shape({ getElementById: q.func, activeElement: q.any, body: q.any }),
  });
Po.itemToString, Po.stateReducer, Po.environment;
const Lm = 20,
  cy = (e) =>
    e.suggestions.length > 0
      ? C.createElement(vI, { ...e })
      : C.createElement("input", { className: D.textInput, size: 40, autoFocus: !0, ...e.register(e.inputName) }),
  vI = ({
    autofocus: e,
    suggestions: t,
    control: n,
    inputName: r,
    placeholder: i,
    initialInputValue: o,
    setValue: s,
  }) => {
    const [l, a] = C.useState(t.slice(0, Lm)),
      u = qe(Ke),
      c = t.length > 0,
      {
        isOpen: d,
        getToggleButtonProps: f,
        getMenuProps: h,
        getInputProps: p,
        highlightedIndex: g,
        getItemProps: x,
        selectedItem: b,
      } = uy({
        initialInputValue: o,
        onInputValueChange({ inputValue: v = "" }) {
          s(r, v), (v = v.toLowerCase() || "");
          const _ = [];
          for (const k of t) if (k.toLowerCase().includes(v) && (_.push(k), _.length >= Lm)) break;
          a(_);
        },
        items: l,
        itemToString(v) {
          return v ?? "";
        },
      }),
      m = d && l.length > 0;
    return C.createElement(
      "div",
      { className: D.downshiftAutocompleteContainer },
      C.createElement(
        "div",
        { "data-visible-dropdown": m, className: D.downshiftInputWrapper },
        C.createElement(K5, {
          name: r,
          control: n,
          render: ({ field: v }) => {
            const _ = p();
            return C.createElement("input", {
              ..._,
              name: v.name,
              placeholder: i,
              className: D.downshiftInput,
              size: 30,
              "data-editor-dialog": !0,
              autoFocus: e,
            });
          },
        }),
        c && C.createElement("button", { "aria-label": "toggle menu", type: "button", ...f() }, u("arrow_drop_down")),
      ),
      C.createElement(
        "div",
        { className: D.downshiftAutocompleteContainer },
        C.createElement(
          "ul",
          { ...h(), "data-visible": m },
          l.map((v, _) =>
            C.createElement(
              "li",
              { "data-selected": b === v, "data-highlighted": g === _, key: `${v}${_}`, ...x({ item: v, index: _ }) },
              v,
            ),
          ),
        ),
      ),
    );
  },
  bI = () => {
    const [e, t, n, r] = Le(td, Hr, wr, fr),
      i = Ie(gy),
      o = Ie(hy),
      s = Fe(),
      {
        register: l,
        handleSubmit: a,
        control: u,
        setValue: c,
        reset: d,
      } = Ad({ values: t.type === "editing" ? t.initialValues : {} });
    return t.type === "inactive"
      ? null
      : C.createElement(
          Vb,
          {
            open: !0,
            onOpenChange: (f) => {
              f || (o(), d({ src: "", title: "", altText: "" }));
            },
          },
          C.createElement(
            zb,
            { container: n == null ? void 0 : n.current },
            C.createElement(jb, { className: D.dialogOverlay }),
            C.createElement(
              Ub,
              {
                className: D.dialogContent,
                onOpenAutoFocus: (f) => {
                  f.preventDefault();
                },
              },
              C.createElement(Wb, null, s("uploadImage.dialogTitle", "Upload an image")),
              C.createElement(
                "form",
                {
                  onSubmit: async (f) => {
                    f.preventDefault(), f.stopPropagation(), await a(i)(f), d({ src: "", title: "", altText: "" });
                  },
                  className: D.multiFieldForm,
                },
                r === null
                  ? C.createElement("input", { type: "hidden", accept: "image/*", ...l("file") })
                  : C.createElement(
                      "div",
                      { className: D.formField },
                      C.createElement(
                        "label",
                        { htmlFor: "file" },
                        s("uploadImage.uploadInstructions", "Upload an image from your device:"),
                      ),
                      C.createElement("input", { type: "file", accept: "image/*", ...l("file") }),
                    ),
                C.createElement(
                  "div",
                  { className: D.formField },
                  C.createElement(
                    "label",
                    { htmlFor: "src" },
                    r !== null
                      ? s("uploadImage.addViaUrlInstructions", "Or add an image from an URL:")
                      : s("uploadImage.addViaUrlInstructionsNoUpload", "Add an image from an URL:"),
                  ),
                  C.createElement(cy, {
                    register: l,
                    initialInputValue: t.type === "editing" ? t.initialValues.src ?? "" : "",
                    inputName: "src",
                    suggestions: e,
                    setValue: c,
                    control: u,
                    placeholder: s("uploadImage.autoCompletePlaceholder", "Select or paste an image src"),
                  }),
                ),
                C.createElement(
                  "div",
                  { className: D.formField },
                  C.createElement("label", { htmlFor: "alt" }, s("uploadImage.alt", "Alt:")),
                  C.createElement("input", { type: "text", ...l("altText"), className: D.textInput }),
                ),
                C.createElement(
                  "div",
                  { className: D.formField },
                  C.createElement("label", { htmlFor: "title" }, s("uploadImage.title", "Title:")),
                  C.createElement("input", { type: "text", ...l("title"), className: D.textInput }),
                ),
                C.createElement(
                  "div",
                  { style: { display: "flex", justifyContent: "flex-end", gap: "var(--spacing-2)" } },
                  C.createElement(
                    "button",
                    {
                      type: "submit",
                      title: s("dialogControls.save", "Save"),
                      "aria-label": s("dialogControls.save", "Save"),
                      className: we(D.primaryButton),
                    },
                    s("dialogControls.save", "Save"),
                  ),
                  C.createElement(
                    Kb,
                    { asChild: !0 },
                    C.createElement(
                      "button",
                      {
                        type: "reset",
                        title: s("dialogControls.cancel", "Cancel"),
                        "aria-label": s("dialogControls.cancel", "Cancel"),
                        className: we(D.secondaryButton),
                      },
                      s("dialogControls.cancel", "Cancel"),
                    ),
                  ),
                ),
              ),
            ),
          ),
        );
  };
function Mu(e, t, n) {
  return Math.min(Math.max(e, t), n);
}
const Pe = { east: 1, north: 8, south: 2, west: 4 };
function yI({ onResizeStart: e, onResizeEnd: t, imageRef: n, maxWidth: r, editor: i }) {
  const o = E.useRef(null),
    s = E.useRef({ priority: "", value: "default" }),
    l = E.useRef({
      currentHeight: 0,
      currentWidth: 0,
      direction: 0,
      isResizing: !1,
      ratio: 0,
      startHeight: 0,
      startWidth: 0,
      startX: 0,
      startY: 0,
    }),
    a = i.getRootElement(),
    u = r || (a !== null ? a.getBoundingClientRect().width - 20 : 100),
    c = a !== null ? a.getBoundingClientRect().height - 20 : 100,
    d = 100,
    f = 100,
    h = (m) => {
      const v = m === Pe.east || m === Pe.west,
        _ = m === Pe.north || m === Pe.south,
        k = (m & Pe.north && m & Pe.west) || (m & Pe.south && m & Pe.east),
        w = v ? "ew" : _ ? "ns" : k ? "nwse" : "nesw";
      a !== null && a.style.setProperty("cursor", `${w}-resize`, "important"),
        document.body !== null &&
          (document.body.style.setProperty("cursor", `${w}-resize`, "important"),
          (s.current.value = document.body.style.getPropertyValue("-webkit-user-select")),
          (s.current.priority = document.body.style.getPropertyPriority("-webkit-user-select")),
          document.body.style.setProperty("-webkit-user-select", "none", "important"));
    },
    p = () => {
      a !== null && a.style.setProperty("cursor", "text"),
        document.body !== null &&
          (document.body.style.setProperty("cursor", "default"),
          document.body.style.setProperty("-webkit-user-select", s.current.value, s.current.priority));
    },
    g = (m, v) => {
      if (!i.isEditable()) return;
      const _ = n.current,
        k = o.current;
      if (_ !== null && k !== null) {
        m.preventDefault();
        const { width: w, height: y } = _.getBoundingClientRect(),
          S = l.current;
        (S.startWidth = w),
          (S.startHeight = y),
          (S.ratio = w / y),
          (S.currentWidth = w),
          (S.currentHeight = y),
          (S.startX = m.clientX),
          (S.startY = m.clientY),
          (S.isResizing = !0),
          (S.direction = v),
          h(v),
          e(),
          k.classList.add(D.imageControlWrapperResizing),
          (_.style.height = `${y}px`),
          (_.style.width = `${w}px`),
          document.addEventListener("pointermove", x),
          document.addEventListener("pointerup", b);
      }
    },
    x = (m) => {
      const v = n.current,
        _ = l.current,
        k = _.direction & (Pe.east | Pe.west),
        w = _.direction & (Pe.south | Pe.north);
      if (v !== null && _.isResizing)
        if (k && w) {
          let y = Math.floor(_.startX - m.clientX);
          y = _.direction & Pe.east ? -y : y;
          const S = Mu(_.startWidth + y, d, u),
            T = S / _.ratio;
          (v.style.width = `${S}px`), (v.style.height = `${T}px`), (_.currentHeight = T), (_.currentWidth = S);
        } else if (w) {
          let y = Math.floor(_.startY - m.clientY);
          y = _.direction & Pe.south ? -y : y;
          const S = Mu(_.startHeight + y, f, c);
          (v.style.height = `${S}px`), (_.currentHeight = S);
        } else {
          let y = Math.floor(_.startX - m.clientX);
          y = _.direction & Pe.east ? -y : y;
          const S = Mu(_.startWidth + y, d, u);
          (v.style.width = `${S}px`), (_.currentWidth = S);
        }
    },
    b = () => {
      const m = n.current,
        v = l.current,
        _ = o.current;
      if (m !== null && _ !== null && v.isResizing) {
        const k = v.currentWidth,
          w = v.currentHeight;
        (v.startWidth = 0),
          (v.startHeight = 0),
          (v.ratio = 0),
          (v.startX = 0),
          (v.startY = 0),
          (v.currentWidth = 0),
          (v.currentHeight = 0),
          (v.isResizing = !1),
          _.classList.remove(D.imageControlWrapperResizing),
          p(),
          t(k, w),
          document.removeEventListener("pointermove", x),
          document.removeEventListener("pointerup", b);
      }
    };
  return E.createElement(
    "div",
    { ref: o },
    E.createElement("div", {
      className: we(D.imageResizer, D.imageResizerN),
      onPointerDown: (m) => {
        g(m, Pe.north);
      },
    }),
    E.createElement("div", {
      className: we(D.imageResizer, D.imageResizerNe),
      onPointerDown: (m) => {
        g(m, Pe.north | Pe.east);
      },
    }),
    E.createElement("div", {
      className: we(D.imageResizer, D.imageResizerE),
      onPointerDown: (m) => {
        g(m, Pe.east);
      },
    }),
    E.createElement("div", {
      className: we(D.imageResizer, D.imageResizerSe),
      onPointerDown: (m) => {
        g(m, Pe.south | Pe.east);
      },
    }),
    E.createElement("div", {
      className: we(D.imageResizer, D.imageResizerS),
      onPointerDown: (m) => {
        g(m, Pe.south);
      },
    }),
    E.createElement("div", {
      className: we(D.imageResizer, D.imageResizerSw),
      onPointerDown: (m) => {
        g(m, Pe.south | Pe.west);
      },
    }),
    E.createElement("div", {
      className: we(D.imageResizer, D.imageResizerW),
      onPointerDown: (m) => {
        g(m, Pe.west);
      },
    }),
    E.createElement("div", {
      className: we(D.imageResizer, D.imageResizerNw),
      onPointerDown: (m) => {
        g(m, Pe.north | Pe.west);
      },
    }),
  );
}
const CI =
    "data:image/svg+xml;charset=utf-8," +
    encodeURIComponent(`
    <svg id="imgLoadError" xmlns="http://www.w3.org/2000/svg" width="100" height="100">
      <rect x="0" y="0" width="100" height="100" fill="none" stroke="red" stroke-width="4" stroke-dasharray="4" />
      <text x="50" y="55" text-anchor="middle" font-size="20" fill="red">⚠️</text>
    </svg>
`),
  _I = {
    __cache: {},
    read(e) {
      if (
        (this.__cache[e] ||
          (this.__cache[e] = new Promise((t) => {
            const n = new Image();
            (n.onerror = () => {
              (this.__cache[e] = CI), t();
            }),
              (n.onload = () => {
                (this.__cache[e] = e), t();
              }),
              (n.src = e);
          })),
        this.__cache[e] instanceof Promise)
      )
        throw this.__cache[e];
      return this.__cache[e];
    },
  };
function wI({ title: e, alt: t, className: n, imageRef: r, src: i, width: o, height: s }) {
  return C.createElement("img", {
    className: n ?? void 0,
    alt: t,
    src: _I.read(i),
    title: e,
    ref: r,
    draggable: "false",
    width: o,
    height: s,
  });
}
function EI({ src: e, title: t, alt: n, nodeKey: r, width: i, height: o, rest: s }) {
  const [l, a, u, c, d] = Le(id, nd, rd, ct, od),
    f = C.useRef(null),
    h = C.useRef(null),
    [p, g, x] = sv(r),
    [b] = bt(),
    [m, v] = C.useState(null),
    _ = C.useRef(null),
    [k, w] = C.useState(!1),
    [y, S] = C.useState(null),
    [T, A] = C.useState(null),
    F = C.useCallback(
      (te) => {
        if (p && Je(J())) {
          te.preventDefault();
          const se = Oe(r);
          Bl(se) && se.remove();
        }
        return !1;
      },
      [p, r],
    ),
    R = C.useCallback(
      (te) => {
        const L = J(),
          se = h.current;
        return p && Je(L) && L.getNodes().length === 1 && se !== null && se !== document.activeElement
          ? (te.preventDefault(), se.focus(), !0)
          : !1;
      },
      [p],
    ),
    V = C.useCallback(
      (te) =>
        h.current === te.target
          ? (Ye(null),
            b.update(() => {
              g(!0);
              const L = b.getRootElement();
              L !== null && L.focus();
            }),
            !0)
          : !1,
      [b, g],
    );
  C.useEffect(() => {
    u
      ? (async () => {
          T || A(e);
          const L = await u(e);
          S(L);
        })().catch((L) => {
          console.error(L);
        })
      : S(e);
  }, [e, u, T]),
    C.useEffect(() => {
      let te = !0;
      const L = yt(
        b.registerUpdateListener(({ editorState: se }) => {
          te && v(se.read(() => J()));
        }),
        b.registerCommand(os, (se, pe) => ((_.current = pe), !1), He),
        b.registerCommand(
          Ql,
          (se) => {
            const pe = se;
            return k ? !0 : pe.target === f.current ? (pe.shiftKey ? g(!p) : (x(), g(!0)), !0) : !1;
          },
          He,
        ),
        b.registerCommand(ia, (se) => (se.target === f.current ? (se.preventDefault(), !0) : !1), He),
        b.registerCommand(Wd, F, He),
        b.registerCommand(na, F, He),
        b.registerCommand(Oi, R, He),
        b.registerCommand(ls, V, He),
      );
      return () => {
        (te = !1), L();
      };
    }, [x, b, k, p, r, F, R, V, g]);
  const B = (te, L) => {
      setTimeout(() => {
        w(!1);
      }, 200),
        b.update(() => {
          const se = Oe(r);
          Bl(se) && se.setWidthAndHeight(te, L);
        });
    },
    N = () => {
      w(!0);
    },
    G = Je(m),
    U = p,
    X = C.useMemo(() => {
      if (s.length === 0) return null;
      const te = s.find((L) => L.type === "mdxJsxAttribute" && (L.name === "class" || L.name === "className"));
      return te ? te.value : null;
    }, [s]);
  return y !== null
    ? C.createElement(
        C.Suspense,
        { fallback: l ? C.createElement(l, null) : null },
        C.createElement(
          "div",
          { className: D.imageWrapper, "data-editor-block-type": "image" },
          C.createElement(
            "div",
            { draggable: G },
            C.createElement(wI, {
              width: i,
              height: o,
              className: we({ [D.focusedImage]: U }, X),
              src: y,
              title: t ?? "",
              alt: n ?? "",
              imageRef: f,
            }),
          ),
          G && U && !a && C.createElement(yI, { editor: b, imageRef: f, onResizeStart: N, onResizeEnd: B }),
          c || C.createElement(d, { nodeKey: r, imageSource: y, initialImagePath: T, title: t ?? "", alt: n ?? "" }),
        ),
      )
    : null;
}
var kI = Object.defineProperty,
  SI = (e, t, n) => (t in e ? kI(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (e[t] = n)),
  gi = (e, t, n) => (SI(e, typeof t != "symbol" ? t + "" : t, n), n);
function TI(e) {
  if (e instanceof HTMLImageElement) {
    const { alt: t, src: n, title: r, width: i, height: o } = e;
    return { node: ui({ altText: t, src: n, title: r, width: i, height: o }) };
  }
  return null;
}
class Es extends Cr {
  constructor(t, n, r, i, o, s, l) {
    super(l),
      gi(this, "__src"),
      gi(this, "__altText"),
      gi(this, "__title"),
      gi(this, "__width"),
      gi(this, "__height"),
      gi(this, "__rest"),
      (this.__src = t),
      (this.__title = r),
      (this.__altText = n),
      (this.__width = i || "inherit"),
      (this.__height = o || "inherit"),
      (this.__rest = s ?? []);
  }
  static getType() {
    return "image";
  }
  static clone(t) {
    return new Es(t.__src, t.__altText, t.__title, t.__width, t.__height, t.__rest, t.__key);
  }
  static importJSON(t) {
    const { altText: n, title: r, src: i, width: o, rest: s, height: l } = t;
    return ui({ altText: n, title: r, src: i, height: l, width: o, rest: s });
  }
  exportDOM() {
    const t = document.createElement("img");
    return (
      t.setAttribute("src", this.__src),
      t.setAttribute("alt", this.__altText),
      this.__title && t.setAttribute("title", this.__title),
      this.__width && t.setAttribute("width", this.__width.toString()),
      this.__height && t.setAttribute("height", this.__height.toString()),
      { element: t }
    );
  }
  static importDOM() {
    return { img: () => ({ conversion: TI, priority: 0 }) };
  }
  exportJSON() {
    return {
      altText: this.getAltText(),
      title: this.getTitle(),
      height: this.__height === "inherit" ? 0 : this.__height,
      width: this.__width === "inherit" ? 0 : this.__width,
      src: this.getSrc(),
      rest: this.__rest,
      type: "image",
      version: 1,
    };
  }
  setWidthAndHeight(t, n) {
    const r = this.getWritable();
    (r.__width = t), (r.__height = n);
  }
  createDOM(t) {
    const n = document.createElement("span"),
      i = t.theme.image;
    return i !== void 0 && (n.className = i), n;
  }
  updateDOM() {
    return !1;
  }
  getSrc() {
    return this.__src;
  }
  getAltText() {
    return this.__altText;
  }
  getTitle() {
    return this.__title;
  }
  getHeight() {
    return this.__height;
  }
  getWidth() {
    return this.__width;
  }
  getRest() {
    return this.__rest;
  }
  setTitle(t) {
    this.getWritable().__title = t;
  }
  setSrc(t) {
    this.getWritable().__src = t;
  }
  setAltText(t) {
    this.getWritable().__altText = t ?? "";
  }
  shouldBeSerializedAsElement() {
    return this.__width !== "inherit" || this.__height !== "inherit" || this.__rest.length > 0;
  }
  decorate(t) {
    return C.createElement(EI, {
      src: this.getSrc(),
      title: this.getTitle(),
      nodeKey: this.getKey(),
      width: this.__width,
      height: this.__height,
      alt: this.__altText,
      rest: this.__rest,
    });
  }
}
function ui(e) {
  const { altText: t, title: n, src: r, key: i, width: o, height: s, rest: l } = e;
  return new Es(r, t, n, o, s, l, i);
}
function Bl(e) {
  return e instanceof Es;
}
const AI = {
    testLexicalNode: Bl,
    visitLexicalNode({ mdastParent: e, lexicalNode: t, actions: n }) {
      if (t.shouldBeSerializedAsElement()) {
        const r = new Image();
        t.getHeight() !== "inherit" && (r.height = t.getHeight()),
          t.getWidth() !== "inherit" && (r.width = t.getWidth()),
          t.getAltText() && (r.alt = t.getAltText()),
          t.getTitle() && (r.title = t.getTitle());
        for (const i of t.getRest())
          i.type === "mdxJsxAttribute" && typeof i.value == "string" && r.setAttribute(i.name, i.value);
        n.appendToParent(e, { type: "html", value: r.outerHTML.replace(/>$/, ` src="${t.getSrc()}" />`) });
      } else n.appendToParent(e, { type: "image", url: t.getSrc(), alt: t.getAltText(), title: t.getTitle() });
    },
  },
  II = {
    testNode: "image",
    visitNode({ mdastNode: e, actions: t }) {
      t.addAndStepInto(ui({ src: e.url, altText: e.alt ?? "", title: e.title ?? "" }));
    },
  },
  NI = {
    testNode: (e) => e.type === "html" && e.value.trim().startsWith("<img"),
    visitNode({ mdastNode: e, lexicalParent: t }) {
      const n = document.createElement("div");
      n.innerHTML = e.value;
      const r = n.querySelector("img");
      if (!r) throw new Error("Invalid HTML image");
      const i = r.src,
        o = r.alt,
        s = r.title,
        l = r.width,
        a = r.height,
        u = ui({ src: i || "", altText: o, title: s, width: l, height: a });
      if (t.getType() === "root") {
        const c = Se();
        c.append(u), t.append(c);
      } else t.append(u);
    },
  };
function vo(e, t) {
  const n = e.attributes.find((r) => r.type === "mdxJsxAttribute" && r.name === t);
  if (n) return n.value;
}
const LI = {
    testNode: (e) => (e.type === "mdxJsxTextElement" || e.type === "mdxJsxFlowElement") && e.name === "img",
    visitNode({ mdastNode: e, lexicalParent: t }) {
      const n = vo(e, "src");
      if (!n) return;
      const r = vo(e, "alt") ?? "",
        i = vo(e, "title"),
        o = vo(e, "height"),
        s = vo(e, "width"),
        l = e.attributes.filter(
          (u) => u.type === "mdxJsxAttribute" && !["src", "alt", "title", "height", "width"].includes(u.name),
        ),
        a = ui({
          src: n,
          altText: r,
          title: i,
          width: s ? parseInt(s, 10) : void 0,
          height: o ? parseInt(o, 10) : void 0,
          rest: l,
        });
      if (t.getType() === "root") {
        const u = Se();
        u.append(a), t.append(u);
      } else t.append(a);
    },
  },
  _h = Ze((e) => {
    e.sub(e.pipe(_h, Ve(je)), ([t, n]) => {
      n == null ||
        n.update(() => {
          const r = ui({ altText: t.altText ?? "", src: t.src, title: t.title ?? "" });
          Yi([r]), tt(r.getParentOrThrow()) && bf(r, Se).selectEnd();
        });
    });
  }),
  MI = Ze((e) => {
    e.sub(e.pipe(MI, Ve(fr)), ([t, n]) => {
      const r = (i) => {
        e.pub(_h, { ...t, src: i });
      };
      "file" in t
        ? n == null ||
          n(t.file)
            .then(r)
            .catch((i) => {
              throw i;
            })
        : r(t.src);
    });
  }),
  td = ne([]),
  nd = ne(!1),
  fr = ne(null),
  rd = ne(null),
  id = ne(null),
  Hr = ne({ type: "inactive" }, (e) => {
    e.sub(e.pipe(gy, Ve(je, fr, Hr)), ([t, n, r, i]) => {
      const o =
        i.type === "editing"
          ? (s) => {
              n == null ||
                n.update(() => {
                  const { nodeKey: l } = i,
                    a = Oe(l);
                  a.setTitle(t.title), a.setAltText(t.altText), a.setSrc(s);
                }),
                e.pub(Hr, { type: "inactive" });
            }
          : (s) => {
              e.pub(_h, { ...t, src: s }), e.pub(Hr, { type: "inactive" });
            };
      t.file && t.file.length > 0
        ? r == null ||
          r(t.file.item(0))
            .then(o)
            .catch((s) => {
              throw s;
            })
        : t.src && o(t.src);
    }),
      e.pub(qo, (t) => {
        const n = e.getValue(fr);
        return yt(
          t.registerCommand(
            Hl,
            (r) => {
              const i = ui(r);
              return Yi([i]), tt(i.getParentOrThrow()) && bf(i, Se).selectEnd(), !0;
            },
            be,
          ),
          t.registerCommand(ia, (r) => PI(r), wl),
          t.registerCommand(Jd, (r) => DI(r, !!n), He),
          t.registerCommand(Kd, (r) => $I(r, t, e.getValue(fr)), wl),
          t.registerCommand(
            ss,
            (r) => {
              var i, o;
              if (!n) {
                let u = Array.from(((i = r.clipboardData) == null ? void 0 : i.items) ?? []);
                return (u = u.filter((c) => c.type.includes("text"))), !u.length || u.length === 0;
              }
              const s = Array.from(((o = r.clipboardData) == null ? void 0 : o.items) ?? []);
              if (s.some((u) => !u.type.includes("image")) || !s.length || s.length === 0) return !1;
              const a = e.getValue(fr);
              return (
                Promise.all(s.map((u) => a(u.getAsFile())))
                  .then((u) => {
                    u.forEach((c) => {
                      t.dispatchCommand(Hl, { src: c, altText: "" });
                    });
                  })
                  .catch((u) => {
                    throw u;
                  }),
                !0
              );
            },
            Bt,
          ),
        );
      });
  }),
  dy = Nn((e) => {
    e.link(e.pipe(dy, I1({ type: "new" })), Hr);
  }),
  fy = Ze((e) => {
    e.link(
      e.pipe(
        fy,
        tn((t) => ({ type: "editing", ...t })),
      ),
      Hr,
    );
  }),
  hy = Nn((e) => {
    e.link(e.pipe(hy, I1({ type: "inactive" })), Hr);
  }),
  py = ne(!1),
  gy = Ze(),
  od = ne(Qc),
  OI = vt({
    init(e, t) {
      e.pubIn({
        [Gt]: [II, NI, LI],
        [fn]: Es,
        [hn]: AI,
        [ai]: (t == null ? void 0 : t.ImageDialog) ?? bI,
        [fr]: (t == null ? void 0 : t.imageUploadHandler) ?? null,
        [td]: (t == null ? void 0 : t.imageAutocompleteSuggestions) ?? [],
        [nd]: !!(t != null && t.disableImageResize),
        [py]: !!(t != null && t.disableImageSettingsButton),
        [rd]: (t == null ? void 0 : t.imagePreviewHandler) ?? null,
        [od]: (t == null ? void 0 : t.EditImageToolbar) ?? Qc,
        [id]: (t == null ? void 0 : t.imagePlaceholder) ?? Em,
      });
    },
    update(e, t) {
      e.pubIn({
        [fr]: (t == null ? void 0 : t.imageUploadHandler) ?? null,
        [td]: (t == null ? void 0 : t.imageAutocompleteSuggestions) ?? [],
        [nd]: !!(t != null && t.disableImageResize),
        [rd]: (t == null ? void 0 : t.imagePreviewHandler) ?? null,
        [od]: (t == null ? void 0 : t.EditImageToolbar) ?? Qc,
        [id]: (t == null ? void 0 : t.imagePlaceholder) ?? Em,
      });
    },
  }),
  FI = (e) => (iv ? (e ?? window).getSelection() : null),
  Hl = ae("INSERT_IMAGE_COMMAND"),
  RI = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
function PI(e) {
  const t = wh();
  if (!t) return !1;
  const n = e.dataTransfer;
  if (!n) return !1;
  n.setData("text/plain", "_");
  const r = document.createElement("img");
  return (
    (r.src = RI),
    n.setDragImage(r, 0, 0),
    n.setData(
      "application/x-lexical-drag",
      JSON.stringify({
        data: { altText: t.__altText, title: t.__title, key: t.getKey(), src: t.__src },
        type: "image",
      }),
    ),
    !0
  );
}
function DI(e, t) {
  var n;
  if (t) {
    let i = Array.from(((n = e.dataTransfer) == null ? void 0 : n.items) ?? []);
    if (((i = i.filter((o) => o.type.includes("image"))), i.length > 0)) return e.preventDefault(), !0;
  }
  return wh() ? (my(e) || e.preventDefault(), !0) : !1;
}
function $I(e, t, n) {
  var r;
  let i = Array.from(((r = e.dataTransfer) == null ? void 0 : r.items) ?? []);
  if (((i = i.filter((l) => l.type.includes("image"))), i.length > 0 && n !== null))
    return (
      e.preventDefault(),
      Promise.all(
        i.map((l) =>
          l.kind === "string"
            ? new Promise((a) => {
                l.getAsString(a);
              })
            : n(l.getAsFile()),
        ),
      )
        .then((l) => {
          l.forEach((a) => {
            t.dispatchCommand(Hl, { src: a, altText: "" });
          });
        })
        .catch((l) => {
          throw l;
        }),
      !0
    );
  const o = wh();
  if (!o) return !1;
  const s = BI(e);
  if (!s) return !1;
  if ((e.preventDefault(), my(e))) {
    const l = HI(e);
    o.remove();
    const a = qi();
    l != null && a.applyDOMRange(l), Ye(a), t.dispatchCommand(Hl, s);
  }
  return !0;
}
function wh() {
  const e = J();
  if (!Je(e)) return null;
  const n = e.getNodes()[0];
  return Bl(n) ? n : null;
}
function BI(e) {
  var t;
  const n = (t = e.dataTransfer) == null ? void 0 : t.getData("application/x-lexical-drag");
  if (!n) return null;
  const { type: r, data: i } = JSON.parse(n);
  return r !== "image" ? null : i;
}
function my(e) {
  const t = e.target;
  return !!(t && t instanceof HTMLElement && t.parentElement);
}
function HI(e) {
  let t;
  const n = e.target,
    r = n == null ? null : n.nodeType === 9 ? n.defaultView : n.ownerDocument.defaultView,
    i = FI(r);
  if (document.caretRangeFromPoint) t = document.caretRangeFromPoint(e.clientX, e.clientY);
  else if (e.rangeParent && i !== null) i.collapse(e.rangeParent, e.rangeOffset ?? 0), (t = i.getRangeAt(0));
  else throw Error("Cannot get the selection when dragging");
  return t;
}
var xy = { exports: {} };
(function (e) {
  (function () {
    var t;
    (t = e.exports = i),
      (t.format = i),
      (t.vsprintf = r),
      typeof console < "u" && typeof console.log == "function" && (t.printf = n);
    function n() {
      console.log(i.apply(null, arguments));
    }
    function r(o, s) {
      return i.apply(null, [o].concat(s));
    }
    function i(o) {
      for (
        var s = 1,
          l = [].slice.call(arguments),
          a = 0,
          u = o.length,
          c = "",
          d,
          f = !1,
          h,
          p,
          g = !1,
          x,
          b = function () {
            return l[s++];
          },
          m = function () {
            for (var v = ""; /\d/.test(o[a]); ) (v += o[a++]), (d = o[a]);
            return v.length > 0 ? parseInt(v) : null;
          };
        a < u;
        ++a
      )
        if (((d = o[a]), f))
          switch (
            ((f = !1),
            d == "."
              ? ((g = !1), (d = o[++a]))
              : d == "0" && o[a + 1] == "."
                ? ((g = !0), (a += 2), (d = o[a]))
                : (g = !0),
            (x = m()),
            d)
          ) {
            case "b":
              c += parseInt(b(), 10).toString(2);
              break;
            case "c":
              (h = b()),
                typeof h == "string" || h instanceof String ? (c += h) : (c += String.fromCharCode(parseInt(h, 10)));
              break;
            case "d":
              c += parseInt(b(), 10);
              break;
            case "f":
              (p = String(parseFloat(b()).toFixed(x || 6))), (c += g ? p : p.replace(/^0/, ""));
              break;
            case "j":
              c += JSON.stringify(b());
              break;
            case "o":
              c += "0" + parseInt(b(), 10).toString(8);
              break;
            case "s":
              c += b();
              break;
            case "x":
              c += "0x" + parseInt(b(), 10).toString(16);
              break;
            case "X":
              c += "0x" + parseInt(b(), 10).toString(16).toUpperCase();
              break;
            default:
              c += d;
              break;
          }
        else d === "%" ? (f = !0) : (c += d);
      return c;
    }
  })();
})(xy);
var VI = xy.exports;
const zI = w1(VI),
  Ks = Object.assign(Or(Error), {
    eval: Or(EvalError),
    range: Or(RangeError),
    reference: Or(ReferenceError),
    syntax: Or(SyntaxError),
    type: Or(TypeError),
    uri: Or(URIError),
  });
function Or(e) {
  return (t.displayName = e.displayName || e.name), t;
  function t(n, ...r) {
    const i = n && zI(n, ...r);
    return new e(i);
  }
}
const Js = {}.hasOwnProperty,
  Mm = { yaml: "-", toml: "+" };
function Eh(e) {
  const t = [];
  let n = -1;
  const r = Array.isArray(e) ? e : e ? [e] : ["yaml"];
  for (; ++n < r.length; ) t[n] = jI(r[n]);
  return t;
}
function jI(e) {
  let t = e;
  if (typeof t == "string") {
    if (!Js.call(Mm, t)) throw Ks("Missing matter definition for `%s`", t);
    t = { type: t, marker: Mm[t] };
  } else if (typeof t != "object") throw Ks("Expected matter to be an object, not `%j`", t);
  if (!Js.call(t, "type")) throw Ks("Missing `type` in matter `%j`", t);
  if (!Js.call(t, "fence") && !Js.call(t, "marker")) throw Ks("Missing `marker` or `fence` in matter `%j`", t);
  return t;
}
function UI(e) {
  const t = Eh(e),
    n = {};
  let r = -1;
  for (; ++r < t.length; ) {
    const i = t[r],
      o = sd(i, "open").charCodeAt(0),
      s = WI(i),
      l = n[o];
    Array.isArray(l) ? l.push(s) : (n[o] = [s]);
  }
  return { flow: n };
}
function WI(e) {
  const t = e.anywhere,
    n = e.type,
    r = n + "Fence",
    i = r + "Sequence",
    o = n + "Value",
    s = { tokenize: c, partial: !0 };
  let l,
    a = 0;
  return { tokenize: u, concrete: !0 };
  function u(d, f, h) {
    const p = this;
    return g;
    function g(y) {
      const S = p.now();
      return S.column === 1 && (S.line === 1 || t) && ((l = sd(e, "open")), (a = 0), y === l.charCodeAt(a))
        ? (d.enter(n), d.enter(r), d.enter(i), x(y))
        : h(y);
    }
    function x(y) {
      return a === l.length
        ? (d.exit(i), fe(y) ? (d.enter("whitespace"), b(y)) : m(y))
        : y === l.charCodeAt(a++)
          ? (d.consume(y), x)
          : h(y);
    }
    function b(y) {
      return fe(y) ? (d.consume(y), b) : (d.exit("whitespace"), m(y));
    }
    function m(y) {
      return ee(y)
        ? (d.exit(r),
          d.enter("lineEnding"),
          d.consume(y),
          d.exit("lineEnding"),
          (l = sd(e, "close")),
          (a = 0),
          d.attempt(s, w, v))
        : h(y);
    }
    function v(y) {
      return y === null || ee(y) ? k(y) : (d.enter(o), _(y));
    }
    function _(y) {
      return y === null || ee(y) ? (d.exit(o), k(y)) : (d.consume(y), _);
    }
    function k(y) {
      return y === null ? h(y) : (d.enter("lineEnding"), d.consume(y), d.exit("lineEnding"), d.attempt(s, w, v));
    }
    function w(y) {
      return d.exit(n), f(y);
    }
  }
  function c(d, f, h) {
    let p = 0;
    return g;
    function g(v) {
      return v === l.charCodeAt(p) ? (d.enter(r), d.enter(i), x(v)) : h(v);
    }
    function x(v) {
      return p === l.length
        ? (d.exit(i), fe(v) ? (d.enter("whitespace"), b(v)) : m(v))
        : v === l.charCodeAt(p++)
          ? (d.consume(v), x)
          : h(v);
    }
    function b(v) {
      return fe(v) ? (d.consume(v), b) : (d.exit("whitespace"), m(v));
    }
    function m(v) {
      return v === null || ee(v) ? (d.exit(r), f(v)) : h(v);
    }
  }
}
function sd(e, t) {
  return e.marker ? Om(e.marker, t).repeat(3) : Om(e.fence, t);
}
function Om(e, t) {
  return typeof e == "string" ? e : e[t];
}
function KI(e) {
  if (typeof e != "string") throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function JI(e) {
  const t = Eh(e),
    n = {},
    r = {};
  let i = -1;
  for (; ++i < t.length; ) {
    const o = t[i];
    (n[o.type] = GI(o)), (r[o.type] = ZI), (r[o.type + "Value"] = qI);
  }
  return { enter: n, exit: r };
}
function GI(e) {
  return t;
  function t(n) {
    this.enter({ type: e.type, value: "" }, n), this.buffer();
  }
}
function ZI(e) {
  const t = this.resume(),
    n = this.stack[this.stack.length - 1];
  this.exit(e), (n.value = t.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""));
}
function qI(e) {
  this.config.enter.data.call(this, e), this.config.exit.data.call(this, e);
}
function YI(e) {
  const t = [],
    n = {},
    r = Eh(e);
  let i = -1;
  for (; ++i < r.length; ) {
    const o = r[i];
    n[o.type] = XI(o);
    const s = ld(o, "open");
    t.push({ atBreak: !0, character: s.charAt(0), after: KI(s.charAt(1)) });
  }
  return { unsafe: t, handlers: n };
}
function XI(e) {
  const t = ld(e, "open"),
    n = ld(e, "close");
  return r;
  function r(i) {
    return (
      t +
      (i.value
        ? `
` + i.value
        : "") +
      `
` +
      n
    );
  }
}
function ld(e, t) {
  return e.marker ? Fm(e.marker, t).repeat(3) : Fm(e.fence, t);
}
function Fm(e, t) {
  return typeof e == "string" ? e : e[t];
}
/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */ function vy(e) {
  return typeof e > "u" || e === null;
}
function QI(e) {
  return typeof e == "object" && e !== null;
}
function eN(e) {
  return Array.isArray(e) ? e : vy(e) ? [] : [e];
}
function tN(e, t) {
  var n, r, i, o;
  if (t) for (o = Object.keys(t), n = 0, r = o.length; n < r; n += 1) (i = o[n]), (e[i] = t[i]);
  return e;
}
function nN(e, t) {
  var n = "",
    r;
  for (r = 0; r < t; r += 1) n += e;
  return n;
}
function rN(e) {
  return e === 0 && Number.NEGATIVE_INFINITY === 1 / e;
}
var iN = vy,
  oN = QI,
  sN = eN,
  lN = nN,
  aN = rN,
  uN = tN,
  ot = { isNothing: iN, isObject: oN, toArray: sN, repeat: lN, isNegativeZero: aN, extend: uN };
function by(e, t) {
  var n = "",
    r = e.reason || "(unknown reason)";
  return e.mark
    ? (e.mark.name && (n += 'in "' + e.mark.name + '" '),
      (n += "(" + (e.mark.line + 1) + ":" + (e.mark.column + 1) + ")"),
      !t &&
        e.mark.snippet &&
        (n +=
          `

` + e.mark.snippet),
      r + " " + n)
    : r;
}
function Qo(e, t) {
  Error.call(this),
    (this.name = "YAMLException"),
    (this.reason = e),
    (this.mark = t),
    (this.message = by(this, !1)),
    Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : (this.stack = new Error().stack || "");
}
Qo.prototype = Object.create(Error.prototype);
Qo.prototype.constructor = Qo;
Qo.prototype.toString = function (t) {
  return this.name + ": " + by(this, t);
};
var kt = Qo;
function Ou(e, t, n, r, i) {
  var o = "",
    s = "",
    l = Math.floor(i / 2) - 1;
  return (
    r - t > l && ((o = " ... "), (t = r - l + o.length)),
    n - r > l && ((s = " ..."), (n = r + l - s.length)),
    { str: o + e.slice(t, n).replace(/\t/g, "→") + s, pos: r - t + o.length }
  );
}
function Fu(e, t) {
  return ot.repeat(" ", t - e.length) + e;
}
function cN(e, t) {
  if (((t = Object.create(t || null)), !e.buffer)) return null;
  t.maxLength || (t.maxLength = 79),
    typeof t.indent != "number" && (t.indent = 1),
    typeof t.linesBefore != "number" && (t.linesBefore = 3),
    typeof t.linesAfter != "number" && (t.linesAfter = 2);
  for (var n = /\r?\n|\r|\0/g, r = [0], i = [], o, s = -1; (o = n.exec(e.buffer)); )
    i.push(o.index), r.push(o.index + o[0].length), e.position <= o.index && s < 0 && (s = r.length - 2);
  s < 0 && (s = r.length - 1);
  var l = "",
    a,
    u,
    c = Math.min(e.line + t.linesAfter, i.length).toString().length,
    d = t.maxLength - (t.indent + c + 3);
  for (a = 1; a <= t.linesBefore && !(s - a < 0); a++)
    (u = Ou(e.buffer, r[s - a], i[s - a], e.position - (r[s] - r[s - a]), d)),
      (l =
        ot.repeat(" ", t.indent) +
        Fu((e.line - a + 1).toString(), c) +
        " | " +
        u.str +
        `
` +
        l);
  for (
    u = Ou(e.buffer, r[s], i[s], e.position, d),
      l +=
        ot.repeat(" ", t.indent) +
        Fu((e.line + 1).toString(), c) +
        " | " +
        u.str +
        `
`,
      l +=
        ot.repeat("-", t.indent + c + 3 + u.pos) +
        `^
`,
      a = 1;
    a <= t.linesAfter && !(s + a >= i.length);
    a++
  )
    (u = Ou(e.buffer, r[s + a], i[s + a], e.position - (r[s] - r[s + a]), d)),
      (l +=
        ot.repeat(" ", t.indent) +
        Fu((e.line + a + 1).toString(), c) +
        " | " +
        u.str +
        `
`);
  return l.replace(/\n$/, "");
}
var dN = cN,
  fN = [
    "kind",
    "multi",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "representName",
    "defaultStyle",
    "styleAliases",
  ],
  hN = ["scalar", "sequence", "mapping"];
function pN(e) {
  var t = {};
  return (
    e !== null &&
      Object.keys(e).forEach(function (n) {
        e[n].forEach(function (r) {
          t[String(r)] = n;
        });
      }),
    t
  );
}
function gN(e, t) {
  if (
    ((t = t || {}),
    Object.keys(t).forEach(function (n) {
      if (fN.indexOf(n) === -1)
        throw new kt('Unknown option "' + n + '" is met in definition of "' + e + '" YAML type.');
    }),
    (this.options = t),
    (this.tag = e),
    (this.kind = t.kind || null),
    (this.resolve =
      t.resolve ||
      function () {
        return !0;
      }),
    (this.construct =
      t.construct ||
      function (n) {
        return n;
      }),
    (this.instanceOf = t.instanceOf || null),
    (this.predicate = t.predicate || null),
    (this.represent = t.represent || null),
    (this.representName = t.representName || null),
    (this.defaultStyle = t.defaultStyle || null),
    (this.multi = t.multi || !1),
    (this.styleAliases = pN(t.styleAliases || null)),
    hN.indexOf(this.kind) === -1)
  )
    throw new kt('Unknown kind "' + this.kind + '" is specified for "' + e + '" YAML type.');
}
var ht = gN;
function Rm(e, t) {
  var n = [];
  return (
    e[t].forEach(function (r) {
      var i = n.length;
      n.forEach(function (o, s) {
        o.tag === r.tag && o.kind === r.kind && o.multi === r.multi && (i = s);
      }),
        (n[i] = r);
    }),
    n
  );
}
function mN() {
  var e = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {},
      multi: { scalar: [], sequence: [], mapping: [], fallback: [] },
    },
    t,
    n;
  function r(i) {
    i.multi ? (e.multi[i.kind].push(i), e.multi.fallback.push(i)) : (e[i.kind][i.tag] = e.fallback[i.tag] = i);
  }
  for (t = 0, n = arguments.length; t < n; t += 1) arguments[t].forEach(r);
  return e;
}
function ad(e) {
  return this.extend(e);
}
ad.prototype.extend = function (t) {
  var n = [],
    r = [];
  if (t instanceof ht) r.push(t);
  else if (Array.isArray(t)) r = r.concat(t);
  else if (t && (Array.isArray(t.implicit) || Array.isArray(t.explicit)))
    t.implicit && (n = n.concat(t.implicit)), t.explicit && (r = r.concat(t.explicit));
  else
    throw new kt(
      "Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })",
    );
  n.forEach(function (o) {
    if (!(o instanceof ht))
      throw new kt("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    if (o.loadKind && o.loadKind !== "scalar")
      throw new kt(
        "There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.",
      );
    if (o.multi)
      throw new kt(
        "There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.",
      );
  }),
    r.forEach(function (o) {
      if (!(o instanceof ht))
        throw new kt("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    });
  var i = Object.create(ad.prototype);
  return (
    (i.implicit = (this.implicit || []).concat(n)),
    (i.explicit = (this.explicit || []).concat(r)),
    (i.compiledImplicit = Rm(i, "implicit")),
    (i.compiledExplicit = Rm(i, "explicit")),
    (i.compiledTypeMap = mN(i.compiledImplicit, i.compiledExplicit)),
    i
  );
};
var yy = ad,
  Cy = new ht("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function (e) {
      return e !== null ? e : "";
    },
  }),
  _y = new ht("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function (e) {
      return e !== null ? e : [];
    },
  }),
  wy = new ht("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function (e) {
      return e !== null ? e : {};
    },
  }),
  Ey = new yy({ explicit: [Cy, _y, wy] });
function xN(e) {
  if (e === null) return !0;
  var t = e.length;
  return (t === 1 && e === "~") || (t === 4 && (e === "null" || e === "Null" || e === "NULL"));
}
function vN() {
  return null;
}
function bN(e) {
  return e === null;
}
var ky = new ht("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: xN,
  construct: vN,
  predicate: bN,
  represent: {
    canonical: function () {
      return "~";
    },
    lowercase: function () {
      return "null";
    },
    uppercase: function () {
      return "NULL";
    },
    camelcase: function () {
      return "Null";
    },
    empty: function () {
      return "";
    },
  },
  defaultStyle: "lowercase",
});
function yN(e) {
  if (e === null) return !1;
  var t = e.length;
  return (
    (t === 4 && (e === "true" || e === "True" || e === "TRUE")) ||
    (t === 5 && (e === "false" || e === "False" || e === "FALSE"))
  );
}
function CN(e) {
  return e === "true" || e === "True" || e === "TRUE";
}
function _N(e) {
  return Object.prototype.toString.call(e) === "[object Boolean]";
}
var Sy = new ht("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: yN,
  construct: CN,
  predicate: _N,
  represent: {
    lowercase: function (e) {
      return e ? "true" : "false";
    },
    uppercase: function (e) {
      return e ? "TRUE" : "FALSE";
    },
    camelcase: function (e) {
      return e ? "True" : "False";
    },
  },
  defaultStyle: "lowercase",
});
function wN(e) {
  return (48 <= e && e <= 57) || (65 <= e && e <= 70) || (97 <= e && e <= 102);
}
function EN(e) {
  return 48 <= e && e <= 55;
}
function kN(e) {
  return 48 <= e && e <= 57;
}
function SN(e) {
  if (e === null) return !1;
  var t = e.length,
    n = 0,
    r = !1,
    i;
  if (!t) return !1;
  if (((i = e[n]), (i === "-" || i === "+") && (i = e[++n]), i === "0")) {
    if (n + 1 === t) return !0;
    if (((i = e[++n]), i === "b")) {
      for (n++; n < t; n++)
        if (((i = e[n]), i !== "_")) {
          if (i !== "0" && i !== "1") return !1;
          r = !0;
        }
      return r && i !== "_";
    }
    if (i === "x") {
      for (n++; n < t; n++)
        if (((i = e[n]), i !== "_")) {
          if (!wN(e.charCodeAt(n))) return !1;
          r = !0;
        }
      return r && i !== "_";
    }
    if (i === "o") {
      for (n++; n < t; n++)
        if (((i = e[n]), i !== "_")) {
          if (!EN(e.charCodeAt(n))) return !1;
          r = !0;
        }
      return r && i !== "_";
    }
  }
  if (i === "_") return !1;
  for (; n < t; n++)
    if (((i = e[n]), i !== "_")) {
      if (!kN(e.charCodeAt(n))) return !1;
      r = !0;
    }
  return !(!r || i === "_");
}
function TN(e) {
  var t = e,
    n = 1,
    r;
  if (
    (t.indexOf("_") !== -1 && (t = t.replace(/_/g, "")),
    (r = t[0]),
    (r === "-" || r === "+") && (r === "-" && (n = -1), (t = t.slice(1)), (r = t[0])),
    t === "0")
  )
    return 0;
  if (r === "0") {
    if (t[1] === "b") return n * parseInt(t.slice(2), 2);
    if (t[1] === "x") return n * parseInt(t.slice(2), 16);
    if (t[1] === "o") return n * parseInt(t.slice(2), 8);
  }
  return n * parseInt(t, 10);
}
function AN(e) {
  return Object.prototype.toString.call(e) === "[object Number]" && e % 1 === 0 && !ot.isNegativeZero(e);
}
var Ty = new ht("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: SN,
    construct: TN,
    predicate: AN,
    represent: {
      binary: function (e) {
        return e >= 0 ? "0b" + e.toString(2) : "-0b" + e.toString(2).slice(1);
      },
      octal: function (e) {
        return e >= 0 ? "0o" + e.toString(8) : "-0o" + e.toString(8).slice(1);
      },
      decimal: function (e) {
        return e.toString(10);
      },
      hexadecimal: function (e) {
        return e >= 0 ? "0x" + e.toString(16).toUpperCase() : "-0x" + e.toString(16).toUpperCase().slice(1);
      },
    },
    defaultStyle: "decimal",
    styleAliases: { binary: [2, "bin"], octal: [8, "oct"], decimal: [10, "dec"], hexadecimal: [16, "hex"] },
  }),
  IN = new RegExp(
    "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$",
  );
function NN(e) {
  return !(e === null || !IN.test(e) || e[e.length - 1] === "_");
}
function LN(e) {
  var t, n;
  return (
    (t = e.replace(/_/g, "").toLowerCase()),
    (n = t[0] === "-" ? -1 : 1),
    "+-".indexOf(t[0]) >= 0 && (t = t.slice(1)),
    t === ".inf"
      ? n === 1
        ? Number.POSITIVE_INFINITY
        : Number.NEGATIVE_INFINITY
      : t === ".nan"
        ? NaN
        : n * parseFloat(t, 10)
  );
}
var MN = /^[-+]?[0-9]+e/;
function ON(e, t) {
  var n;
  if (isNaN(e))
    switch (t) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === e)
    switch (t) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === e)
    switch (t) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (ot.isNegativeZero(e)) return "-0.0";
  return (n = e.toString(10)), MN.test(n) ? n.replace("e", ".e") : n;
}
function FN(e) {
  return Object.prototype.toString.call(e) === "[object Number]" && (e % 1 !== 0 || ot.isNegativeZero(e));
}
var Ay = new ht("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: NN,
    construct: LN,
    predicate: FN,
    represent: ON,
    defaultStyle: "lowercase",
  }),
  Iy = Ey.extend({ implicit: [ky, Sy, Ty, Ay] }),
  Ny = Iy,
  Ly = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"),
  My = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$",
  );
function RN(e) {
  return e === null ? !1 : Ly.exec(e) !== null || My.exec(e) !== null;
}
function PN(e) {
  var t,
    n,
    r,
    i,
    o,
    s,
    l,
    a = 0,
    u = null,
    c,
    d,
    f;
  if (((t = Ly.exec(e)), t === null && (t = My.exec(e)), t === null)) throw new Error("Date resolve error");
  if (((n = +t[1]), (r = +t[2] - 1), (i = +t[3]), !t[4])) return new Date(Date.UTC(n, r, i));
  if (((o = +t[4]), (s = +t[5]), (l = +t[6]), t[7])) {
    for (a = t[7].slice(0, 3); a.length < 3; ) a += "0";
    a = +a;
  }
  return (
    t[9] && ((c = +t[10]), (d = +(t[11] || 0)), (u = (c * 60 + d) * 6e4), t[9] === "-" && (u = -u)),
    (f = new Date(Date.UTC(n, r, i, o, s, l, a))),
    u && f.setTime(f.getTime() - u),
    f
  );
}
function DN(e) {
  return e.toISOString();
}
var Oy = new ht("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: RN,
  construct: PN,
  instanceOf: Date,
  represent: DN,
});
function $N(e) {
  return e === "<<" || e === null;
}
var Fy = new ht("tag:yaml.org,2002:merge", { kind: "scalar", resolve: $N }),
  kh = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function BN(e) {
  if (e === null) return !1;
  var t,
    n,
    r = 0,
    i = e.length,
    o = kh;
  for (n = 0; n < i; n++)
    if (((t = o.indexOf(e.charAt(n))), !(t > 64))) {
      if (t < 0) return !1;
      r += 6;
    }
  return r % 8 === 0;
}
function HN(e) {
  var t,
    n,
    r = e.replace(/[\r\n=]/g, ""),
    i = r.length,
    o = kh,
    s = 0,
    l = [];
  for (t = 0; t < i; t++)
    t % 4 === 0 && t && (l.push((s >> 16) & 255), l.push((s >> 8) & 255), l.push(s & 255)),
      (s = (s << 6) | o.indexOf(r.charAt(t)));
  return (
    (n = (i % 4) * 6),
    n === 0
      ? (l.push((s >> 16) & 255), l.push((s >> 8) & 255), l.push(s & 255))
      : n === 18
        ? (l.push((s >> 10) & 255), l.push((s >> 2) & 255))
        : n === 12 && l.push((s >> 4) & 255),
    new Uint8Array(l)
  );
}
function VN(e) {
  var t = "",
    n = 0,
    r,
    i,
    o = e.length,
    s = kh;
  for (r = 0; r < o; r++)
    r % 3 === 0 && r && ((t += s[(n >> 18) & 63]), (t += s[(n >> 12) & 63]), (t += s[(n >> 6) & 63]), (t += s[n & 63])),
      (n = (n << 8) + e[r]);
  return (
    (i = o % 3),
    i === 0
      ? ((t += s[(n >> 18) & 63]), (t += s[(n >> 12) & 63]), (t += s[(n >> 6) & 63]), (t += s[n & 63]))
      : i === 2
        ? ((t += s[(n >> 10) & 63]), (t += s[(n >> 4) & 63]), (t += s[(n << 2) & 63]), (t += s[64]))
        : i === 1 && ((t += s[(n >> 2) & 63]), (t += s[(n << 4) & 63]), (t += s[64]), (t += s[64])),
    t
  );
}
function zN(e) {
  return Object.prototype.toString.call(e) === "[object Uint8Array]";
}
var Ry = new ht("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: BN,
    construct: HN,
    predicate: zN,
    represent: VN,
  }),
  jN = Object.prototype.hasOwnProperty,
  UN = Object.prototype.toString;
function WN(e) {
  if (e === null) return !0;
  var t = [],
    n,
    r,
    i,
    o,
    s,
    l = e;
  for (n = 0, r = l.length; n < r; n += 1) {
    if (((i = l[n]), (s = !1), UN.call(i) !== "[object Object]")) return !1;
    for (o in i)
      if (jN.call(i, o))
        if (!s) s = !0;
        else return !1;
    if (!s) return !1;
    if (t.indexOf(o) === -1) t.push(o);
    else return !1;
  }
  return !0;
}
function KN(e) {
  return e !== null ? e : [];
}
var Py = new ht("tag:yaml.org,2002:omap", { kind: "sequence", resolve: WN, construct: KN }),
  JN = Object.prototype.toString;
function GN(e) {
  if (e === null) return !0;
  var t,
    n,
    r,
    i,
    o,
    s = e;
  for (o = new Array(s.length), t = 0, n = s.length; t < n; t += 1) {
    if (((r = s[t]), JN.call(r) !== "[object Object]" || ((i = Object.keys(r)), i.length !== 1))) return !1;
    o[t] = [i[0], r[i[0]]];
  }
  return !0;
}
function ZN(e) {
  if (e === null) return [];
  var t,
    n,
    r,
    i,
    o,
    s = e;
  for (o = new Array(s.length), t = 0, n = s.length; t < n; t += 1)
    (r = s[t]), (i = Object.keys(r)), (o[t] = [i[0], r[i[0]]]);
  return o;
}
var Dy = new ht("tag:yaml.org,2002:pairs", { kind: "sequence", resolve: GN, construct: ZN }),
  qN = Object.prototype.hasOwnProperty;
function YN(e) {
  if (e === null) return !0;
  var t,
    n = e;
  for (t in n) if (qN.call(n, t) && n[t] !== null) return !1;
  return !0;
}
function XN(e) {
  return e !== null ? e : {};
}
var $y = new ht("tag:yaml.org,2002:set", { kind: "mapping", resolve: YN, construct: XN }),
  Sh = Ny.extend({ implicit: [Oy, Fy], explicit: [Ry, Py, Dy, $y] }),
  br = Object.prototype.hasOwnProperty,
  Vl = 1,
  By = 2,
  Hy = 3,
  zl = 4,
  Ru = 1,
  QN = 2,
  Pm = 3,
  eL =
    /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/,
  tL = /[\x85\u2028\u2029]/,
  nL = /[,\[\]\{\}]/,
  Vy = /^(?:!|!!|![a-z\-]+!)$/i,
  zy = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function Dm(e) {
  return Object.prototype.toString.call(e);
}
function Sn(e) {
  return e === 10 || e === 13;
}
function Vr(e) {
  return e === 9 || e === 32;
}
function Nt(e) {
  return e === 9 || e === 32 || e === 10 || e === 13;
}
function wi(e) {
  return e === 44 || e === 91 || e === 93 || e === 123 || e === 125;
}
function rL(e) {
  var t;
  return 48 <= e && e <= 57 ? e - 48 : ((t = e | 32), 97 <= t && t <= 102 ? t - 97 + 10 : -1);
}
function iL(e) {
  return e === 120 ? 2 : e === 117 ? 4 : e === 85 ? 8 : 0;
}
function oL(e) {
  return 48 <= e && e <= 57 ? e - 48 : -1;
}
function $m(e) {
  return e === 48
    ? "\0"
    : e === 97
      ? "\x07"
      : e === 98
        ? "\b"
        : e === 116 || e === 9
          ? "	"
          : e === 110
            ? `
`
            : e === 118
              ? "\v"
              : e === 102
                ? "\f"
                : e === 114
                  ? "\r"
                  : e === 101
                    ? "\x1B"
                    : e === 32
                      ? " "
                      : e === 34
                        ? '"'
                        : e === 47
                          ? "/"
                          : e === 92
                            ? "\\"
                            : e === 78
                              ? ""
                              : e === 95
                                ? " "
                                : e === 76
                                  ? "\u2028"
                                  : e === 80
                                    ? "\u2029"
                                    : "";
}
function sL(e) {
  return e <= 65535
    ? String.fromCharCode(e)
    : String.fromCharCode(((e - 65536) >> 10) + 55296, ((e - 65536) & 1023) + 56320);
}
var jy = new Array(256),
  Uy = new Array(256);
for (var mi = 0; mi < 256; mi++) (jy[mi] = $m(mi) ? 1 : 0), (Uy[mi] = $m(mi));
function lL(e, t) {
  (this.input = e),
    (this.filename = t.filename || null),
    (this.schema = t.schema || Sh),
    (this.onWarning = t.onWarning || null),
    (this.legacy = t.legacy || !1),
    (this.json = t.json || !1),
    (this.listener = t.listener || null),
    (this.implicitTypes = this.schema.compiledImplicit),
    (this.typeMap = this.schema.compiledTypeMap),
    (this.length = e.length),
    (this.position = 0),
    (this.line = 0),
    (this.lineStart = 0),
    (this.lineIndent = 0),
    (this.firstTabInLine = -1),
    (this.documents = []);
}
function Wy(e, t) {
  var n = {
    name: e.filename,
    buffer: e.input.slice(0, -1),
    position: e.position,
    line: e.line,
    column: e.position - e.lineStart,
  };
  return (n.snippet = dN(n)), new kt(t, n);
}
function le(e, t) {
  throw Wy(e, t);
}
function jl(e, t) {
  e.onWarning && e.onWarning.call(null, Wy(e, t));
}
var Bm = {
  YAML: function (t, n, r) {
    var i, o, s;
    t.version !== null && le(t, "duplication of %YAML directive"),
      r.length !== 1 && le(t, "YAML directive accepts exactly one argument"),
      (i = /^([0-9]+)\.([0-9]+)$/.exec(r[0])),
      i === null && le(t, "ill-formed argument of the YAML directive"),
      (o = parseInt(i[1], 10)),
      (s = parseInt(i[2], 10)),
      o !== 1 && le(t, "unacceptable YAML version of the document"),
      (t.version = r[0]),
      (t.checkLineBreaks = s < 2),
      s !== 1 && s !== 2 && jl(t, "unsupported YAML version of the document");
  },
  TAG: function (t, n, r) {
    var i, o;
    r.length !== 2 && le(t, "TAG directive accepts exactly two arguments"),
      (i = r[0]),
      (o = r[1]),
      Vy.test(i) || le(t, "ill-formed tag handle (first argument) of the TAG directive"),
      br.call(t.tagMap, i) && le(t, 'there is a previously declared suffix for "' + i + '" tag handle'),
      zy.test(o) || le(t, "ill-formed tag prefix (second argument) of the TAG directive");
    try {
      o = decodeURIComponent(o);
    } catch {
      le(t, "tag prefix is malformed: " + o);
    }
    t.tagMap[i] = o;
  },
};
function pr(e, t, n, r) {
  var i, o, s, l;
  if (t < n) {
    if (((l = e.input.slice(t, n)), r))
      for (i = 0, o = l.length; i < o; i += 1)
        (s = l.charCodeAt(i)), s === 9 || (32 <= s && s <= 1114111) || le(e, "expected valid JSON character");
    else eL.test(l) && le(e, "the stream contains non-printable characters");
    e.result += l;
  }
}
function Hm(e, t, n, r) {
  var i, o, s, l;
  for (
    ot.isObject(n) || le(e, "cannot merge mappings; the provided source object is unacceptable"),
      i = Object.keys(n),
      s = 0,
      l = i.length;
    s < l;
    s += 1
  )
    (o = i[s]), br.call(t, o) || ((t[o] = n[o]), (r[o] = !0));
}
function Ei(e, t, n, r, i, o, s, l, a) {
  var u, c;
  if (Array.isArray(i))
    for (i = Array.prototype.slice.call(i), u = 0, c = i.length; u < c; u += 1)
      Array.isArray(i[u]) && le(e, "nested arrays are not supported inside keys"),
        typeof i == "object" && Dm(i[u]) === "[object Object]" && (i[u] = "[object Object]");
  if (
    (typeof i == "object" && Dm(i) === "[object Object]" && (i = "[object Object]"),
    (i = String(i)),
    t === null && (t = {}),
    r === "tag:yaml.org,2002:merge")
  )
    if (Array.isArray(o)) for (u = 0, c = o.length; u < c; u += 1) Hm(e, t, o[u], n);
    else Hm(e, t, o, n);
  else
    !e.json &&
      !br.call(n, i) &&
      br.call(t, i) &&
      ((e.line = s || e.line),
      (e.lineStart = l || e.lineStart),
      (e.position = a || e.position),
      le(e, "duplicated mapping key")),
      i === "__proto__"
        ? Object.defineProperty(t, i, { configurable: !0, enumerable: !0, writable: !0, value: o })
        : (t[i] = o),
      delete n[i];
  return t;
}
function Th(e) {
  var t;
  (t = e.input.charCodeAt(e.position)),
    t === 10
      ? e.position++
      : t === 13
        ? (e.position++, e.input.charCodeAt(e.position) === 10 && e.position++)
        : le(e, "a line break is expected"),
    (e.line += 1),
    (e.lineStart = e.position),
    (e.firstTabInLine = -1);
}
function et(e, t, n) {
  for (var r = 0, i = e.input.charCodeAt(e.position); i !== 0; ) {
    for (; Vr(i); )
      i === 9 && e.firstTabInLine === -1 && (e.firstTabInLine = e.position), (i = e.input.charCodeAt(++e.position));
    if (t && i === 35)
      do i = e.input.charCodeAt(++e.position);
      while (i !== 10 && i !== 13 && i !== 0);
    if (Sn(i))
      for (Th(e), i = e.input.charCodeAt(e.position), r++, e.lineIndent = 0; i === 32; )
        e.lineIndent++, (i = e.input.charCodeAt(++e.position));
    else break;
  }
  return n !== -1 && r !== 0 && e.lineIndent < n && jl(e, "deficient indentation"), r;
}
function ja(e) {
  var t = e.position,
    n;
  return (
    (n = e.input.charCodeAt(t)),
    !!(
      (n === 45 || n === 46) &&
      n === e.input.charCodeAt(t + 1) &&
      n === e.input.charCodeAt(t + 2) &&
      ((t += 3), (n = e.input.charCodeAt(t)), n === 0 || Nt(n))
    )
  );
}
function Ah(e, t) {
  t === 1
    ? (e.result += " ")
    : t > 1 &&
      (e.result += ot.repeat(
        `
`,
        t - 1,
      ));
}
function aL(e, t, n) {
  var r,
    i,
    o,
    s,
    l,
    a,
    u,
    c,
    d = e.kind,
    f = e.result,
    h;
  if (
    ((h = e.input.charCodeAt(e.position)),
    Nt(h) ||
      wi(h) ||
      h === 35 ||
      h === 38 ||
      h === 42 ||
      h === 33 ||
      h === 124 ||
      h === 62 ||
      h === 39 ||
      h === 34 ||
      h === 37 ||
      h === 64 ||
      h === 96 ||
      ((h === 63 || h === 45) && ((i = e.input.charCodeAt(e.position + 1)), Nt(i) || (n && wi(i)))))
  )
    return !1;
  for (e.kind = "scalar", e.result = "", o = s = e.position, l = !1; h !== 0; ) {
    if (h === 58) {
      if (((i = e.input.charCodeAt(e.position + 1)), Nt(i) || (n && wi(i)))) break;
    } else if (h === 35) {
      if (((r = e.input.charCodeAt(e.position - 1)), Nt(r))) break;
    } else {
      if ((e.position === e.lineStart && ja(e)) || (n && wi(h))) break;
      if (Sn(h))
        if (((a = e.line), (u = e.lineStart), (c = e.lineIndent), et(e, !1, -1), e.lineIndent >= t)) {
          (l = !0), (h = e.input.charCodeAt(e.position));
          continue;
        } else {
          (e.position = s), (e.line = a), (e.lineStart = u), (e.lineIndent = c);
          break;
        }
    }
    l && (pr(e, o, s, !1), Ah(e, e.line - a), (o = s = e.position), (l = !1)),
      Vr(h) || (s = e.position + 1),
      (h = e.input.charCodeAt(++e.position));
  }
  return pr(e, o, s, !1), e.result ? !0 : ((e.kind = d), (e.result = f), !1);
}
function uL(e, t) {
  var n, r, i;
  if (((n = e.input.charCodeAt(e.position)), n !== 39)) return !1;
  for (e.kind = "scalar", e.result = "", e.position++, r = i = e.position; (n = e.input.charCodeAt(e.position)) !== 0; )
    if (n === 39)
      if ((pr(e, r, e.position, !0), (n = e.input.charCodeAt(++e.position)), n === 39))
        (r = e.position), e.position++, (i = e.position);
      else return !0;
    else
      Sn(n)
        ? (pr(e, r, i, !0), Ah(e, et(e, !1, t)), (r = i = e.position))
        : e.position === e.lineStart && ja(e)
          ? le(e, "unexpected end of the document within a single quoted scalar")
          : (e.position++, (i = e.position));
  le(e, "unexpected end of the stream within a single quoted scalar");
}
function cL(e, t) {
  var n, r, i, o, s, l;
  if (((l = e.input.charCodeAt(e.position)), l !== 34)) return !1;
  for (
    e.kind = "scalar", e.result = "", e.position++, n = r = e.position;
    (l = e.input.charCodeAt(e.position)) !== 0;

  ) {
    if (l === 34) return pr(e, n, e.position, !0), e.position++, !0;
    if (l === 92) {
      if ((pr(e, n, e.position, !0), (l = e.input.charCodeAt(++e.position)), Sn(l))) et(e, !1, t);
      else if (l < 256 && jy[l]) (e.result += Uy[l]), e.position++;
      else if ((s = iL(l)) > 0) {
        for (i = s, o = 0; i > 0; i--)
          (l = e.input.charCodeAt(++e.position)),
            (s = rL(l)) >= 0 ? (o = (o << 4) + s) : le(e, "expected hexadecimal character");
        (e.result += sL(o)), e.position++;
      } else le(e, "unknown escape sequence");
      n = r = e.position;
    } else
      Sn(l)
        ? (pr(e, n, r, !0), Ah(e, et(e, !1, t)), (n = r = e.position))
        : e.position === e.lineStart && ja(e)
          ? le(e, "unexpected end of the document within a double quoted scalar")
          : (e.position++, (r = e.position));
  }
  le(e, "unexpected end of the stream within a double quoted scalar");
}
function dL(e, t) {
  var n = !0,
    r,
    i,
    o,
    s = e.tag,
    l,
    a = e.anchor,
    u,
    c,
    d,
    f,
    h,
    p = Object.create(null),
    g,
    x,
    b,
    m;
  if (((m = e.input.charCodeAt(e.position)), m === 91)) (c = 93), (h = !1), (l = []);
  else if (m === 123) (c = 125), (h = !0), (l = {});
  else return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = l), m = e.input.charCodeAt(++e.position); m !== 0; ) {
    if ((et(e, !0, t), (m = e.input.charCodeAt(e.position)), m === c))
      return e.position++, (e.tag = s), (e.anchor = a), (e.kind = h ? "mapping" : "sequence"), (e.result = l), !0;
    n
      ? m === 44 && le(e, "expected the node content, but found ','")
      : le(e, "missed comma between flow collection entries"),
      (x = g = b = null),
      (d = f = !1),
      m === 63 && ((u = e.input.charCodeAt(e.position + 1)), Nt(u) && ((d = f = !0), e.position++, et(e, !0, t))),
      (r = e.line),
      (i = e.lineStart),
      (o = e.position),
      Ki(e, t, Vl, !1, !0),
      (x = e.tag),
      (g = e.result),
      et(e, !0, t),
      (m = e.input.charCodeAt(e.position)),
      (f || e.line === r) &&
        m === 58 &&
        ((d = !0), (m = e.input.charCodeAt(++e.position)), et(e, !0, t), Ki(e, t, Vl, !1, !0), (b = e.result)),
      h ? Ei(e, l, p, x, g, b, r, i, o) : d ? l.push(Ei(e, null, p, x, g, b, r, i, o)) : l.push(g),
      et(e, !0, t),
      (m = e.input.charCodeAt(e.position)),
      m === 44 ? ((n = !0), (m = e.input.charCodeAt(++e.position))) : (n = !1);
  }
  le(e, "unexpected end of the stream within a flow collection");
}
function fL(e, t) {
  var n,
    r,
    i = Ru,
    o = !1,
    s = !1,
    l = t,
    a = 0,
    u = !1,
    c,
    d;
  if (((d = e.input.charCodeAt(e.position)), d === 124)) r = !1;
  else if (d === 62) r = !0;
  else return !1;
  for (e.kind = "scalar", e.result = ""; d !== 0; )
    if (((d = e.input.charCodeAt(++e.position)), d === 43 || d === 45))
      Ru === i ? (i = d === 43 ? Pm : QN) : le(e, "repeat of a chomping mode identifier");
    else if ((c = oL(d)) >= 0)
      c === 0
        ? le(e, "bad explicit indentation width of a block scalar; it cannot be less than one")
        : s
          ? le(e, "repeat of an indentation width identifier")
          : ((l = t + c - 1), (s = !0));
    else break;
  if (Vr(d)) {
    do d = e.input.charCodeAt(++e.position);
    while (Vr(d));
    if (d === 35)
      do d = e.input.charCodeAt(++e.position);
      while (!Sn(d) && d !== 0);
  }
  for (; d !== 0; ) {
    for (Th(e), e.lineIndent = 0, d = e.input.charCodeAt(e.position); (!s || e.lineIndent < l) && d === 32; )
      e.lineIndent++, (d = e.input.charCodeAt(++e.position));
    if ((!s && e.lineIndent > l && (l = e.lineIndent), Sn(d))) {
      a++;
      continue;
    }
    if (e.lineIndent < l) {
      i === Pm
        ? (e.result += ot.repeat(
            `
`,
            o ? 1 + a : a,
          ))
        : i === Ru &&
          o &&
          (e.result += `
`);
      break;
    }
    for (
      r
        ? Vr(d)
          ? ((u = !0),
            (e.result += ot.repeat(
              `
`,
              o ? 1 + a : a,
            )))
          : u
            ? ((u = !1),
              (e.result += ot.repeat(
                `
`,
                a + 1,
              )))
            : a === 0
              ? o && (e.result += " ")
              : (e.result += ot.repeat(
                  `
`,
                  a,
                ))
        : (e.result += ot.repeat(
            `
`,
            o ? 1 + a : a,
          )),
        o = !0,
        s = !0,
        a = 0,
        n = e.position;
      !Sn(d) && d !== 0;

    )
      d = e.input.charCodeAt(++e.position);
    pr(e, n, e.position, !1);
  }
  return !0;
}
function Vm(e, t) {
  var n,
    r = e.tag,
    i = e.anchor,
    o = [],
    s,
    l = !1,
    a;
  if (e.firstTabInLine !== -1) return !1;
  for (
    e.anchor !== null && (e.anchorMap[e.anchor] = o), a = e.input.charCodeAt(e.position);
    a !== 0 &&
    (e.firstTabInLine !== -1 &&
      ((e.position = e.firstTabInLine), le(e, "tab characters must not be used in indentation")),
    !(a !== 45 || ((s = e.input.charCodeAt(e.position + 1)), !Nt(s))));

  ) {
    if (((l = !0), e.position++, et(e, !0, -1) && e.lineIndent <= t)) {
      o.push(null), (a = e.input.charCodeAt(e.position));
      continue;
    }
    if (
      ((n = e.line),
      Ki(e, t, Hy, !1, !0),
      o.push(e.result),
      et(e, !0, -1),
      (a = e.input.charCodeAt(e.position)),
      (e.line === n || e.lineIndent > t) && a !== 0)
    )
      le(e, "bad indentation of a sequence entry");
    else if (e.lineIndent < t) break;
  }
  return l ? ((e.tag = r), (e.anchor = i), (e.kind = "sequence"), (e.result = o), !0) : !1;
}
function hL(e, t, n) {
  var r,
    i,
    o,
    s,
    l,
    a,
    u = e.tag,
    c = e.anchor,
    d = {},
    f = Object.create(null),
    h = null,
    p = null,
    g = null,
    x = !1,
    b = !1,
    m;
  if (e.firstTabInLine !== -1) return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = d), m = e.input.charCodeAt(e.position); m !== 0; ) {
    if (
      (!x &&
        e.firstTabInLine !== -1 &&
        ((e.position = e.firstTabInLine), le(e, "tab characters must not be used in indentation")),
      (r = e.input.charCodeAt(e.position + 1)),
      (o = e.line),
      (m === 63 || m === 58) && Nt(r))
    )
      m === 63
        ? (x && (Ei(e, d, f, h, p, null, s, l, a), (h = p = g = null)), (b = !0), (x = !0), (i = !0))
        : x
          ? ((x = !1), (i = !0))
          : le(e, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"),
        (e.position += 1),
        (m = r);
    else {
      if (((s = e.line), (l = e.lineStart), (a = e.position), !Ki(e, n, By, !1, !0))) break;
      if (e.line === o) {
        for (m = e.input.charCodeAt(e.position); Vr(m); ) m = e.input.charCodeAt(++e.position);
        if (m === 58)
          (m = e.input.charCodeAt(++e.position)),
            Nt(m) || le(e, "a whitespace character is expected after the key-value separator within a block mapping"),
            x && (Ei(e, d, f, h, p, null, s, l, a), (h = p = g = null)),
            (b = !0),
            (x = !1),
            (i = !1),
            (h = e.tag),
            (p = e.result);
        else if (b) le(e, "can not read an implicit mapping pair; a colon is missed");
        else return (e.tag = u), (e.anchor = c), !0;
      } else if (b) le(e, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else return (e.tag = u), (e.anchor = c), !0;
    }
    if (
      ((e.line === o || e.lineIndent > t) &&
        (x && ((s = e.line), (l = e.lineStart), (a = e.position)),
        Ki(e, t, zl, !0, i) && (x ? (p = e.result) : (g = e.result)),
        x || (Ei(e, d, f, h, p, g, s, l, a), (h = p = g = null)),
        et(e, !0, -1),
        (m = e.input.charCodeAt(e.position))),
      (e.line === o || e.lineIndent > t) && m !== 0)
    )
      le(e, "bad indentation of a mapping entry");
    else if (e.lineIndent < t) break;
  }
  return (
    x && Ei(e, d, f, h, p, null, s, l, a), b && ((e.tag = u), (e.anchor = c), (e.kind = "mapping"), (e.result = d)), b
  );
}
function pL(e) {
  var t,
    n = !1,
    r = !1,
    i,
    o,
    s;
  if (((s = e.input.charCodeAt(e.position)), s !== 33)) return !1;
  if (
    (e.tag !== null && le(e, "duplication of a tag property"),
    (s = e.input.charCodeAt(++e.position)),
    s === 60
      ? ((n = !0), (s = e.input.charCodeAt(++e.position)))
      : s === 33
        ? ((r = !0), (i = "!!"), (s = e.input.charCodeAt(++e.position)))
        : (i = "!"),
    (t = e.position),
    n)
  ) {
    do s = e.input.charCodeAt(++e.position);
    while (s !== 0 && s !== 62);
    e.position < e.length
      ? ((o = e.input.slice(t, e.position)), (s = e.input.charCodeAt(++e.position)))
      : le(e, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; s !== 0 && !Nt(s); )
      s === 33 &&
        (r
          ? le(e, "tag suffix cannot contain exclamation marks")
          : ((i = e.input.slice(t - 1, e.position + 1)),
            Vy.test(i) || le(e, "named tag handle cannot contain such characters"),
            (r = !0),
            (t = e.position + 1))),
        (s = e.input.charCodeAt(++e.position));
    (o = e.input.slice(t, e.position)), nL.test(o) && le(e, "tag suffix cannot contain flow indicator characters");
  }
  o && !zy.test(o) && le(e, "tag name cannot contain such characters: " + o);
  try {
    o = decodeURIComponent(o);
  } catch {
    le(e, "tag name is malformed: " + o);
  }
  return (
    n
      ? (e.tag = o)
      : br.call(e.tagMap, i)
        ? (e.tag = e.tagMap[i] + o)
        : i === "!"
          ? (e.tag = "!" + o)
          : i === "!!"
            ? (e.tag = "tag:yaml.org,2002:" + o)
            : le(e, 'undeclared tag handle "' + i + '"'),
    !0
  );
}
function gL(e) {
  var t, n;
  if (((n = e.input.charCodeAt(e.position)), n !== 38)) return !1;
  for (
    e.anchor !== null && le(e, "duplication of an anchor property"),
      n = e.input.charCodeAt(++e.position),
      t = e.position;
    n !== 0 && !Nt(n) && !wi(n);

  )
    n = e.input.charCodeAt(++e.position);
  return (
    e.position === t && le(e, "name of an anchor node must contain at least one character"),
    (e.anchor = e.input.slice(t, e.position)),
    !0
  );
}
function mL(e) {
  var t, n, r;
  if (((r = e.input.charCodeAt(e.position)), r !== 42)) return !1;
  for (r = e.input.charCodeAt(++e.position), t = e.position; r !== 0 && !Nt(r) && !wi(r); )
    r = e.input.charCodeAt(++e.position);
  return (
    e.position === t && le(e, "name of an alias node must contain at least one character"),
    (n = e.input.slice(t, e.position)),
    br.call(e.anchorMap, n) || le(e, 'unidentified alias "' + n + '"'),
    (e.result = e.anchorMap[n]),
    et(e, !0, -1),
    !0
  );
}
function Ki(e, t, n, r, i) {
  var o,
    s,
    l,
    a = 1,
    u = !1,
    c = !1,
    d,
    f,
    h,
    p,
    g,
    x;
  if (
    (e.listener !== null && e.listener("open", e),
    (e.tag = null),
    (e.anchor = null),
    (e.kind = null),
    (e.result = null),
    (o = s = l = zl === n || Hy === n),
    r &&
      et(e, !0, -1) &&
      ((u = !0), e.lineIndent > t ? (a = 1) : e.lineIndent === t ? (a = 0) : e.lineIndent < t && (a = -1)),
    a === 1)
  )
    for (; pL(e) || gL(e); )
      et(e, !0, -1)
        ? ((u = !0), (l = o), e.lineIndent > t ? (a = 1) : e.lineIndent === t ? (a = 0) : e.lineIndent < t && (a = -1))
        : (l = !1);
  if (
    (l && (l = u || i),
    (a === 1 || zl === n) &&
      (Vl === n || By === n ? (g = t) : (g = t + 1),
      (x = e.position - e.lineStart),
      a === 1
        ? (l && (Vm(e, x) || hL(e, x, g))) || dL(e, g)
          ? (c = !0)
          : ((s && fL(e, g)) || uL(e, g) || cL(e, g)
              ? (c = !0)
              : mL(e)
                ? ((c = !0),
                  (e.tag !== null || e.anchor !== null) && le(e, "alias node should not have any properties"))
                : aL(e, g, Vl === n) && ((c = !0), e.tag === null && (e.tag = "?")),
            e.anchor !== null && (e.anchorMap[e.anchor] = e.result))
        : a === 0 && (c = l && Vm(e, x))),
    e.tag === null)
  )
    e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
  else if (e.tag === "?") {
    for (
      e.result !== null &&
        e.kind !== "scalar" &&
        le(e, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + e.kind + '"'),
        d = 0,
        f = e.implicitTypes.length;
      d < f;
      d += 1
    )
      if (((p = e.implicitTypes[d]), p.resolve(e.result))) {
        (e.result = p.construct(e.result)), (e.tag = p.tag), e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
        break;
      }
  } else if (e.tag !== "!") {
    if (br.call(e.typeMap[e.kind || "fallback"], e.tag)) p = e.typeMap[e.kind || "fallback"][e.tag];
    else
      for (p = null, h = e.typeMap.multi[e.kind || "fallback"], d = 0, f = h.length; d < f; d += 1)
        if (e.tag.slice(0, h[d].tag.length) === h[d].tag) {
          p = h[d];
          break;
        }
    p || le(e, "unknown tag !<" + e.tag + ">"),
      e.result !== null &&
        p.kind !== e.kind &&
        le(e, "unacceptable node kind for !<" + e.tag + '> tag; it should be "' + p.kind + '", not "' + e.kind + '"'),
      p.resolve(e.result, e.tag)
        ? ((e.result = p.construct(e.result, e.tag)), e.anchor !== null && (e.anchorMap[e.anchor] = e.result))
        : le(e, "cannot resolve a node with !<" + e.tag + "> explicit tag");
  }
  return e.listener !== null && e.listener("close", e), e.tag !== null || e.anchor !== null || c;
}
function xL(e) {
  var t = e.position,
    n,
    r,
    i,
    o = !1,
    s;
  for (
    e.version = null, e.checkLineBreaks = e.legacy, e.tagMap = Object.create(null), e.anchorMap = Object.create(null);
    (s = e.input.charCodeAt(e.position)) !== 0 &&
    (et(e, !0, -1), (s = e.input.charCodeAt(e.position)), !(e.lineIndent > 0 || s !== 37));

  ) {
    for (o = !0, s = e.input.charCodeAt(++e.position), n = e.position; s !== 0 && !Nt(s); )
      s = e.input.charCodeAt(++e.position);
    for (
      r = e.input.slice(n, e.position),
        i = [],
        r.length < 1 && le(e, "directive name must not be less than one character in length");
      s !== 0;

    ) {
      for (; Vr(s); ) s = e.input.charCodeAt(++e.position);
      if (s === 35) {
        do s = e.input.charCodeAt(++e.position);
        while (s !== 0 && !Sn(s));
        break;
      }
      if (Sn(s)) break;
      for (n = e.position; s !== 0 && !Nt(s); ) s = e.input.charCodeAt(++e.position);
      i.push(e.input.slice(n, e.position));
    }
    s !== 0 && Th(e), br.call(Bm, r) ? Bm[r](e, r, i) : jl(e, 'unknown document directive "' + r + '"');
  }
  if (
    (et(e, !0, -1),
    e.lineIndent === 0 &&
    e.input.charCodeAt(e.position) === 45 &&
    e.input.charCodeAt(e.position + 1) === 45 &&
    e.input.charCodeAt(e.position + 2) === 45
      ? ((e.position += 3), et(e, !0, -1))
      : o && le(e, "directives end mark is expected"),
    Ki(e, e.lineIndent - 1, zl, !1, !0),
    et(e, !0, -1),
    e.checkLineBreaks &&
      tL.test(e.input.slice(t, e.position)) &&
      jl(e, "non-ASCII line breaks are interpreted as content"),
    e.documents.push(e.result),
    e.position === e.lineStart && ja(e))
  ) {
    e.input.charCodeAt(e.position) === 46 && ((e.position += 3), et(e, !0, -1));
    return;
  }
  if (e.position < e.length - 1) le(e, "end of the stream or a document separator is expected");
  else return;
}
function Ky(e, t) {
  (e = String(e)),
    (t = t || {}),
    e.length !== 0 &&
      (e.charCodeAt(e.length - 1) !== 10 &&
        e.charCodeAt(e.length - 1) !== 13 &&
        (e += `
`),
      e.charCodeAt(0) === 65279 && (e = e.slice(1)));
  var n = new lL(e, t),
    r = e.indexOf("\0");
  for (
    r !== -1 && ((n.position = r), le(n, "null byte is not allowed in input")), n.input += "\0";
    n.input.charCodeAt(n.position) === 32;

  )
    (n.lineIndent += 1), (n.position += 1);
  for (; n.position < n.length - 1; ) xL(n);
  return n.documents;
}
function vL(e, t, n) {
  t !== null && typeof t == "object" && typeof n > "u" && ((n = t), (t = null));
  var r = Ky(e, n);
  if (typeof t != "function") return r;
  for (var i = 0, o = r.length; i < o; i += 1) t(r[i]);
}
function bL(e, t) {
  var n = Ky(e, t);
  if (n.length !== 0) {
    if (n.length === 1) return n[0];
    throw new kt("expected a single document in the stream, but found more");
  }
}
var yL = vL,
  CL = bL,
  Jy = { loadAll: yL, load: CL },
  Gy = Object.prototype.toString,
  Zy = Object.prototype.hasOwnProperty,
  Ih = 65279,
  _L = 9,
  es = 10,
  wL = 13,
  EL = 32,
  kL = 33,
  SL = 34,
  ud = 35,
  TL = 37,
  AL = 38,
  IL = 39,
  NL = 42,
  qy = 44,
  LL = 45,
  Ul = 58,
  ML = 61,
  OL = 62,
  FL = 63,
  RL = 64,
  Yy = 91,
  Xy = 93,
  PL = 96,
  Qy = 123,
  DL = 124,
  e2 = 125,
  Ct = {};
Ct[0] = "\\0";
Ct[7] = "\\a";
Ct[8] = "\\b";
Ct[9] = "\\t";
Ct[10] = "\\n";
Ct[11] = "\\v";
Ct[12] = "\\f";
Ct[13] = "\\r";
Ct[27] = "\\e";
Ct[34] = '\\"';
Ct[92] = "\\\\";
Ct[133] = "\\N";
Ct[160] = "\\_";
Ct[8232] = "\\L";
Ct[8233] = "\\P";
var $L = ["y", "Y", "yes", "Yes", "YES", "on", "On", "ON", "n", "N", "no", "No", "NO", "off", "Off", "OFF"],
  BL = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function HL(e, t) {
  var n, r, i, o, s, l, a;
  if (t === null) return {};
  for (n = {}, r = Object.keys(t), i = 0, o = r.length; i < o; i += 1)
    (s = r[i]),
      (l = String(t[s])),
      s.slice(0, 2) === "!!" && (s = "tag:yaml.org,2002:" + s.slice(2)),
      (a = e.compiledTypeMap.fallback[s]),
      a && Zy.call(a.styleAliases, l) && (l = a.styleAliases[l]),
      (n[s] = l);
  return n;
}
function VL(e) {
  var t, n, r;
  if (((t = e.toString(16).toUpperCase()), e <= 255)) (n = "x"), (r = 2);
  else if (e <= 65535) (n = "u"), (r = 4);
  else if (e <= 4294967295) (n = "U"), (r = 8);
  else throw new kt("code point within a string may not be greater than 0xFFFFFFFF");
  return "\\" + n + ot.repeat("0", r - t.length) + t;
}
var zL = 1,
  ts = 2;
function jL(e) {
  (this.schema = e.schema || Sh),
    (this.indent = Math.max(1, e.indent || 2)),
    (this.noArrayIndent = e.noArrayIndent || !1),
    (this.skipInvalid = e.skipInvalid || !1),
    (this.flowLevel = ot.isNothing(e.flowLevel) ? -1 : e.flowLevel),
    (this.styleMap = HL(this.schema, e.styles || null)),
    (this.sortKeys = e.sortKeys || !1),
    (this.lineWidth = e.lineWidth || 80),
    (this.noRefs = e.noRefs || !1),
    (this.noCompatMode = e.noCompatMode || !1),
    (this.condenseFlow = e.condenseFlow || !1),
    (this.quotingType = e.quotingType === '"' ? ts : zL),
    (this.forceQuotes = e.forceQuotes || !1),
    (this.replacer = typeof e.replacer == "function" ? e.replacer : null),
    (this.implicitTypes = this.schema.compiledImplicit),
    (this.explicitTypes = this.schema.compiledExplicit),
    (this.tag = null),
    (this.result = ""),
    (this.duplicates = []),
    (this.usedDuplicates = null);
}
function zm(e, t) {
  for (var n = ot.repeat(" ", t), r = 0, i = -1, o = "", s, l = e.length; r < l; )
    (i = e.indexOf(
      `
`,
      r,
    )),
      i === -1 ? ((s = e.slice(r)), (r = l)) : ((s = e.slice(r, i + 1)), (r = i + 1)),
      s.length &&
        s !==
          `
` &&
        (o += n),
      (o += s);
  return o;
}
function cd(e, t) {
  return (
    `
` + ot.repeat(" ", e.indent * t)
  );
}
function UL(e, t) {
  var n, r, i;
  for (n = 0, r = e.implicitTypes.length; n < r; n += 1) if (((i = e.implicitTypes[n]), i.resolve(t))) return !0;
  return !1;
}
function Wl(e) {
  return e === EL || e === _L;
}
function ns(e) {
  return (
    (32 <= e && e <= 126) ||
    (161 <= e && e <= 55295 && e !== 8232 && e !== 8233) ||
    (57344 <= e && e <= 65533 && e !== Ih) ||
    (65536 <= e && e <= 1114111)
  );
}
function jm(e) {
  return ns(e) && e !== Ih && e !== wL && e !== es;
}
function Um(e, t, n) {
  var r = jm(e),
    i = r && !Wl(e);
  return (
    ((n ? r : r && e !== qy && e !== Yy && e !== Xy && e !== Qy && e !== e2) && e !== ud && !(t === Ul && !i)) ||
    (jm(t) && !Wl(t) && e === ud) ||
    (t === Ul && i)
  );
}
function WL(e) {
  return (
    ns(e) &&
    e !== Ih &&
    !Wl(e) &&
    e !== LL &&
    e !== FL &&
    e !== Ul &&
    e !== qy &&
    e !== Yy &&
    e !== Xy &&
    e !== Qy &&
    e !== e2 &&
    e !== ud &&
    e !== AL &&
    e !== NL &&
    e !== kL &&
    e !== DL &&
    e !== ML &&
    e !== OL &&
    e !== IL &&
    e !== SL &&
    e !== TL &&
    e !== RL &&
    e !== PL
  );
}
function KL(e) {
  return !Wl(e) && e !== Ul;
}
function wo(e, t) {
  var n = e.charCodeAt(t),
    r;
  return n >= 55296 && n <= 56319 && t + 1 < e.length && ((r = e.charCodeAt(t + 1)), r >= 56320 && r <= 57343)
    ? (n - 55296) * 1024 + r - 56320 + 65536
    : n;
}
function t2(e) {
  var t = /^\n* /;
  return t.test(e);
}
var n2 = 1,
  dd = 2,
  r2 = 3,
  i2 = 4,
  yi = 5;
function JL(e, t, n, r, i, o, s, l) {
  var a,
    u = 0,
    c = null,
    d = !1,
    f = !1,
    h = r !== -1,
    p = -1,
    g = WL(wo(e, 0)) && KL(wo(e, e.length - 1));
  if (t || s)
    for (a = 0; a < e.length; u >= 65536 ? (a += 2) : a++) {
      if (((u = wo(e, a)), !ns(u))) return yi;
      (g = g && Um(u, c, l)), (c = u);
    }
  else {
    for (a = 0; a < e.length; u >= 65536 ? (a += 2) : a++) {
      if (((u = wo(e, a)), u === es)) (d = !0), h && ((f = f || (a - p - 1 > r && e[p + 1] !== " ")), (p = a));
      else if (!ns(u)) return yi;
      (g = g && Um(u, c, l)), (c = u);
    }
    f = f || (h && a - p - 1 > r && e[p + 1] !== " ");
  }
  return !d && !f
    ? g && !s && !i(e)
      ? n2
      : o === ts
        ? yi
        : dd
    : n > 9 && t2(e)
      ? yi
      : s
        ? o === ts
          ? yi
          : dd
        : f
          ? i2
          : r2;
}
function GL(e, t, n, r, i) {
  e.dump = (function () {
    if (t.length === 0) return e.quotingType === ts ? '""' : "''";
    if (!e.noCompatMode && ($L.indexOf(t) !== -1 || BL.test(t)))
      return e.quotingType === ts ? '"' + t + '"' : "'" + t + "'";
    var o = e.indent * Math.max(1, n),
      s = e.lineWidth === -1 ? -1 : Math.max(Math.min(e.lineWidth, 40), e.lineWidth - o),
      l = r || (e.flowLevel > -1 && n >= e.flowLevel);
    function a(u) {
      return UL(e, u);
    }
    switch (JL(t, l, e.indent, s, a, e.quotingType, e.forceQuotes && !r, i)) {
      case n2:
        return t;
      case dd:
        return "'" + t.replace(/'/g, "''") + "'";
      case r2:
        return "|" + Wm(t, e.indent) + Km(zm(t, o));
      case i2:
        return ">" + Wm(t, e.indent) + Km(zm(ZL(t, s), o));
      case yi:
        return '"' + qL(t) + '"';
      default:
        throw new kt("impossible error: invalid scalar style");
    }
  })();
}
function Wm(e, t) {
  var n = t2(e) ? String(t) : "",
    r =
      e[e.length - 1] ===
      `
`,
    i =
      r &&
      (e[e.length - 2] ===
        `
` ||
        e ===
          `
`),
    o = i ? "+" : r ? "" : "-";
  return (
    n +
    o +
    `
`
  );
}
function Km(e) {
  return e[e.length - 1] ===
    `
`
    ? e.slice(0, -1)
    : e;
}
function ZL(e, t) {
  for (
    var n = /(\n+)([^\n]*)/g,
      r = (function () {
        var u = e.indexOf(`
`);
        return (u = u !== -1 ? u : e.length), (n.lastIndex = u), Jm(e.slice(0, u), t);
      })(),
      i =
        e[0] ===
          `
` || e[0] === " ",
      o,
      s;
    (s = n.exec(e));

  ) {
    var l = s[1],
      a = s[2];
    (o = a[0] === " "),
      (r +=
        l +
        (!i && !o && a !== ""
          ? `
`
          : "") +
        Jm(a, t)),
      (i = o);
  }
  return r;
}
function Jm(e, t) {
  if (e === "" || e[0] === " ") return e;
  for (var n = / [^ ]/g, r, i = 0, o, s = 0, l = 0, a = ""; (r = n.exec(e)); )
    (l = r.index),
      l - i > t &&
        ((o = s > i ? s : l),
        (a +=
          `
` + e.slice(i, o)),
        (i = o + 1)),
      (s = l);
  return (
    (a += `
`),
    e.length - i > t && s > i
      ? (a +=
          e.slice(i, s) +
          `
` +
          e.slice(s + 1))
      : (a += e.slice(i)),
    a.slice(1)
  );
}
function qL(e) {
  for (var t = "", n = 0, r, i = 0; i < e.length; n >= 65536 ? (i += 2) : i++)
    (n = wo(e, i)), (r = Ct[n]), !r && ns(n) ? ((t += e[i]), n >= 65536 && (t += e[i + 1])) : (t += r || VL(n));
  return t;
}
function YL(e, t, n) {
  var r = "",
    i = e.tag,
    o,
    s,
    l;
  for (o = 0, s = n.length; o < s; o += 1)
    (l = n[o]),
      e.replacer && (l = e.replacer.call(n, String(o), l)),
      (er(e, t, l, !1, !1) || (typeof l > "u" && er(e, t, null, !1, !1))) &&
        (r !== "" && (r += "," + (e.condenseFlow ? "" : " ")), (r += e.dump));
  (e.tag = i), (e.dump = "[" + r + "]");
}
function Gm(e, t, n, r) {
  var i = "",
    o = e.tag,
    s,
    l,
    a;
  for (s = 0, l = n.length; s < l; s += 1)
    (a = n[s]),
      e.replacer && (a = e.replacer.call(n, String(s), a)),
      (er(e, t + 1, a, !0, !0, !1, !0) || (typeof a > "u" && er(e, t + 1, null, !0, !0, !1, !0))) &&
        ((!r || i !== "") && (i += cd(e, t)),
        e.dump && es === e.dump.charCodeAt(0) ? (i += "-") : (i += "- "),
        (i += e.dump));
  (e.tag = o), (e.dump = i || "[]");
}
function XL(e, t, n) {
  var r = "",
    i = e.tag,
    o = Object.keys(n),
    s,
    l,
    a,
    u,
    c;
  for (s = 0, l = o.length; s < l; s += 1)
    (c = ""),
      r !== "" && (c += ", "),
      e.condenseFlow && (c += '"'),
      (a = o[s]),
      (u = n[a]),
      e.replacer && (u = e.replacer.call(n, a, u)),
      er(e, t, a, !1, !1) &&
        (e.dump.length > 1024 && (c += "? "),
        (c += e.dump + (e.condenseFlow ? '"' : "") + ":" + (e.condenseFlow ? "" : " ")),
        er(e, t, u, !1, !1) && ((c += e.dump), (r += c)));
  (e.tag = i), (e.dump = "{" + r + "}");
}
function QL(e, t, n, r) {
  var i = "",
    o = e.tag,
    s = Object.keys(n),
    l,
    a,
    u,
    c,
    d,
    f;
  if (e.sortKeys === !0) s.sort();
  else if (typeof e.sortKeys == "function") s.sort(e.sortKeys);
  else if (e.sortKeys) throw new kt("sortKeys must be a boolean or a function");
  for (l = 0, a = s.length; l < a; l += 1)
    (f = ""),
      (!r || i !== "") && (f += cd(e, t)),
      (u = s[l]),
      (c = n[u]),
      e.replacer && (c = e.replacer.call(n, u, c)),
      er(e, t + 1, u, !0, !0, !0) &&
        ((d = (e.tag !== null && e.tag !== "?") || (e.dump && e.dump.length > 1024)),
        d && (e.dump && es === e.dump.charCodeAt(0) ? (f += "?") : (f += "? ")),
        (f += e.dump),
        d && (f += cd(e, t)),
        er(e, t + 1, c, !0, d) &&
          (e.dump && es === e.dump.charCodeAt(0) ? (f += ":") : (f += ": "), (f += e.dump), (i += f)));
  (e.tag = o), (e.dump = i || "{}");
}
function Zm(e, t, n) {
  var r, i, o, s, l, a;
  for (i = n ? e.explicitTypes : e.implicitTypes, o = 0, s = i.length; o < s; o += 1)
    if (
      ((l = i[o]),
      (l.instanceOf || l.predicate) &&
        (!l.instanceOf || (typeof t == "object" && t instanceof l.instanceOf)) &&
        (!l.predicate || l.predicate(t)))
    ) {
      if (
        (n ? (l.multi && l.representName ? (e.tag = l.representName(t)) : (e.tag = l.tag)) : (e.tag = "?"), l.represent)
      ) {
        if (((a = e.styleMap[l.tag] || l.defaultStyle), Gy.call(l.represent) === "[object Function]"))
          r = l.represent(t, a);
        else if (Zy.call(l.represent, a)) r = l.represent[a](t, a);
        else throw new kt("!<" + l.tag + '> tag resolver accepts not "' + a + '" style');
        e.dump = r;
      }
      return !0;
    }
  return !1;
}
function er(e, t, n, r, i, o, s) {
  (e.tag = null), (e.dump = n), Zm(e, n, !1) || Zm(e, n, !0);
  var l = Gy.call(e.dump),
    a = r,
    u;
  r && (r = e.flowLevel < 0 || e.flowLevel > t);
  var c = l === "[object Object]" || l === "[object Array]",
    d,
    f;
  if (
    (c && ((d = e.duplicates.indexOf(n)), (f = d !== -1)),
    ((e.tag !== null && e.tag !== "?") || f || (e.indent !== 2 && t > 0)) && (i = !1),
    f && e.usedDuplicates[d])
  )
    e.dump = "*ref_" + d;
  else {
    if ((c && f && !e.usedDuplicates[d] && (e.usedDuplicates[d] = !0), l === "[object Object]"))
      r && Object.keys(e.dump).length !== 0
        ? (QL(e, t, e.dump, i), f && (e.dump = "&ref_" + d + e.dump))
        : (XL(e, t, e.dump), f && (e.dump = "&ref_" + d + " " + e.dump));
    else if (l === "[object Array]")
      r && e.dump.length !== 0
        ? (e.noArrayIndent && !s && t > 0 ? Gm(e, t - 1, e.dump, i) : Gm(e, t, e.dump, i),
          f && (e.dump = "&ref_" + d + e.dump))
        : (YL(e, t, e.dump), f && (e.dump = "&ref_" + d + " " + e.dump));
    else if (l === "[object String]") e.tag !== "?" && GL(e, e.dump, t, o, a);
    else {
      if (l === "[object Undefined]") return !1;
      if (e.skipInvalid) return !1;
      throw new kt("unacceptable kind of an object to dump " + l);
    }
    e.tag !== null &&
      e.tag !== "?" &&
      ((u = encodeURI(e.tag[0] === "!" ? e.tag.slice(1) : e.tag).replace(/!/g, "%21")),
      e.tag[0] === "!"
        ? (u = "!" + u)
        : u.slice(0, 18) === "tag:yaml.org,2002:"
          ? (u = "!!" + u.slice(18))
          : (u = "!<" + u + ">"),
      (e.dump = u + " " + e.dump));
  }
  return !0;
}
function eM(e, t) {
  var n = [],
    r = [],
    i,
    o;
  for (fd(e, n, r), i = 0, o = r.length; i < o; i += 1) t.duplicates.push(n[r[i]]);
  t.usedDuplicates = new Array(o);
}
function fd(e, t, n) {
  var r, i, o;
  if (e !== null && typeof e == "object")
    if (((i = t.indexOf(e)), i !== -1)) n.indexOf(i) === -1 && n.push(i);
    else if ((t.push(e), Array.isArray(e))) for (i = 0, o = e.length; i < o; i += 1) fd(e[i], t, n);
    else for (r = Object.keys(e), i = 0, o = r.length; i < o; i += 1) fd(e[r[i]], t, n);
}
function tM(e, t) {
  t = t || {};
  var n = new jL(t);
  n.noRefs || eM(e, n);
  var r = e;
  return (
    n.replacer && (r = n.replacer.call({ "": r }, "", r)),
    er(n, 0, r, !0, !0)
      ? n.dump +
        `
`
      : ""
  );
}
var nM = tM,
  rM = { dump: nM };
function Nh(e, t) {
  return function () {
    throw new Error(
      "Function yaml." + e + " is removed in js-yaml 4. Use yaml." + t + " instead, which is now safe by default.",
    );
  };
}
var iM = ht,
  oM = yy,
  sM = Ey,
  lM = Iy,
  aM = Ny,
  uM = Sh,
  cM = Jy.load,
  dM = Jy.loadAll,
  fM = rM.dump,
  hM = kt,
  pM = {
    binary: Ry,
    float: Ay,
    map: wy,
    null: ky,
    pairs: Dy,
    set: $y,
    timestamp: Oy,
    bool: Sy,
    int: Ty,
    merge: Fy,
    omap: Py,
    seq: _y,
    str: Cy,
  },
  gM = Nh("safeLoad", "load"),
  mM = Nh("safeLoadAll", "loadAll"),
  xM = Nh("safeDump", "dump"),
  qm = {
    Type: iM,
    Schema: oM,
    FAILSAFE_SCHEMA: sM,
    JSON_SCHEMA: lM,
    CORE_SCHEMA: aM,
    DEFAULT_SCHEMA: uM,
    load: cM,
    loadAll: dM,
    dump: fM,
    YAMLException: hM,
    types: pM,
    safeLoad: gM,
    safeLoadAll: mM,
    safeDump: xM,
  };
const vM = ({ yaml: e, onChange: t }) => {
    const [n, r, i, o] = Le(ct, wr, Ke, Kl),
      s = Fe(),
      l = Ie(Kl),
      a = Ie(s2),
      u = C.useMemo(() => (e ? Object.entries(qm.load(e)).map(([b, m]) => ({ key: b, value: m })) : []), [e]),
      { register: c, control: d, handleSubmit: f } = Ad({ defaultValues: { yamlConfig: u } }),
      { fields: h, append: p, remove: g } = J5({ control: d, name: "yamlConfig" }),
      x = C.useCallback(
        ({ yamlConfig: b }) => {
          if (b.length === 0) {
            a(), l(!1);
            return;
          }
          const m = b.reduce((v, { key: _, value: k }) => (_ && k && (v[_] = k), v), {});
          t(qm.dump(m).trim()), l(!1);
        },
        [t, l, a],
      );
    return C.createElement(
      C.Fragment,
      null,
      C.createElement(
        Vb,
        {
          open: o,
          onOpenChange: (b) => {
            l(b);
          },
        },
        C.createElement(
          zb,
          { container: r == null ? void 0 : r.current },
          C.createElement(jb, { className: D.dialogOverlay }),
          C.createElement(
            Ub,
            { className: D.largeDialogContent, "data-editor-type": "frontmatter" },
            C.createElement(
              Wb,
              { className: D.dialogTitle },
              s("frontmatterEditor.title", "Edit document frontmatter"),
            ),
            C.createElement(
              "form",
              {
                onSubmit: (b) => {
                  f(x)(b), b.stopPropagation();
                },
                onReset: (b) => {
                  b.stopPropagation(), l(!1);
                },
              },
              C.createElement(
                "table",
                { className: D.propertyEditorTable },
                C.createElement(
                  "colgroup",
                  null,
                  C.createElement("col", null),
                  C.createElement("col", null),
                  C.createElement("col", null),
                ),
                C.createElement(
                  "thead",
                  null,
                  C.createElement(
                    "tr",
                    null,
                    C.createElement("th", null, s("frontmatterEditor.key", "Key")),
                    C.createElement("th", null, s("frontmatterEditor.value", "Value")),
                    C.createElement("th", null),
                  ),
                ),
                C.createElement(
                  "tbody",
                  null,
                  h.map((b, m) =>
                    C.createElement(
                      "tr",
                      { key: b.id },
                      C.createElement(
                        "td",
                        null,
                        C.createElement(Ym, {
                          ...c(`yamlConfig.${m}.key`, { required: !0 }),
                          autofocusIfEmpty: !0,
                          readOnly: n,
                        }),
                      ),
                      C.createElement(
                        "td",
                        null,
                        C.createElement(Ym, { ...c(`yamlConfig.${m}.value`, { required: !0 }), readOnly: n }),
                      ),
                      C.createElement(
                        "td",
                        null,
                        C.createElement(
                          "button",
                          {
                            type: "button",
                            onClick: () => {
                              g(m);
                            },
                            className: D.iconButton,
                            disabled: n,
                          },
                          i("delete_big"),
                        ),
                      ),
                    ),
                  ),
                ),
                C.createElement(
                  "tfoot",
                  null,
                  C.createElement(
                    "tr",
                    null,
                    C.createElement(
                      "td",
                      null,
                      C.createElement(
                        "button",
                        {
                          disabled: n,
                          className: we(D.primaryButton, D.smallButton),
                          type: "button",
                          onClick: () => {
                            p({ key: "", value: "" });
                          },
                        },
                        s("frontmatterEditor.addEntry", "Add entry"),
                      ),
                    ),
                  ),
                ),
              ),
              C.createElement(
                "div",
                { style: { display: "flex", justifyContent: "flex-end", gap: "var(--spacing-2)" } },
                C.createElement(
                  "button",
                  { type: "submit", className: D.primaryButton },
                  s("dialogControls.save", "Save"),
                ),
                C.createElement(
                  "button",
                  { type: "reset", className: D.secondaryButton },
                  s("dialogControls.cancel", "Cancel"),
                ),
              ),
            ),
            C.createElement(
              Kb,
              { asChild: !0 },
              C.createElement(
                "button",
                { className: D.dialogCloseButton, "aria-label": s("dialogControls.cancel", "Cancel") },
                i("close"),
              ),
            ),
          ),
        ),
      ),
    );
  },
  Ym = C.forwardRef(({ className: e, autofocusIfEmpty: t, ...n }, r) =>
    C.createElement("input", { className: we(D.propertyEditorInput, e), ...n, ref: r }),
  );
var bM = Object.defineProperty,
  yM = (e, t, n) => (t in e ? bM(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (e[t] = n)),
  CM = (e, t, n) => (yM(e, t + "", n), n);
class ks extends Cr {
  constructor(t, n) {
    super(n), CM(this, "__yaml"), (this.__yaml = t);
  }
  static getType() {
    return "frontmatter";
  }
  static clone(t) {
    return new ks(t.__yaml, t.__key);
  }
  static importJSON(t) {
    const { yaml: n } = t;
    return Ua(n);
  }
  exportJSON() {
    return { yaml: this.getYaml(), type: "frontmatter", version: 1 };
  }
  createDOM(t) {
    return document.createElement("div");
  }
  updateDOM() {
    return !1;
  }
  getYaml() {
    return this.getLatest().__yaml;
  }
  setYaml(t) {
    t !== this.__yaml && (this.getWritable().__yaml = t);
  }
  decorate(t) {
    return C.createElement(vM, {
      yaml: this.getYaml(),
      onChange: (n) => {
        t.update(() => {
          this.setYaml(n);
        });
      },
    });
  }
  isKeyboardSelectable() {
    return !1;
  }
}
function Ua(e) {
  return new ks(e);
}
function zr(e) {
  return e instanceof ks;
}
const _M = {
    testLexicalNode: zr,
    visitLexicalNode: ({ actions: e, lexicalNode: t }) => {
      e.addAndStepInto("yaml", { value: t.getYaml() });
    },
  },
  wM = {
    testNode: "yaml",
    visitNode({ mdastNode: e, actions: t }) {
      t.addAndStepInto(Ua(e.value));
    },
  },
  Kl = ne(!1),
  o2 = Nn((e) => {
    e.sub(e.pipe(o2, Ve(Ht)), ([, t]) => {
      t == null ||
        t.update(() => {
          const n = Ce().getFirstChild();
          if (!zr(n)) {
            const r = Ua('"": ""');
            n ? n.insertBefore(r) : Ce().append(r);
          }
        }),
        e.pub(Kl, !0);
    });
  }),
  s2 = Nn((e) => {
    e.sub(e.pipe(s2, Ve(Ht)), ([, t]) => {
      t == null ||
        t.update(() => {
          const n = Ce().getFirstChild();
          zr(n) && n.remove();
        }),
        e.pub(Kl, !1);
    });
  }),
  l2 = ne(!1, (e) => {
    e.pub(La, (t) =>
      t.registerUpdateListener(({ editorState: n }) => {
        n.read(() => {
          e.pub(l2, zr(Ce().getFirstChild()));
        });
      }),
    );
  }),
  EM = vt({
    init: (e) => {
      e.pubIn({
        [Vi]: JI("yaml"),
        [Hi]: UI(),
        [fn]: ks,
        [Gt]: wM,
        [hn]: _M,
        [vs]: YI("yaml"),
        [La]: (t) =>
          t.registerCommand(
            Hd,
            (n) => {
              let r = !1;
              return (
                t.read(() => {
                  const i = J();
                  if (H(i))
                    if (i.isCollapsed() && i.anchor.offset === 0 && i.focus.offset === 0 && n.key === "Backspace") {
                      let o = i.getNodes()[0];
                      Z(o) && (o = o.getParent());
                      const s = o == null ? void 0 : o.getPreviousSibling();
                      zr(s) && ((r = !0), n.preventDefault());
                    } else {
                      const o = i.getNodes()[0];
                      if (zr(o)) {
                        const s = o.getYaml();
                        setTimeout(() => {
                          t.update(
                            () => {
                              const l = Ce().getFirstChild();
                              zr(l) || Ce().splice(0, 0, [Ua(s)]);
                            },
                            { discrete: !0 },
                          );
                        });
                      }
                    }
                }),
                !!r
              );
            },
            Bt,
          ),
      });
    },
  }),
  kM = {
    testNode: "blockquote",
    visitNode({ actions: e }) {
      e.addAndStepInto(gs());
    },
  },
  SM = {
    testLexicalNode: Tc,
    visitLexicalNode: ({ lexicalNode: e, mdastParent: t, actions: n }) => {
      const r = { type: "paragraph", children: [] };
      n.appendToParent(t, { type: "blockquote", children: [r] }), n.visitChildren(e, r);
    },
  },
  TM = vt({
    init(e) {
      e.pubIn({ [ro]: "quote", [Gt]: kM, [fn]: to, [hn]: SM });
    },
  }),
  a2 = C.createContext(void 0);
function Wa() {
  const e = C.useContext(a2);
  if (!e) throw new Error("useNestedEditor must be used within a NestedEditorsProvider");
  return e;
}
function AM() {
  const { parentEditor: e, mdastNode: t, lexicalNode: n } = Wa();
  return function (i) {
    e.update(
      () => {
        T0("history-push");
        const o = Oe(n.getKey());
        o && o.setMdastNode({ ...t, ...i });
      },
      { discrete: !0 },
    ),
      e.dispatchCommand(Qr, void 0);
  };
}
function IM() {
  const { parentEditor: e, lexicalNode: t } = Wa();
  return () => {
    e.update(() => {
      const n = Oe(t.getKey());
      n.selectNext(), n.remove();
    });
  };
}
const NM = function (e) {
  const { getContent: t, getUpdatedMdastNode: n, contentEditableProps: r, block: i = !1 } = e,
    { mdastNode: o, lexicalNode: s, focusEmitter: l } = Wa(),
    a = AM(),
    u = IM(),
    c = t(o),
    d = Gi(),
    [f, h, p, g, x, b, m, v, _, k] = Le(Ht, Ta, Ia, Aa, Na, Bi, no, Lf, qx, Ll),
    w = Ie(li),
    [y] = C.useState(() => rf({ nodes: g, theme: d.getValue(Ll) }));
  return (
    C.useEffect(() => {
      l.subscribe(() => {
        y.focus();
      });
    }, [y, l]),
    C.useEffect(() => {
      y.update(() => {
        Ce().clear();
        let S = c;
        i ? S.length === 0 && (S = [{ type: "paragraph", children: [] }]) : (S = [{ type: "paragraph", children: c }]),
          Af({
            root: Ce(),
            mdastRoot: { type: "root", children: S },
            visitors: h,
            directiveDescriptors: b,
            codeBlockEditorDescriptors: m,
            jsxComponentDescriptors: x,
          });
      });
    }, [y, i, h]),
    C.useEffect(() => {
      function S() {
        y.getEditorState().read(() => {
          const T = kf({
              root: Ce(),
              visitors: p,
              jsxComponentDescriptors: x,
              jsxIsAvailable: v,
              addImportStatements: !1,
            }),
            A = i ? T.children : T.children[0].children;
          a(n(structuredClone(o), A));
        });
      }
      return yt(
        y.registerCommand(sa, () => (w({ editorType: "lexical", rootNode: s }), !1), He),
        y.registerCommand(
          la,
          (T) => {
            const A = T.relatedTarget;
            return rh(A, f.getRootElement()) ? !1 : (S(), w(null), !0);
          },
          be,
        ),
        y.registerCommand(Qr, () => (S(), !0), be),
        y.registerCommand(os, () => (w({ editorType: "lexical", rootNode: s }), !1), wl),
        y.registerCommand(
          na,
          (T, A) => {
            const F = A.getRootElement();
            return (F == null ? void 0 : F.innerText) ===
              `
`
              ? (u(), !0)
              : !1;
          },
          Bt,
        ),
      );
    }, [i, y, p, n, x, v, s, o, u, w, a, f]),
    C.createElement(
      yv,
      { initialEditor: y, initialTheme: k },
      C.createElement(Pf, {
        contentEditable: C.createElement(Rf, { ...r, className: we(D.nestedEditor, r == null ? void 0 : r.className) }),
        placeholder: null,
        ErrorBoundary: Df,
      }),
      C.createElement(Px, null),
      _.map((S, T) => C.createElement(S, { key: T })),
    )
  );
};
function u2() {
  let e = Pr;
  return {
    publish: () => {
      e();
    },
    subscribe: (t) => {
      e = t;
    },
  };
}
var LM = Object.defineProperty,
  MM = (e, t, n) => (t in e ? LM(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (e[t] = n)),
  lr = (e, t, n) => (MM(e, typeof t != "symbol" ? t + "" : t, n), n);
class lo extends Cr {
  constructor(t, n, r, i) {
    super(i),
      lr(this, "__code"),
      lr(this, "__meta"),
      lr(this, "__language"),
      lr(this, "__focusEmitter", u2()),
      lr(this, "setCode", (o) => {
        o !== this.__code && (this.getWritable().__code = o);
      }),
      lr(this, "setMeta", (o) => {
        o !== this.__meta && (this.getWritable().__meta = o);
      }),
      lr(this, "setLanguage", (o) => {
        o !== this.__language && (this.getWritable().__language = o);
      }),
      lr(this, "select", () => {
        this.__focusEmitter.publish();
      }),
      (this.__code = t),
      (this.__meta = r),
      (this.__language = n);
  }
  static getType() {
    return "codeblock";
  }
  static clone(t) {
    return new lo(t.__code, t.__language, t.__meta, t.__key);
  }
  static importJSON(t) {
    const { code: n, meta: r, language: i } = t;
    return Ss({ code: n, language: i, meta: r });
  }
  static importDOM() {
    return { pre: () => ({ conversion: PM, priority: 3 }) };
  }
  exportJSON() {
    return { code: this.getCode(), language: this.getLanguage(), meta: this.getMeta(), type: "codeblock", version: 1 };
  }
  createDOM(t) {
    return document.createElement("div");
  }
  updateDOM() {
    return !1;
  }
  getCode() {
    return this.__code;
  }
  getMeta() {
    return this.__meta;
  }
  getLanguage() {
    return this.__language;
  }
  decorate(t) {
    return C.createElement(FM, {
      parentEditor: t,
      code: this.getCode(),
      meta: this.getMeta(),
      language: this.getLanguage(),
      codeBlockNode: this,
      nodeKey: this.getKey(),
      focusEmitter: this.__focusEmitter,
    });
  }
  isInline() {
    return !1;
  }
}
const c2 = C.createContext(null),
  OM = ({ parentEditor: e, lexicalNode: t, children: n }) => {
    const r = C.useMemo(
      () => ({
        lexicalNode: t,
        parentEditor: e,
        setCode: (i) => {
          e.update(() => {
            t.setCode(i),
              setTimeout(() => {
                e.dispatchCommand(Qr, void 0);
              }, 0);
          });
        },
        setLanguage: (i) => {
          e.update(() => {
            t.setLanguage(i);
          });
        },
        setMeta: (i) => {
          e.update(() => {
            t.setMeta(i);
          });
        },
      }),
      [t, e],
    );
    return C.createElement(c2.Provider, { value: r }, n);
  };
function hd() {
  const e = C.useContext(c2);
  if (!e) throw new Error("useCodeBlockEditor must be used within a CodeBlockEditor");
  return e;
}
const FM = (e) => {
  const t = qe(no),
    n = qe(Lh);
  let r = t.sort((a, u) => u.priority - a.priority).find((a) => a.match(e.language || "", e.meta || ""));
  if ((r || (r = t.find((a) => a.match(n || "", e.meta || ""))), !r))
    throw new Error(`No CodeBlockEditor registered for language=${e.language} meta=${e.meta}`);
  const i = r.Editor,
    { codeBlockNode: o, parentEditor: s, ...l } = e;
  return C.createElement(
    OM,
    { parentEditor: e.parentEditor, lexicalNode: e.codeBlockNode },
    C.createElement(i, { ...l }),
  );
};
function Ss(e) {
  const { code: t = "", language: n = "", meta: r = "" } = e;
  return new lo(t, n, r);
}
function RM(e) {
  return e instanceof lo;
}
function PM(e) {
  const t = e,
    n = t.textContent ?? "",
    r = e.getAttribute("class") ?? "",
    i = e.getAttribute("data-language") ?? "",
    o = r.match(/language-(\w+)/),
    s = o ? o[1] : i,
    l = t.getAttribute("data-meta") ?? "";
  return { node: Ss({ code: n, language: s, meta: l }) };
}
const DM = {
    testLexicalNode: RM,
    visitLexicalNode: ({ lexicalNode: e, actions: t }) => {
      t.addAndStepInto("code", { value: e.getCode(), lang: e.getLanguage(), meta: e.getMeta() });
    },
  },
  $M = {
    testNode: (e, { codeBlockEditorDescriptors: t }) =>
      e.type === "code" ? t.find((r) => r.match(e.lang, e.meta)) !== void 0 : !1,
    visitNode({ mdastNode: e, actions: t }) {
      t.addAndStepInto(Ss({ code: e.value, language: e.lang, meta: e.meta }));
    },
  },
  Lh = ne(""),
  Ka = Ze((e) => {
    e.link(
      e.pipe(
        Ka,
        Ve(Lh),
        tn(
          ([t, n]) =>
            () =>
              Ss({ language: n, ...t }),
        ),
      ),
      Ma,
    );
  }),
  BM = At(no),
  HM = vt({
    update(e, t) {
      e.pub(Lh, (t == null ? void 0 : t.defaultCodeBlockLanguage) ?? "");
    },
    init(e, t) {
      e.pubIn({
        [ro]: "codeblock",
        [no]: (t == null ? void 0 : t.codeBlockEditorDescriptors) ?? [],
        [Gt]: $M,
        [fn]: lo,
        [hn]: DM,
      });
    },
  });
function VM(e, t, n, r) {
  const i = qe(je),
    o = Ie(li),
    s = C.useRef(null),
    { lexicalNode: l } = hd(),
    a = C.useRef(!1),
    u = C.useRef(!1),
    c = C.useCallback(() => {
      o({ editorType: t, rootNode: l });
    }, [t, l, o]),
    d = C.useCallback(
      (f) => {
        var h, p, g, x, b, m;
        if (f.key === "ArrowDown") {
          const v = (p = (h = s.current) == null ? void 0 : h.getCodemirror()) == null ? void 0 : p.state;
          if (v) {
            const _ = v.doc.length,
              k = v.selection.ranges[0].to;
            _ === k &&
              (a.current
                ? (i == null ||
                    i.update(() => {
                      var w, y;
                      const S = Oe(e);
                      S.getNextSibling()
                        ? ((y = (w = s.current) == null ? void 0 : w.getCodemirror()) == null || y.contentDOM.blur(),
                          S.selectNext())
                        : S.insertAfter(Se());
                    }),
                  (a.current = !1))
                : (a.current = !0));
          }
        } else if (f.key === "ArrowUp") {
          const v = (x = (g = s.current) == null ? void 0 : g.getCodemirror()) == null ? void 0 : x.state;
          v &&
            v.selection.ranges[0].from === 0 &&
            (u.current
              ? (i == null ||
                  i.update(() => {
                    var k, w;
                    const y = Oe(e);
                    y.getPreviousSibling() &&
                      ((w = (k = s.current) == null ? void 0 : k.getCodemirror()) == null || w.contentDOM.blur(),
                      y.selectPrevious());
                  }),
                (u.current = !1))
              : (u.current = !0));
        } else if (f.key === "Enter") f.stopPropagation();
        else if (f.key === "Backspace" || f.key === "Delete") {
          const v = (m = (b = s.current) == null ? void 0 : b.getCodemirror()) == null ? void 0 : m.state;
          (v == null ? void 0 : v.doc.length) === 0 &&
            (i == null ||
              i.update(() => {
                Oe(e).remove();
              }));
        }
      },
      [i, e],
    );
  return (
    C.useEffect(() => {
      const f = s.current;
      return (
        setTimeout(() => {
          var h, p;
          (h = f == null ? void 0 : f.getCodemirror()) == null || h.contentDOM.addEventListener("focus", c),
            (p = f == null ? void 0 : f.getCodemirror()) == null || p.contentDOM.addEventListener("keydown", d);
        }, 300),
        () => {
          var h, p;
          (h = f == null ? void 0 : f.getCodemirror()) == null || h.contentDOM.removeEventListener("focus", c),
            (p = f == null ? void 0 : f.getCodemirror()) == null || p.contentDOM.removeEventListener("keydown", d);
        }
      );
    }, [s, c, d, n]),
    C.useEffect(() => {
      r.subscribe(() => {
        var f, h;
        (h = (f = s.current) == null ? void 0 : f.getCodemirror()) == null || h.focus(), c();
      });
    }, [r, s, e, c]),
    s
  );
}
const zM = `
export default function App() {
  return (
    <div className="App">
      <h1>Hello CodeSandbox</h1>
      <h2>Start editing to see some magic happen!</h2>
    </div>
  );
}
`,
  jM = {
    defaultPreset: "react",
    presets: [
      {
        name: "react",
        meta: "live react",
        label: "React",
        sandpackTemplate: "react",
        sandpackTheme: "light",
        snippetFileName: "/App.js",
        snippetLanguage: "jsx",
        initialSnippetContent: zM,
      },
    ],
  },
  d2 = ne(jM),
  UM = Ze((e) => {
    e.link(
      e.pipe(
        UM,
        Ve(d2),
        tn(([t, n]) => {
          const r = t ? n.presets.find((i) => i.name === t) : n.presets.find((i) => i.name == n.defaultPreset);
          if (!r) throw new Error(`No sandpack preset found with name ${t}`);
          return { code: r.initialSnippetContent ?? "", language: r.snippetLanguage ?? "jsx", meta: r.meta };
        }),
      ),
      Ka,
    );
  }),
  Xm = "#2e3440",
  Mh = "#3b4252",
  Qm = "#434c5e",
  Gs = "#4c566a",
  e1 = "#e5e9f0",
  pd = "#eceff4",
  Pu = "#8fbcbb",
  t1 = "#88c0d0",
  WM = "#81a1c1",
  Xt = "#5e81ac",
  KM = "#bf616a",
  xi = "#d08770",
  Du = "#ebcb8b",
  n1 = "#a3be8c",
  JM = "#b48ead",
  r1 = "#d30102",
  Oh = pd,
  $u = Oh,
  GM = "#ffffff",
  Bu = Mh,
  ZM = Oh,
  i1 = Mh,
  qM = kn.theme(
    {
      "&": { color: Xm, backgroundColor: GM },
      ".cm-content": { caretColor: i1 },
      ".cm-cursor, .cm-dropCursor": { borderLeftColor: i1 },
      "&.cm-focused .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: ZM },
      ".cm-panels": { backgroundColor: Oh, color: Gs },
      ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
      ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
      ".cm-searchMatch": { backgroundColor: "#72a1ff59", outline: `1px solid ${Gs}` },
      ".cm-searchMatch.cm-searchMatch-selected": { backgroundColor: e1 },
      ".cm-activeLine": { backgroundColor: $u },
      ".cm-selectionMatch": { backgroundColor: e1 },
      "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": { outline: `1px solid ${Gs}` },
      "&.cm-focused .cm-matchingBracket": { backgroundColor: pd },
      ".cm-gutters": { backgroundColor: pd, color: Xm, border: "none" },
      ".cm-activeLineGutter": { backgroundColor: $u },
      ".cm-foldPlaceholder": { backgroundColor: "transparent", border: "none", color: "#ddd" },
      ".cm-tooltip": { border: "none", backgroundColor: Bu },
      ".cm-tooltip .cm-tooltip-arrow:before": { borderTopColor: "transparent", borderBottomColor: "transparent" },
      ".cm-tooltip .cm-tooltip-arrow:after": { borderTopColor: Bu, borderBottomColor: Bu },
      ".cm-tooltip-autocomplete": { "& > ul > li[aria-selected]": { backgroundColor: $u, color: Gs } },
    },
    { dark: !1 },
  ),
  YM = rC.define([
    { tag: ie.keyword, color: Xt },
    { tag: [ie.name, ie.deleted, ie.character, ie.propertyName, ie.macroName], color: xi },
    { tag: [ie.variableName], color: xi },
    { tag: [ie.function(ie.variableName)], color: Xt },
    { tag: [ie.labelName], color: WM },
    { tag: [ie.color, ie.constant(ie.name), ie.standard(ie.name)], color: Xt },
    { tag: [ie.definition(ie.name), ie.separator], color: n1 },
    { tag: [ie.brace], color: Pu },
    { tag: [ie.annotation], color: r1 },
    { tag: [ie.number, ie.changed, ie.annotation, ie.modifier, ie.self, ie.namespace], color: t1 },
    { tag: [ie.typeName, ie.className], color: Du },
    { tag: [ie.operator, ie.operatorKeyword], color: n1 },
    { tag: [ie.tagName], color: JM },
    { tag: [ie.squareBracket], color: KM },
    { tag: [ie.angleBracket], color: xi },
    { tag: [ie.attributeName], color: Du },
    { tag: [ie.regexp], color: Xt },
    { tag: [ie.quote], color: Mh },
    { tag: [ie.string], color: xi },
    { tag: ie.link, color: Pu, textDecoration: "underline", textUnderlinePosition: "under" },
    { tag: [ie.url, ie.escape, ie.special(ie.string)], color: xi },
    { tag: [ie.meta], color: t1 },
    { tag: [ie.comment], color: Qm, fontStyle: "italic" },
    { tag: ie.strong, fontWeight: "bold", color: Xt },
    { tag: ie.emphasis, fontStyle: "italic", color: Xt },
    { tag: ie.strikethrough, textDecoration: "line-through" },
    { tag: ie.heading, fontWeight: "bold", color: Xt },
    { tag: ie.special(ie.heading1), fontWeight: "bold", color: Xt },
    { tag: ie.heading1, fontWeight: "bold", color: Xt },
    { tag: [ie.heading2, ie.heading3, ie.heading4], fontWeight: "bold", color: Xt },
    { tag: [ie.heading5, ie.heading6], color: Xt },
    { tag: [ie.atom, ie.bool, ie.special(ie.variableName)], color: xi },
    { tag: [ie.processingInstruction, ie.inserted], color: Pu },
    { tag: [ie.contentSeparator], color: Du },
    { tag: ie.invalid, color: Qm, borderBottom: `1px dotted ${r1}` },
  ]),
  f2 = [qM, E1(YM)],
  h2 = [
    Nd(),
    iC(),
    oC(),
    sC(),
    lC(),
    aC(),
    uC(),
    jr.allowMultipleSelections.of(!0),
    cC(),
    E1(kC, { fallback: !0 }),
    dC(),
    fC(),
    hC(),
    pC(),
    gC(),
    mC(),
    xC(),
    k1.of([...vC, ...bC, ...yC, ...CC, ..._C, ...wC, ...EC]),
  ];
function o1(e, [t, n]) {
  return Math.min(n, Math.max(t, e));
}
function XM(e) {
  const t = E.useRef({ value: e, previous: e });
  return E.useMemo(
    () => (
      t.current.value !== e && ((t.current.previous = t.current.value), (t.current.value = e)), t.current.previous
    ),
    [e],
  );
}
var p2 = Object.freeze({
    position: "absolute",
    border: 0,
    width: 1,
    height: 1,
    padding: 0,
    margin: -1,
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    wordWrap: "normal",
  }),
  QM = "VisuallyHidden",
  g2 = E.forwardRef((e, t) => O.jsx(_e.span, { ...e, ref: t, style: { ...p2, ...e.style } }));
g2.displayName = QM;
var eO = g2,
  tO = [" ", "Enter", "ArrowUp", "ArrowDown"],
  nO = [" ", "Enter"],
  ni = "Select",
  [Ja, Ga, rO] = Jv(ni),
  [ao, cP] = ir(ni, [rO, oo]),
  Za = oo(),
  [iO, Tr] = ao(ni),
  [oO, sO] = ao(ni),
  m2 = (e) => {
    const {
        __scopeSelect: t,
        children: n,
        open: r,
        defaultOpen: i,
        onOpenChange: o,
        value: s,
        defaultValue: l,
        onValueChange: a,
        dir: u,
        name: c,
        autoComplete: d,
        disabled: f,
        required: h,
        form: p,
      } = e,
      g = Za(t),
      [x, b] = E.useState(null),
      [m, v] = E.useState(null),
      [_, k] = E.useState(!1),
      w = $a(u),
      [y, S] = Qn({ prop: r, defaultProp: i ?? !1, onChange: o, caller: ni }),
      [T, A] = Qn({ prop: s, defaultProp: l, onChange: a, caller: ni }),
      F = E.useRef(null),
      R = x ? p || !!x.closest("form") : !0,
      [V, B] = E.useState(new Set()),
      N = Array.from(V)
        .map((G) => G.props.value)
        .join(";");
    return O.jsx(jf, {
      ...g,
      children: O.jsxs(iO, {
        required: h,
        scope: t,
        trigger: x,
        onTriggerChange: b,
        valueNode: m,
        onValueNodeChange: v,
        valueNodeHasChildren: _,
        onValueNodeHasChildrenChange: k,
        contentId: Zn(),
        value: T,
        onValueChange: A,
        open: y,
        onOpenChange: S,
        dir: w,
        triggerPointerDownPosRef: F,
        disabled: f,
        children: [
          O.jsx(Ja.Provider, {
            scope: t,
            children: O.jsx(oO, {
              scope: e.__scopeSelect,
              onNativeOptionAdd: E.useCallback((G) => {
                B((U) => new Set(U).add(G));
              }, []),
              onNativeOptionRemove: E.useCallback((G) => {
                B((U) => {
                  const X = new Set(U);
                  return X.delete(G), X;
                });
              }, []),
              children: n,
            }),
          }),
          R
            ? O.jsxs(
                P2,
                {
                  "aria-hidden": !0,
                  required: h,
                  tabIndex: -1,
                  name: c,
                  autoComplete: d,
                  value: T,
                  onChange: (G) => A(G.target.value),
                  disabled: f,
                  form: p,
                  children: [T === void 0 ? O.jsx("option", { value: "" }) : null, Array.from(V)],
                },
                N,
              )
            : null,
        ],
      }),
    });
  };
m2.displayName = ni;
var x2 = "SelectTrigger",
  v2 = E.forwardRef((e, t) => {
    const { __scopeSelect: n, disabled: r = !1, ...i } = e,
      o = Za(n),
      s = Tr(x2, n),
      l = s.disabled || r,
      a = ze(t, s.onTriggerChange),
      u = Ga(n),
      c = E.useRef("touch"),
      [d, f, h] = $2((g) => {
        const x = u().filter((v) => !v.disabled),
          b = x.find((v) => v.value === s.value),
          m = B2(x, g, b);
        m !== void 0 && s.onValueChange(m.value);
      }),
      p = (g) => {
        l || (s.onOpenChange(!0), h()),
          g && (s.triggerPointerDownPosRef.current = { x: Math.round(g.pageX), y: Math.round(g.pageY) });
      };
    return O.jsx(Ra, {
      asChild: !0,
      ...o,
      children: O.jsx(_e.button, {
        type: "button",
        role: "combobox",
        "aria-controls": s.contentId,
        "aria-expanded": s.open,
        "aria-required": s.required,
        "aria-autocomplete": "none",
        dir: s.dir,
        "data-state": s.open ? "open" : "closed",
        disabled: l,
        "data-disabled": l ? "" : void 0,
        "data-placeholder": D2(s.value) ? "" : void 0,
        ...i,
        ref: a,
        onClick: ge(i.onClick, (g) => {
          g.currentTarget.focus(), c.current !== "mouse" && p(g);
        }),
        onPointerDown: ge(i.onPointerDown, (g) => {
          c.current = g.pointerType;
          const x = g.target;
          x.hasPointerCapture(g.pointerId) && x.releasePointerCapture(g.pointerId),
            g.button === 0 && g.ctrlKey === !1 && g.pointerType === "mouse" && (p(g), g.preventDefault());
        }),
        onKeyDown: ge(i.onKeyDown, (g) => {
          const x = d.current !== "";
          !(g.ctrlKey || g.altKey || g.metaKey) && g.key.length === 1 && f(g.key),
            !(x && g.key === " ") && tO.includes(g.key) && (p(), g.preventDefault());
        }),
      }),
    });
  });
v2.displayName = x2;
var b2 = "SelectValue",
  y2 = E.forwardRef((e, t) => {
    const { __scopeSelect: n, className: r, style: i, children: o, placeholder: s = "", ...l } = e,
      a = Tr(b2, n),
      { onValueNodeHasChildrenChange: u } = a,
      c = o !== void 0,
      d = ze(t, a.onValueNodeChange);
    return (
      xt(() => {
        u(c);
      }, [u, c]),
      O.jsx(_e.span, {
        ...l,
        ref: d,
        style: { pointerEvents: "none" },
        children: D2(a.value) ? O.jsx(O.Fragment, { children: s }) : o,
      })
    );
  });
y2.displayName = b2;
var lO = "SelectIcon",
  C2 = E.forwardRef((e, t) => {
    const { __scopeSelect: n, children: r, ...i } = e;
    return O.jsx(_e.span, { "aria-hidden": !0, ...i, ref: t, children: r || "▼" });
  });
C2.displayName = lO;
var aO = "SelectPortal",
  _2 = (e) => O.jsx(Cs, { asChild: !0, ...e });
_2.displayName = aO;
var ri = "SelectContent",
  w2 = E.forwardRef((e, t) => {
    const n = Tr(ri, e.__scopeSelect),
      [r, i] = E.useState();
    if (
      (xt(() => {
        i(new DocumentFragment());
      }, []),
      !n.open)
    ) {
      const o = r;
      return o
        ? Ni.createPortal(
            O.jsx(E2, {
              scope: e.__scopeSelect,
              children: O.jsx(Ja.Slot, { scope: e.__scopeSelect, children: O.jsx("div", { children: e.children }) }),
            }),
            o,
          )
        : null;
    }
    return O.jsx(k2, { ...e, ref: t });
  });
w2.displayName = ri;
var Qt = 10,
  [E2, Ar] = ao(ri),
  uO = "SelectContentImpl",
  cO = ji("SelectContent.RemoveScroll"),
  k2 = E.forwardRef((e, t) => {
    const {
        __scopeSelect: n,
        position: r = "item-aligned",
        onCloseAutoFocus: i,
        onEscapeKeyDown: o,
        onPointerDownOutside: s,
        side: l,
        sideOffset: a,
        align: u,
        alignOffset: c,
        arrowPadding: d,
        collisionBoundary: f,
        collisionPadding: h,
        sticky: p,
        hideWhenDetached: g,
        avoidCollisions: x,
        ...b
      } = e,
      m = Tr(ri, n),
      [v, _] = E.useState(null),
      [k, w] = E.useState(null),
      y = ze(t, (z) => _(z)),
      [S, T] = E.useState(null),
      [A, F] = E.useState(null),
      R = Ga(n),
      [V, B] = E.useState(!1),
      N = E.useRef(!1);
    E.useEffect(() => {
      if (v) return Id(v);
    }, [v]),
      Hf();
    const G = E.useCallback(
        (z) => {
          const [W, ...Y] = R().map((he) => he.ref.current),
            [Q] = Y.slice(-1),
            oe = document.activeElement;
          for (const he of z)
            if (
              he === oe ||
              (he == null || he.scrollIntoView({ block: "nearest" }),
              he === W && k && (k.scrollTop = 0),
              he === Q && k && (k.scrollTop = k.scrollHeight),
              he == null || he.focus(),
              document.activeElement !== oe)
            )
              return;
        },
        [R, k],
      ),
      U = E.useCallback(() => G([S, v]), [G, S, v]);
    E.useEffect(() => {
      V && U();
    }, [V, U]);
    const { onOpenChange: X, triggerPointerDownPosRef: te } = m;
    E.useEffect(() => {
      if (v) {
        let z = { x: 0, y: 0 };
        const W = (Q) => {
            var oe, he;
            z = {
              x: Math.abs(Math.round(Q.pageX) - (((oe = te.current) == null ? void 0 : oe.x) ?? 0)),
              y: Math.abs(Math.round(Q.pageY) - (((he = te.current) == null ? void 0 : he.y) ?? 0)),
            };
          },
          Y = (Q) => {
            z.x <= 10 && z.y <= 10 ? Q.preventDefault() : v.contains(Q.target) || X(!1),
              document.removeEventListener("pointermove", W),
              (te.current = null);
          };
        return (
          te.current !== null &&
            (document.addEventListener("pointermove", W),
            document.addEventListener("pointerup", Y, { capture: !0, once: !0 })),
          () => {
            document.removeEventListener("pointermove", W),
              document.removeEventListener("pointerup", Y, { capture: !0 });
          }
        );
      }
    }, [v, X, te]),
      E.useEffect(() => {
        const z = () => X(!1);
        return (
          window.addEventListener("blur", z),
          window.addEventListener("resize", z),
          () => {
            window.removeEventListener("blur", z), window.removeEventListener("resize", z);
          }
        );
      }, [X]);
    const [L, se] = $2((z) => {
        const W = R().filter((oe) => !oe.disabled),
          Y = W.find((oe) => oe.ref.current === document.activeElement),
          Q = B2(W, z, Y);
        Q && setTimeout(() => Q.ref.current.focus());
      }),
      pe = E.useCallback(
        (z, W, Y) => {
          const Q = !N.current && !Y;
          ((m.value !== void 0 && m.value === W) || Q) && (T(z), Q && (N.current = !0));
        },
        [m.value],
      ),
      M = E.useCallback(() => (v == null ? void 0 : v.focus()), [v]),
      me = E.useCallback(
        (z, W, Y) => {
          const Q = !N.current && !Y;
          ((m.value !== void 0 && m.value === W) || Q) && F(z);
        },
        [m.value],
      ),
      Ee = r === "popper" ? gd : S2,
      ce =
        Ee === gd
          ? {
              side: l,
              sideOffset: a,
              align: u,
              alignOffset: c,
              arrowPadding: d,
              collisionBoundary: f,
              collisionPadding: h,
              sticky: p,
              hideWhenDetached: g,
              avoidCollisions: x,
            }
          : {};
    return O.jsx(E2, {
      scope: n,
      content: v,
      viewport: k,
      onViewportChange: w,
      itemRefCallback: pe,
      selectedItem: S,
      onItemLeave: M,
      itemTextRefCallback: me,
      focusSelectedItem: U,
      selectedItemText: A,
      position: r,
      isPositioned: V,
      searchRef: L,
      children: O.jsx(Td, {
        as: cO,
        allowPinchZoom: !0,
        children: O.jsx(Fa, {
          asChild: !0,
          trapped: m.open,
          onMountAutoFocus: (z) => {
            z.preventDefault();
          },
          onUnmountAutoFocus: ge(i, (z) => {
            var W;
            (W = m.trigger) == null || W.focus({ preventScroll: !0 }), z.preventDefault();
          }),
          children: O.jsx(ys, {
            asChild: !0,
            disableOutsidePointerEvents: !0,
            onEscapeKeyDown: o,
            onPointerDownOutside: s,
            onFocusOutside: (z) => z.preventDefault(),
            onDismiss: () => m.onOpenChange(!1),
            children: O.jsx(Ee, {
              role: "listbox",
              id: m.contentId,
              "data-state": m.open ? "open" : "closed",
              dir: m.dir,
              onContextMenu: (z) => z.preventDefault(),
              ...b,
              ...ce,
              onPlaced: () => B(!0),
              ref: y,
              style: { display: "flex", flexDirection: "column", outline: "none", ...b.style },
              onKeyDown: ge(b.onKeyDown, (z) => {
                const W = z.ctrlKey || z.altKey || z.metaKey;
                if (
                  (z.key === "Tab" && z.preventDefault(),
                  !W && z.key.length === 1 && se(z.key),
                  ["ArrowUp", "ArrowDown", "Home", "End"].includes(z.key))
                ) {
                  let Q = R()
                    .filter((oe) => !oe.disabled)
                    .map((oe) => oe.ref.current);
                  if (
                    (["ArrowUp", "End"].includes(z.key) && (Q = Q.slice().reverse()),
                    ["ArrowUp", "ArrowDown"].includes(z.key))
                  ) {
                    const oe = z.target,
                      he = Q.indexOf(oe);
                    Q = Q.slice(he + 1);
                  }
                  setTimeout(() => G(Q)), z.preventDefault();
                }
              }),
            }),
          }),
        }),
      }),
    });
  });
k2.displayName = uO;
var dO = "SelectItemAlignedPosition",
  S2 = E.forwardRef((e, t) => {
    const { __scopeSelect: n, onPlaced: r, ...i } = e,
      o = Tr(ri, n),
      s = Ar(ri, n),
      [l, a] = E.useState(null),
      [u, c] = E.useState(null),
      d = ze(t, (y) => c(y)),
      f = Ga(n),
      h = E.useRef(!1),
      p = E.useRef(!0),
      { viewport: g, selectedItem: x, selectedItemText: b, focusSelectedItem: m } = s,
      v = E.useCallback(() => {
        if (o.trigger && o.valueNode && l && u && g && x && b) {
          const y = o.trigger.getBoundingClientRect(),
            S = u.getBoundingClientRect(),
            T = o.valueNode.getBoundingClientRect(),
            A = b.getBoundingClientRect();
          if (o.dir !== "rtl") {
            const oe = A.left - S.left,
              he = T.left - oe,
              ke = y.left - he,
              De = y.width + ke,
              Xe = Math.max(De, S.width),
              Qe = window.innerWidth - Qt,
              rt = o1(he, [Qt, Math.max(Qt, Qe - Xe)]);
            (l.style.minWidth = De + "px"), (l.style.left = rt + "px");
          } else {
            const oe = S.right - A.right,
              he = window.innerWidth - T.right - oe,
              ke = window.innerWidth - y.right - he,
              De = y.width + ke,
              Xe = Math.max(De, S.width),
              Qe = window.innerWidth - Qt,
              rt = o1(he, [Qt, Math.max(Qt, Qe - Xe)]);
            (l.style.minWidth = De + "px"), (l.style.right = rt + "px");
          }
          const F = f(),
            R = window.innerHeight - Qt * 2,
            V = g.scrollHeight,
            B = window.getComputedStyle(u),
            N = parseInt(B.borderTopWidth, 10),
            G = parseInt(B.paddingTop, 10),
            U = parseInt(B.borderBottomWidth, 10),
            X = parseInt(B.paddingBottom, 10),
            te = N + G + V + X + U,
            L = Math.min(x.offsetHeight * 5, te),
            se = window.getComputedStyle(g),
            pe = parseInt(se.paddingTop, 10),
            M = parseInt(se.paddingBottom, 10),
            me = y.top + y.height / 2 - Qt,
            Ee = R - me,
            ce = x.offsetHeight / 2,
            z = x.offsetTop + ce,
            W = N + G + z,
            Y = te - W;
          if (W <= me) {
            const oe = F.length > 0 && x === F[F.length - 1].ref.current;
            l.style.bottom = "0px";
            const he = u.clientHeight - g.offsetTop - g.offsetHeight,
              ke = Math.max(Ee, ce + (oe ? M : 0) + he + U),
              De = W + ke;
            l.style.height = De + "px";
          } else {
            const oe = F.length > 0 && x === F[0].ref.current;
            l.style.top = "0px";
            const ke = Math.max(me, N + g.offsetTop + (oe ? pe : 0) + ce) + Y;
            (l.style.height = ke + "px"), (g.scrollTop = W - me + g.offsetTop);
          }
          (l.style.margin = `${Qt}px 0`),
            (l.style.minHeight = L + "px"),
            (l.style.maxHeight = R + "px"),
            r == null || r(),
            requestAnimationFrame(() => (h.current = !0));
        }
      }, [f, o.trigger, o.valueNode, l, u, g, x, b, o.dir, r]);
    xt(() => v(), [v]);
    const [_, k] = E.useState();
    xt(() => {
      u && k(window.getComputedStyle(u).zIndex);
    }, [u]);
    const w = E.useCallback(
      (y) => {
        y && p.current === !0 && (v(), m == null || m(), (p.current = !1));
      },
      [v, m],
    );
    return O.jsx(hO, {
      scope: n,
      contentWrapper: l,
      shouldExpandOnScrollRef: h,
      onScrollButtonChange: w,
      children: O.jsx("div", {
        ref: a,
        style: { display: "flex", flexDirection: "column", position: "fixed", zIndex: _ },
        children: O.jsx(_e.div, { ...i, ref: d, style: { boxSizing: "border-box", maxHeight: "100%", ...i.style } }),
      }),
    });
  });
S2.displayName = dO;
var fO = "SelectPopperPosition",
  gd = E.forwardRef((e, t) => {
    const { __scopeSelect: n, align: r = "start", collisionPadding: i = Qt, ...o } = e,
      s = Za(n);
    return O.jsx(Uf, {
      ...s,
      ...o,
      ref: t,
      align: r,
      collisionPadding: i,
      style: {
        boxSizing: "border-box",
        ...o.style,
        "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-select-content-available-width": "var(--radix-popper-available-width)",
        "--radix-select-content-available-height": "var(--radix-popper-available-height)",
        "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-select-trigger-height": "var(--radix-popper-anchor-height)",
      },
    });
  });
gd.displayName = fO;
var [hO, Fh] = ao(ri, {}),
  md = "SelectViewport",
  T2 = E.forwardRef((e, t) => {
    const { __scopeSelect: n, nonce: r, ...i } = e,
      o = Ar(md, n),
      s = Fh(md, n),
      l = ze(t, o.onViewportChange),
      a = E.useRef(0);
    return O.jsxs(O.Fragment, {
      children: [
        O.jsx("style", {
          dangerouslySetInnerHTML: {
            __html:
              "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}",
          },
          nonce: r,
        }),
        O.jsx(Ja.Slot, {
          scope: n,
          children: O.jsx(_e.div, {
            "data-radix-select-viewport": "",
            role: "presentation",
            ...i,
            ref: l,
            style: { position: "relative", flex: 1, overflow: "hidden auto", ...i.style },
            onScroll: ge(i.onScroll, (u) => {
              const c = u.currentTarget,
                { contentWrapper: d, shouldExpandOnScrollRef: f } = s;
              if (f != null && f.current && d) {
                const h = Math.abs(a.current - c.scrollTop);
                if (h > 0) {
                  const p = window.innerHeight - Qt * 2,
                    g = parseFloat(d.style.minHeight),
                    x = parseFloat(d.style.height),
                    b = Math.max(g, x);
                  if (b < p) {
                    const m = b + h,
                      v = Math.min(p, m),
                      _ = m - v;
                    (d.style.height = v + "px"),
                      d.style.bottom === "0px" &&
                        ((c.scrollTop = _ > 0 ? _ : 0), (d.style.justifyContent = "flex-end"));
                  }
                }
              }
              a.current = c.scrollTop;
            }),
          }),
        }),
      ],
    });
  });
T2.displayName = md;
var A2 = "SelectGroup",
  [pO, gO] = ao(A2),
  mO = E.forwardRef((e, t) => {
    const { __scopeSelect: n, ...r } = e,
      i = Zn();
    return O.jsx(pO, {
      scope: n,
      id: i,
      children: O.jsx(_e.div, { role: "group", "aria-labelledby": i, ...r, ref: t }),
    });
  });
mO.displayName = A2;
var I2 = "SelectLabel",
  xO = E.forwardRef((e, t) => {
    const { __scopeSelect: n, ...r } = e,
      i = gO(I2, n);
    return O.jsx(_e.div, { id: i.id, ...r, ref: t });
  });
xO.displayName = I2;
var Jl = "SelectItem",
  [vO, N2] = ao(Jl),
  L2 = E.forwardRef((e, t) => {
    const { __scopeSelect: n, value: r, disabled: i = !1, textValue: o, ...s } = e,
      l = Tr(Jl, n),
      a = Ar(Jl, n),
      u = l.value === r,
      [c, d] = E.useState(o ?? ""),
      [f, h] = E.useState(!1),
      p = ze(t, (m) => {
        var v;
        return (v = a.itemRefCallback) == null ? void 0 : v.call(a, m, r, i);
      }),
      g = Zn(),
      x = E.useRef("touch"),
      b = () => {
        i || (l.onValueChange(r), l.onOpenChange(!1));
      };
    if (r === "")
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.",
      );
    return O.jsx(vO, {
      scope: n,
      value: r,
      disabled: i,
      textId: g,
      isSelected: u,
      onItemTextChange: E.useCallback((m) => {
        d((v) => v || ((m == null ? void 0 : m.textContent) ?? "").trim());
      }, []),
      children: O.jsx(Ja.ItemSlot, {
        scope: n,
        value: r,
        disabled: i,
        textValue: c,
        children: O.jsx(_e.div, {
          role: "option",
          "aria-labelledby": g,
          "data-highlighted": f ? "" : void 0,
          "aria-selected": u && f,
          "data-state": u ? "checked" : "unchecked",
          "aria-disabled": i || void 0,
          "data-disabled": i ? "" : void 0,
          tabIndex: i ? void 0 : -1,
          ...s,
          ref: p,
          onFocus: ge(s.onFocus, () => h(!0)),
          onBlur: ge(s.onBlur, () => h(!1)),
          onClick: ge(s.onClick, () => {
            x.current !== "mouse" && b();
          }),
          onPointerUp: ge(s.onPointerUp, () => {
            x.current === "mouse" && b();
          }),
          onPointerDown: ge(s.onPointerDown, (m) => {
            x.current = m.pointerType;
          }),
          onPointerMove: ge(s.onPointerMove, (m) => {
            var v;
            (x.current = m.pointerType),
              i
                ? (v = a.onItemLeave) == null || v.call(a)
                : x.current === "mouse" && m.currentTarget.focus({ preventScroll: !0 });
          }),
          onPointerLeave: ge(s.onPointerLeave, (m) => {
            var v;
            m.currentTarget === document.activeElement && ((v = a.onItemLeave) == null || v.call(a));
          }),
          onKeyDown: ge(s.onKeyDown, (m) => {
            var _;
            (((_ = a.searchRef) == null ? void 0 : _.current) !== "" && m.key === " ") ||
              (nO.includes(m.key) && b(), m.key === " " && m.preventDefault());
          }),
        }),
      }),
    });
  });
L2.displayName = Jl;
var Eo = "SelectItemText",
  M2 = E.forwardRef((e, t) => {
    const { __scopeSelect: n, className: r, style: i, ...o } = e,
      s = Tr(Eo, n),
      l = Ar(Eo, n),
      a = N2(Eo, n),
      u = sO(Eo, n),
      [c, d] = E.useState(null),
      f = ze(
        t,
        (b) => d(b),
        a.onItemTextChange,
        (b) => {
          var m;
          return (m = l.itemTextRefCallback) == null ? void 0 : m.call(l, b, a.value, a.disabled);
        },
      ),
      h = c == null ? void 0 : c.textContent,
      p = E.useMemo(
        () => O.jsx("option", { value: a.value, disabled: a.disabled, children: h }, a.value),
        [a.disabled, a.value, h],
      ),
      { onNativeOptionAdd: g, onNativeOptionRemove: x } = u;
    return (
      xt(() => (g(p), () => x(p)), [g, x, p]),
      O.jsxs(O.Fragment, {
        children: [
          O.jsx(_e.span, { id: a.textId, ...o, ref: f }),
          a.isSelected && s.valueNode && !s.valueNodeHasChildren ? Ni.createPortal(o.children, s.valueNode) : null,
        ],
      })
    );
  });
M2.displayName = Eo;
var O2 = "SelectItemIndicator",
  bO = E.forwardRef((e, t) => {
    const { __scopeSelect: n, ...r } = e;
    return N2(O2, n).isSelected ? O.jsx(_e.span, { "aria-hidden": !0, ...r, ref: t }) : null;
  });
bO.displayName = O2;
var xd = "SelectScrollUpButton",
  yO = E.forwardRef((e, t) => {
    const n = Ar(xd, e.__scopeSelect),
      r = Fh(xd, e.__scopeSelect),
      [i, o] = E.useState(!1),
      s = ze(t, r.onScrollButtonChange);
    return (
      xt(() => {
        if (n.viewport && n.isPositioned) {
          let l = function () {
            const u = a.scrollTop > 0;
            o(u);
          };
          const a = n.viewport;
          return l(), a.addEventListener("scroll", l), () => a.removeEventListener("scroll", l);
        }
      }, [n.viewport, n.isPositioned]),
      i
        ? O.jsx(F2, {
            ...e,
            ref: s,
            onAutoScroll: () => {
              const { viewport: l, selectedItem: a } = n;
              l && a && (l.scrollTop = l.scrollTop - a.offsetHeight);
            },
          })
        : null
    );
  });
yO.displayName = xd;
var vd = "SelectScrollDownButton",
  CO = E.forwardRef((e, t) => {
    const n = Ar(vd, e.__scopeSelect),
      r = Fh(vd, e.__scopeSelect),
      [i, o] = E.useState(!1),
      s = ze(t, r.onScrollButtonChange);
    return (
      xt(() => {
        if (n.viewport && n.isPositioned) {
          let l = function () {
            const u = a.scrollHeight - a.clientHeight,
              c = Math.ceil(a.scrollTop) < u;
            o(c);
          };
          const a = n.viewport;
          return l(), a.addEventListener("scroll", l), () => a.removeEventListener("scroll", l);
        }
      }, [n.viewport, n.isPositioned]),
      i
        ? O.jsx(F2, {
            ...e,
            ref: s,
            onAutoScroll: () => {
              const { viewport: l, selectedItem: a } = n;
              l && a && (l.scrollTop = l.scrollTop + a.offsetHeight);
            },
          })
        : null
    );
  });
CO.displayName = vd;
var F2 = E.forwardRef((e, t) => {
    const { __scopeSelect: n, onAutoScroll: r, ...i } = e,
      o = Ar("SelectScrollButton", n),
      s = E.useRef(null),
      l = Ga(n),
      a = E.useCallback(() => {
        s.current !== null && (window.clearInterval(s.current), (s.current = null));
      }, []);
    return (
      E.useEffect(() => () => a(), [a]),
      xt(() => {
        var c;
        const u = l().find((d) => d.ref.current === document.activeElement);
        (c = u == null ? void 0 : u.ref.current) == null || c.scrollIntoView({ block: "nearest" });
      }, [l]),
      O.jsx(_e.div, {
        "aria-hidden": !0,
        ...i,
        ref: t,
        style: { flexShrink: 0, ...i.style },
        onPointerDown: ge(i.onPointerDown, () => {
          s.current === null && (s.current = window.setInterval(r, 50));
        }),
        onPointerMove: ge(i.onPointerMove, () => {
          var u;
          (u = o.onItemLeave) == null || u.call(o), s.current === null && (s.current = window.setInterval(r, 50));
        }),
        onPointerLeave: ge(i.onPointerLeave, () => {
          a();
        }),
      })
    );
  }),
  _O = "SelectSeparator",
  R2 = E.forwardRef((e, t) => {
    const { __scopeSelect: n, ...r } = e;
    return O.jsx(_e.div, { "aria-hidden": !0, ...r, ref: t });
  });
R2.displayName = _O;
var bd = "SelectArrow",
  wO = E.forwardRef((e, t) => {
    const { __scopeSelect: n, ...r } = e,
      i = Za(n),
      o = Tr(bd, n),
      s = Ar(bd, n);
    return o.open && s.position === "popper" ? O.jsx(Wf, { ...i, ...r, ref: t }) : null;
  });
wO.displayName = bd;
var EO = "SelectBubbleInput",
  P2 = E.forwardRef(({ __scopeSelect: e, value: t, ...n }, r) => {
    const i = E.useRef(null),
      o = ze(r, i),
      s = XM(t);
    return (
      E.useEffect(() => {
        const l = i.current;
        if (!l) return;
        const a = window.HTMLSelectElement.prototype,
          c = Object.getOwnPropertyDescriptor(a, "value").set;
        if (s !== t && c) {
          const d = new Event("change", { bubbles: !0 });
          c.call(l, t), l.dispatchEvent(d);
        }
      }, [s, t]),
      O.jsx(_e.select, { ...n, style: { ...p2, ...n.style }, ref: o, defaultValue: t })
    );
  });
P2.displayName = EO;
function D2(e) {
  return e === "" || e === void 0;
}
function $2(e) {
  const t = xr(e),
    n = E.useRef(""),
    r = E.useRef(0),
    i = E.useCallback(
      (s) => {
        const l = n.current + s;
        t(l),
          (function a(u) {
            (n.current = u),
              window.clearTimeout(r.current),
              u !== "" && (r.current = window.setTimeout(() => a(""), 1e3));
          })(l);
      },
      [t],
    ),
    o = E.useCallback(() => {
      (n.current = ""), window.clearTimeout(r.current);
    }, []);
  return E.useEffect(() => () => window.clearTimeout(r.current), []), [n, i, o];
}
function B2(e, t, n) {
  const i = t.length > 1 && Array.from(t).every((u) => u === t[0]) ? t[0] : t,
    o = n ? e.indexOf(n) : -1;
  let s = kO(e, Math.max(o, 0));
  i.length === 1 && (s = s.filter((u) => u !== n));
  const a = s.find((u) => u.textValue.toLowerCase().startsWith(i.toLowerCase()));
  return a !== n ? a : void 0;
}
function kO(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
var H2 = m2,
  V2 = v2,
  SO = y2,
  z2 = C2,
  TO = _2,
  AO = w2,
  IO = T2,
  NO = L2,
  LO = M2,
  MO = R2,
  [qa, dP] = ir("Tooltip", [oo]),
  Ya = oo(),
  j2 = "TooltipProvider",
  OO = 700,
  yd = "tooltip.open",
  [FO, Rh] = qa(j2),
  U2 = (e) => {
    const {
        __scopeTooltip: t,
        delayDuration: n = OO,
        skipDelayDuration: r = 300,
        disableHoverableContent: i = !1,
        children: o,
      } = e,
      s = E.useRef(!0),
      l = E.useRef(!1),
      a = E.useRef(0);
    return (
      E.useEffect(() => {
        const u = a.current;
        return () => window.clearTimeout(u);
      }, []),
      O.jsx(FO, {
        scope: t,
        isOpenDelayedRef: s,
        delayDuration: n,
        onOpen: E.useCallback(() => {
          window.clearTimeout(a.current), (s.current = !1);
        }, []),
        onClose: E.useCallback(() => {
          window.clearTimeout(a.current), (a.current = window.setTimeout(() => (s.current = !0), r));
        }, [r]),
        isPointerInTransitRef: l,
        onPointerInTransitChange: E.useCallback((u) => {
          l.current = u;
        }, []),
        disableHoverableContent: i,
        children: o,
      })
    );
  };
U2.displayName = j2;
var rs = "Tooltip",
  [RO, Ts] = qa(rs),
  W2 = (e) => {
    const {
        __scopeTooltip: t,
        children: n,
        open: r,
        defaultOpen: i,
        onOpenChange: o,
        disableHoverableContent: s,
        delayDuration: l,
      } = e,
      a = Rh(rs, e.__scopeTooltip),
      u = Ya(t),
      [c, d] = E.useState(null),
      f = Zn(),
      h = E.useRef(0),
      p = s ?? a.disableHoverableContent,
      g = l ?? a.delayDuration,
      x = E.useRef(!1),
      [b, m] = Qn({
        prop: r,
        defaultProp: i ?? !1,
        onChange: (y) => {
          y ? (a.onOpen(), document.dispatchEvent(new CustomEvent(yd))) : a.onClose(), o == null || o(y);
        },
        caller: rs,
      }),
      v = E.useMemo(() => (b ? (x.current ? "delayed-open" : "instant-open") : "closed"), [b]),
      _ = E.useCallback(() => {
        window.clearTimeout(h.current), (h.current = 0), (x.current = !1), m(!0);
      }, [m]),
      k = E.useCallback(() => {
        window.clearTimeout(h.current), (h.current = 0), m(!1);
      }, [m]),
      w = E.useCallback(() => {
        window.clearTimeout(h.current),
          (h.current = window.setTimeout(() => {
            (x.current = !0), m(!0), (h.current = 0);
          }, g));
      }, [g, m]);
    return (
      E.useEffect(
        () => () => {
          h.current && (window.clearTimeout(h.current), (h.current = 0));
        },
        [],
      ),
      O.jsx(jf, {
        ...u,
        children: O.jsx(RO, {
          scope: t,
          contentId: f,
          open: b,
          stateAttribute: v,
          trigger: c,
          onTriggerChange: d,
          onTriggerEnter: E.useCallback(() => {
            a.isOpenDelayedRef.current ? w() : _();
          }, [a.isOpenDelayedRef, w, _]),
          onTriggerLeave: E.useCallback(() => {
            p ? k() : (window.clearTimeout(h.current), (h.current = 0));
          }, [k, p]),
          onOpen: _,
          onClose: k,
          disableHoverableContent: p,
          children: n,
        }),
      })
    );
  };
W2.displayName = rs;
var Cd = "TooltipTrigger",
  K2 = E.forwardRef((e, t) => {
    const { __scopeTooltip: n, ...r } = e,
      i = Ts(Cd, n),
      o = Rh(Cd, n),
      s = Ya(n),
      l = E.useRef(null),
      a = ze(t, l, i.onTriggerChange),
      u = E.useRef(!1),
      c = E.useRef(!1),
      d = E.useCallback(() => (u.current = !1), []);
    return (
      E.useEffect(() => () => document.removeEventListener("pointerup", d), [d]),
      O.jsx(Ra, {
        asChild: !0,
        ...s,
        children: O.jsx(_e.button, {
          "aria-describedby": i.open ? i.contentId : void 0,
          "data-state": i.stateAttribute,
          ...r,
          ref: a,
          onPointerMove: ge(e.onPointerMove, (f) => {
            f.pointerType !== "touch" &&
              !c.current &&
              !o.isPointerInTransitRef.current &&
              (i.onTriggerEnter(), (c.current = !0));
          }),
          onPointerLeave: ge(e.onPointerLeave, () => {
            i.onTriggerLeave(), (c.current = !1);
          }),
          onPointerDown: ge(e.onPointerDown, () => {
            i.open && i.onClose(), (u.current = !0), document.addEventListener("pointerup", d, { once: !0 });
          }),
          onFocus: ge(e.onFocus, () => {
            u.current || i.onOpen();
          }),
          onBlur: ge(e.onBlur, i.onClose),
          onClick: ge(e.onClick, i.onClose),
        }),
      })
    );
  });
K2.displayName = Cd;
var Ph = "TooltipPortal",
  [PO, DO] = qa(Ph, { forceMount: void 0 }),
  J2 = (e) => {
    const { __scopeTooltip: t, forceMount: n, children: r, container: i } = e,
      o = Ts(Ph, t);
    return O.jsx(PO, {
      scope: t,
      forceMount: n,
      children: O.jsx(Er, { present: n || o.open, children: O.jsx(Cs, { asChild: !0, container: i, children: r }) }),
    });
  };
J2.displayName = Ph;
var Ji = "TooltipContent",
  G2 = E.forwardRef((e, t) => {
    const n = DO(Ji, e.__scopeTooltip),
      { forceMount: r = n.forceMount, side: i = "top", ...o } = e,
      s = Ts(Ji, e.__scopeTooltip);
    return O.jsx(Er, {
      present: r || s.open,
      children: s.disableHoverableContent ? O.jsx(Z2, { side: i, ...o, ref: t }) : O.jsx($O, { side: i, ...o, ref: t }),
    });
  }),
  $O = E.forwardRef((e, t) => {
    const n = Ts(Ji, e.__scopeTooltip),
      r = Rh(Ji, e.__scopeTooltip),
      i = E.useRef(null),
      o = ze(t, i),
      [s, l] = E.useState(null),
      { trigger: a, onClose: u } = n,
      c = i.current,
      { onPointerInTransitChange: d } = r,
      f = E.useCallback(() => {
        l(null), d(!1);
      }, [d]),
      h = E.useCallback(
        (p, g) => {
          const x = p.currentTarget,
            b = { x: p.clientX, y: p.clientY },
            m = zO(b, x.getBoundingClientRect()),
            v = jO(b, m),
            _ = UO(g.getBoundingClientRect()),
            k = KO([...v, ..._]);
          l(k), d(!0);
        },
        [d],
      );
    return (
      E.useEffect(() => () => f(), [f]),
      E.useEffect(() => {
        if (a && c) {
          const p = (x) => h(x, c),
            g = (x) => h(x, a);
          return (
            a.addEventListener("pointerleave", p),
            c.addEventListener("pointerleave", g),
            () => {
              a.removeEventListener("pointerleave", p), c.removeEventListener("pointerleave", g);
            }
          );
        }
      }, [a, c, h, f]),
      E.useEffect(() => {
        if (s) {
          const p = (g) => {
            const x = g.target,
              b = { x: g.clientX, y: g.clientY },
              m = (a == null ? void 0 : a.contains(x)) || (c == null ? void 0 : c.contains(x)),
              v = !WO(b, s);
            m ? f() : v && (f(), u());
          };
          return document.addEventListener("pointermove", p), () => document.removeEventListener("pointermove", p);
        }
      }, [a, c, s, u, f]),
      O.jsx(Z2, { ...e, ref: o })
    );
  }),
  [BO, HO] = qa(rs, { isInside: !1 }),
  VO = f8("TooltipContent"),
  Z2 = E.forwardRef((e, t) => {
    const { __scopeTooltip: n, children: r, "aria-label": i, onEscapeKeyDown: o, onPointerDownOutside: s, ...l } = e,
      a = Ts(Ji, n),
      u = Ya(n),
      { onClose: c } = a;
    return (
      E.useEffect(() => (document.addEventListener(yd, c), () => document.removeEventListener(yd, c)), [c]),
      E.useEffect(() => {
        if (a.trigger) {
          const d = (f) => {
            const h = f.target;
            h != null && h.contains(a.trigger) && c();
          };
          return (
            window.addEventListener("scroll", d, { capture: !0 }),
            () => window.removeEventListener("scroll", d, { capture: !0 })
          );
        }
      }, [a.trigger, c]),
      O.jsx(ys, {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: o,
        onPointerDownOutside: s,
        onFocusOutside: (d) => d.preventDefault(),
        onDismiss: c,
        children: O.jsxs(Uf, {
          "data-state": a.stateAttribute,
          ...u,
          ...l,
          ref: t,
          style: {
            ...l.style,
            "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
            "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
            "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)",
          },
          children: [
            O.jsx(VO, { children: r }),
            O.jsx(BO, {
              scope: n,
              isInside: !0,
              children: O.jsx(eO, { id: a.contentId, role: "tooltip", children: i || r }),
            }),
          ],
        }),
      })
    );
  });
G2.displayName = Ji;
var q2 = "TooltipArrow",
  Y2 = E.forwardRef((e, t) => {
    const { __scopeTooltip: n, ...r } = e,
      i = Ya(n);
    return HO(q2, n).isInside ? null : O.jsx(Wf, { ...i, ...r, ref: t });
  });
Y2.displayName = q2;
function zO(e, t) {
  const n = Math.abs(t.top - e.y),
    r = Math.abs(t.bottom - e.y),
    i = Math.abs(t.right - e.x),
    o = Math.abs(t.left - e.x);
  switch (Math.min(n, r, i, o)) {
    case o:
      return "left";
    case i:
      return "right";
    case n:
      return "top";
    case r:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function jO(e, t, n = 5) {
  const r = [];
  switch (t) {
    case "top":
      r.push({ x: e.x - n, y: e.y + n }, { x: e.x + n, y: e.y + n });
      break;
    case "bottom":
      r.push({ x: e.x - n, y: e.y - n }, { x: e.x + n, y: e.y - n });
      break;
    case "left":
      r.push({ x: e.x + n, y: e.y - n }, { x: e.x + n, y: e.y + n });
      break;
    case "right":
      r.push({ x: e.x - n, y: e.y - n }, { x: e.x - n, y: e.y + n });
      break;
  }
  return r;
}
function UO(e) {
  const { top: t, right: n, bottom: r, left: i } = e;
  return [
    { x: i, y: t },
    { x: n, y: t },
    { x: n, y: r },
    { x: i, y: r },
  ];
}
function WO(e, t) {
  const { x: n, y: r } = e;
  let i = !1;
  for (let o = 0, s = t.length - 1; o < t.length; s = o++) {
    const l = t[o],
      a = t[s],
      u = l.x,
      c = l.y,
      d = a.x,
      f = a.y;
    c > r != f > r && n < ((d - u) * (r - c)) / (f - c) + u && (i = !i);
  }
  return i;
}
function KO(e) {
  const t = e.slice();
  return t.sort((n, r) => (n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0)), JO(t);
}
function JO(e) {
  if (e.length <= 1) return e.slice();
  const t = [];
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    for (; t.length >= 2; ) {
      const o = t[t.length - 1],
        s = t[t.length - 2];
      if ((o.x - s.x) * (i.y - s.y) >= (o.y - s.y) * (i.x - s.x)) t.pop();
      else break;
    }
    t.push(i);
  }
  t.pop();
  const n = [];
  for (let r = e.length - 1; r >= 0; r--) {
    const i = e[r];
    for (; n.length >= 2; ) {
      const o = n[n.length - 1],
        s = n[n.length - 2];
      if ((o.x - s.x) * (i.y - s.y) >= (o.y - s.y) * (i.x - s.x)) n.pop();
      else break;
    }
    n.push(i);
  }
  return n.pop(), t.length === 1 && n.length === 1 && t[0].x === n[0].x && t[0].y === n[0].y ? t : t.concat(n);
}
var X2 = U2,
  Q2 = W2,
  e5 = K2,
  t5 = J2,
  n5 = G2,
  GO = Y2;
const uo = C.forwardRef(({ title: e, children: t }, n) => {
    const r = qe(wr);
    return C.createElement(
      X2,
      { delayDuration: 100 },
      C.createElement(
        Q2,
        null,
        C.createElement(e5, { ref: n, asChild: !0 }, C.createElement("span", { className: D.tooltipTrigger }, t)),
        C.createElement(
          t5,
          { container: r == null ? void 0 : r.current },
          C.createElement(n5, { className: we(D.tooltipContent), sideOffset: 10 }, e),
        ),
      ),
    );
  }),
  r5 = C.forwardRef(({ children: e, className: t, ...n }, r) =>
    C.createElement(NO, { ...n, ref: r, className: we(t, D.selectItem) }, C.createElement(LO, null, e)),
  ),
  ZO = ({ title: e, placeholder: t, className: n }) => {
    const [r, i] = Le(ct, Ke);
    return C.createElement(
      uo,
      { title: e },
      C.createElement(
        V2,
        { "aria-label": t, className: we(D.selectTrigger, n), "data-toolbar-item": !0, disabled: r },
        C.createElement(SO, { placeholder: t }),
        C.createElement(z2, { className: D.selectDropdownArrow }, i("arrow_drop_down")),
      ),
    );
  },
  i5 = ({ children: e, className: t = D.selectContainer }) => {
    const n = qe(wr);
    return C.createElement(
      TO,
      { container: n == null ? void 0 : n.current },
      C.createElement(
        AO,
        {
          className: we(t, "mdxeditor-select-content"),
          onCloseAutoFocus: (r) => {
            r.preventDefault();
          },
          position: "popper",
        },
        C.createElement(IO, { "data-editor-dropdown": !0 }, e),
      ),
    );
  },
  qO = ({ children: e, title: t, className: n }) => {
    const [r, i] = Le(ct, Ke);
    return C.createElement(
      uo,
      { title: t },
      C.createElement(
        V2,
        { className: we(D.toolbarButtonSelectTrigger, n), disabled: r },
        e,
        C.createElement(z2, { className: D.selectDropdownArrow }, i("arrow_drop_down")),
      ),
    );
  },
  Xa = (e) =>
    C.createElement(
      H2,
      { value: e.value || "", onValueChange: e.onChange, disabled: e.disabled },
      C.createElement(ZO, { title: e.triggerTitle, placeholder: e.placeholder }),
      C.createElement(
        i5,
        null,
        e.items.map((t, n) =>
          t === "separator"
            ? C.createElement(MO, { key: n })
            : C.createElement(r5, { key: n, value: t.value }, t.label),
        ),
      ),
    ),
  s1 = "__EMPTY_VALUE__",
  o5 = ({ language: e, nodeKey: t, code: n, focusEmitter: r }) => {
    const i = Fe(),
      { parentEditor: o, lexicalNode: s } = hd(),
      [l, a, u, c, d] = Le(ct, _d, wd, Ke, Gl),
      f = VM(t, "codeblock", e, r),
      { setCode: h } = hd(),
      p = C.useRef(null),
      g = C.useRef(null),
      x = C.useRef(h);
    return (
      (x.current = h),
      (f.current = { getCodemirror: () => p.current }),
      C.useEffect(() => {
        const b = g.current;
        return (
          (async () => {
            const m = [
              ...a,
              h2,
              f2,
              Nd(),
              k1.of([SC]),
              kn.lineWrapping,
              kn.updateListener.of(({ state: v }) => {
                x.current(v.doc.toString());
              }),
            ];
            if ((l && m.push(jr.readOnly.of(!0)), e !== "" && u)) {
              const v = TC.find((_) => _.name === e || _.alias.includes(e) || _.extensions.includes(e));
              if (v)
                try {
                  const _ = await v.load();
                  m.push(_.extension);
                } catch {
                  console.warn("failed to load language support for", e);
                }
            }
            (b.innerHTML = ""),
              (p.current = new kn({ parent: b, state: jr.create({ doc: n, extensions: m }) })),
              b.addEventListener("keydown", l1);
          })(),
          () => {
            var m;
            (m = p.current) == null || m.destroy(), (p.current = null), b.removeEventListener("keydown", l1);
          }
        );
      }, [l, e]),
      C.createElement(
        "div",
        { className: D.codeMirrorWrapper },
        C.createElement(
          "div",
          { className: D.codeMirrorToolbar },
          C.createElement(Xa, {
            disabled: l,
            value: e,
            onChange: (b) => {
              o.update(() => {
                s.setLanguage(b === s1 ? "" : b),
                  setTimeout(() => {
                    o.update(() => {
                      s.getLatest().select();
                    });
                  });
              });
            },
            triggerTitle: i("codeBlock.selectLanguage", "Select code block language"),
            placeholder: i("codeBlock.inlineLanguage", "Language"),
            items: Object.entries(d).map(([b, m]) => ({ value: b || s1, label: m })),
          }),
          C.createElement(
            "button",
            {
              className: D.iconButton,
              type: "button",
              disabled: l,
              title: i("codeblock.delete", "Delete code block"),
              onClick: (b) => {
                b.preventDefault(),
                  o.update(() => {
                    s.remove();
                  });
              },
            },
            c("delete_small"),
          ),
        ),
        C.createElement("div", { ref: g }),
      )
    );
  };
function l1(e) {
  e.stopPropagation();
}
const Gl = ne({ js: "JavaScript", ts: "TypeScript", tsx: "TypeScript (React)", jsx: "JavaScript (React)", css: "CSS" }),
  YO = Ze((e) => {
    e.link(
      e.pipe(
        YO,
        tn(({ language: t, code: n }) => ({ code: n, language: t, meta: "" })),
      ),
      Ka,
    );
  }),
  _d = ne([]),
  wd = ne(!0),
  XO = vt({
    update(e, t) {
      e.pubIn({
        [Gl]: t == null ? void 0 : t.codeBlockLanguages,
        [_d]: (t == null ? void 0 : t.codeMirrorExtensions) ?? [],
        [wd]: (t == null ? void 0 : t.autoLoadLanguageSupport) ?? !0,
      });
    },
    init(e, t) {
      e.pubIn({
        [Gl]: t == null ? void 0 : t.codeBlockLanguages,
        [_d]: (t == null ? void 0 : t.codeMirrorExtensions) ?? [],
        [BM]: QO((t == null ? void 0 : t.codeBlockLanguages) ?? {}),
        [wd]: (t == null ? void 0 : t.autoLoadLanguageSupport) ?? !0,
      });
    },
  });
function QO(e) {
  return {
    match(t, n) {
      return !!Object.hasOwn(e, t ?? "") && !n;
    },
    priority: 1,
    Editor: o5,
  };
}
const eF = {}.hasOwnProperty,
  a1 = /^[^\t\n\r "#'.<=>`}]+$/;
ll.peek = aF;
function tF() {
  return {
    canContainEols: ["textDirective"],
    enter: {
      directiveContainer: rF,
      directiveContainerAttributes: Vu,
      directiveContainerLabel: sF,
      directiveLeaf: iF,
      directiveLeafAttributes: Vu,
      directiveText: oF,
      directiveTextAttributes: Vu,
    },
    exit: {
      directiveContainer: Ju,
      directiveContainerAttributeClassValue: ju,
      directiveContainerAttributeIdValue: zu,
      directiveContainerAttributeName: Wu,
      directiveContainerAttributeValue: Uu,
      directiveContainerAttributes: Ku,
      directiveContainerLabel: lF,
      directiveContainerName: Hu,
      directiveLeaf: Ju,
      directiveLeafAttributeClassValue: ju,
      directiveLeafAttributeIdValue: zu,
      directiveLeafAttributeName: Wu,
      directiveLeafAttributeValue: Uu,
      directiveLeafAttributes: Ku,
      directiveLeafName: Hu,
      directiveText: Ju,
      directiveTextAttributeClassValue: ju,
      directiveTextAttributeIdValue: zu,
      directiveTextAttributeName: Wu,
      directiveTextAttributeValue: Uu,
      directiveTextAttributes: Ku,
      directiveTextName: Hu,
    },
  };
}
function nF() {
  return {
    unsafe: [
      { character: "\r", inConstruct: ["leafDirectiveLabel", "containerDirectiveLabel"] },
      {
        character: `
`,
        inConstruct: ["leafDirectiveLabel", "containerDirectiveLabel"],
      },
      { before: "[^:]", character: ":", after: "[A-Za-z]", inConstruct: ["phrasing"] },
      { atBreak: !0, character: ":", after: ":" },
    ],
    handlers: { containerDirective: ll, leafDirective: ll, textDirective: ll },
  };
}
function rF(e) {
  Dh.call(this, "containerDirective", e);
}
function iF(e) {
  Dh.call(this, "leafDirective", e);
}
function oF(e) {
  Dh.call(this, "textDirective", e);
}
function Dh(e, t) {
  this.enter({ type: e, name: "", attributes: {}, children: [] }, t);
}
function Hu(e) {
  const t = this.stack[this.stack.length - 1];
  t.type === "containerDirective" || t.type === "leafDirective" || t.type, (t.name = this.sliceSerialize(e));
}
function sF(e) {
  this.enter({ type: "paragraph", data: { directiveLabel: !0 }, children: [] }, e);
}
function lF(e) {
  this.exit(e);
}
function Vu() {
  (this.data.directiveAttributes = []), this.buffer();
}
function zu(e) {
  this.data.directiveAttributes.push(["id", Ca(this.sliceSerialize(e), { attribute: !0 })]);
}
function ju(e) {
  this.data.directiveAttributes.push(["class", Ca(this.sliceSerialize(e), { attribute: !0 })]);
}
function Uu(e) {
  const t = this.data.directiveAttributes;
  t[t.length - 1][1] = Ca(this.sliceSerialize(e), { attribute: !0 });
}
function Wu(e) {
  this.data.directiveAttributes.push([this.sliceSerialize(e), ""]);
}
function Ku() {
  const e = this.data.directiveAttributes,
    t = {};
  let n = -1;
  for (; ++n < e.length; ) {
    const i = e[n];
    i[0] === "class" && t.class ? (t.class += " " + i[1]) : (t[i[0]] = i[1]);
  }
  (this.data.directiveAttributes = void 0), this.resume();
  const r = this.stack[this.stack.length - 1];
  r.type === "containerDirective" || r.type === "leafDirective" || r.type, (r.attributes = t);
}
function Ju(e) {
  this.exit(e);
}
function ll(e, t, n, r) {
  const i = n.createTracker(r),
    o = cF(e),
    s = n.enter(e.type);
  let l = i.move(o + (e.name || "")),
    a;
  if (e.type === "containerDirective") {
    const u = (e.children || [])[0];
    a = u1(u) ? u : void 0;
  } else a = e;
  if (a && a.children && a.children.length > 0) {
    const u = n.enter("label"),
      c = `${e.type}Label`,
      d = n.enter(c);
    (l += i.move("[")),
      (l += i.move(n.containerPhrasing(a, { ...i.current(), before: l, after: "]" }))),
      (l += i.move("]")),
      d(),
      u();
  }
  if (((l += i.move(uF(e, n))), e.type === "containerDirective")) {
    const u = (e.children || [])[0];
    let c = e;
    u1(u) && (c = Object.assign({}, e, { children: e.children.slice(1) })),
      c &&
        c.children &&
        c.children.length > 0 &&
        ((l += i.move(`
`)),
        (l += i.move(n.containerFlow(c, i.current())))),
      (l += i.move(
        `
` + o,
      ));
  }
  return s(), l;
}
function aF() {
  return ":";
}
function uF(e, t) {
  const n = t.options.quote || '"',
    r =
      e.type === "textDirective"
        ? [n]
        : [
            n,
            `
`,
            "\r",
          ],
    i = e.attributes || {},
    o = [];
  let s, l, a, u;
  for (u in i)
    if (eF.call(i, u) && i[u] !== void 0 && i[u] !== null) {
      const d = String(i[u]);
      if (u === "id") a = a1.test(d) ? "#" + d : c("id", d);
      else if (u === "class") {
        const f = d.split(/[\t\n\r ]+/g),
          h = [],
          p = [];
        let g = -1;
        for (; ++g < f.length; ) (a1.test(f[g]) ? p : h).push(f[g]);
        (s = h.length > 0 ? c("class", h.join(" ")) : ""), (l = p.length > 0 ? "." + p.join(".") : "");
      } else o.push(c(u, d));
    }
  return s && o.unshift(s), l && o.unshift(l), a && o.unshift(a), o.length > 0 ? "{" + o.join(" ") + "}" : "";
  function c(d, f) {
    return d + (f ? "=" + n + Q0(f, { subset: r }) + n : "");
  }
}
function u1(e) {
  return !!(e && e.type === "paragraph" && e.data && e.data.directiveLabel);
}
function cF(e) {
  let t = 0;
  return (
    e.type === "containerDirective"
      ? (ax(e, function (n, r) {
          if (n.type === "containerDirective") {
            let i = r.length,
              o = 0;
            for (; i--; ) r[i].type === "containerDirective" && o++;
            o > t && (t = o);
          }
        }),
        (t += 3))
      : e.type === "leafDirective"
        ? (t = 2)
        : (t = 1),
    ":".repeat(t)
  );
}
function $h(e, t, n, r, i, o, s, l, a, u, c, d, f, h, p) {
  let g, x;
  return b;
  function b(N) {
    return e.enter(r), e.enter(i), e.consume(N), e.exit(i), m;
  }
  function m(N) {
    return N === 35
      ? ((g = s), v(N))
      : N === 46
        ? ((g = l), v(N))
        : N === 58 || N === 95 || Wt(N)
          ? (e.enter(o), e.enter(a), e.consume(N), w)
          : p && fe(N)
            ? ve(e, m, "whitespace")(N)
            : !p && Ae(N)
              ? Kn(e, m)(N)
              : B(N);
  }
  function v(N) {
    const G = g + "Marker";
    return e.enter(o), e.enter(g), e.enter(G), e.consume(N), e.exit(G), _;
  }
  function _(N) {
    if (
      N === null ||
      N === 34 ||
      N === 35 ||
      N === 39 ||
      N === 46 ||
      N === 60 ||
      N === 61 ||
      N === 62 ||
      N === 96 ||
      N === 125 ||
      Ae(N)
    )
      return n(N);
    const G = g + "Value";
    return e.enter(G), e.consume(N), k;
  }
  function k(N) {
    if (N === null || N === 34 || N === 39 || N === 60 || N === 61 || N === 62 || N === 96) return n(N);
    if (N === 35 || N === 46 || N === 125 || Ae(N)) {
      const G = g + "Value";
      return e.exit(G), e.exit(g), e.exit(o), m(N);
    }
    return e.consume(N), k;
  }
  function w(N) {
    return N === 45 || N === 46 || N === 58 || N === 95 || Dt(N)
      ? (e.consume(N), w)
      : (e.exit(a), p && fe(N) ? ve(e, y, "whitespace")(N) : !p && Ae(N) ? Kn(e, y)(N) : y(N));
  }
  function y(N) {
    return N === 61 ? (e.enter(u), e.consume(N), e.exit(u), S) : (e.exit(o), m(N));
  }
  function S(N) {
    return N === null || N === 60 || N === 61 || N === 62 || N === 96 || N === 125 || (p && ee(N))
      ? n(N)
      : N === 34 || N === 39
        ? (e.enter(c), e.enter(f), e.consume(N), e.exit(f), (x = N), A)
        : p && fe(N)
          ? ve(e, S, "whitespace")(N)
          : !p && Ae(N)
            ? Kn(e, S)(N)
            : (e.enter(d), e.enter(h), e.consume(N), (x = void 0), T);
  }
  function T(N) {
    return N === null || N === 34 || N === 39 || N === 60 || N === 61 || N === 62 || N === 96
      ? n(N)
      : N === 125 || Ae(N)
        ? (e.exit(h), e.exit(d), e.exit(o), m(N))
        : (e.consume(N), T);
  }
  function A(N) {
    return N === x ? (e.enter(f), e.consume(N), e.exit(f), e.exit(c), e.exit(o), V) : (e.enter(d), F(N));
  }
  function F(N) {
    return N === x
      ? (e.exit(d), A(N))
      : N === null
        ? n(N)
        : ee(N)
          ? p
            ? n(N)
            : Kn(e, F)(N)
          : (e.enter(h), e.consume(N), R);
  }
  function R(N) {
    return N === x || N === null || ee(N) ? (e.exit(h), F(N)) : (e.consume(N), R);
  }
  function V(N) {
    return N === 125 || Ae(N) ? m(N) : B(N);
  }
  function B(N) {
    return N === 125 ? (e.enter(i), e.consume(N), e.exit(i), e.exit(r), t) : n(N);
  }
}
function Bh(e, t, n, r, i, o, s) {
  let l = 0,
    a = 0,
    u;
  return c;
  function c(x) {
    return e.enter(r), e.enter(i), e.consume(x), e.exit(i), d;
  }
  function d(x) {
    return x === 93 ? (e.enter(i), e.consume(x), e.exit(i), e.exit(r), t) : (e.enter(o), f(x));
  }
  function f(x) {
    if (x === 93 && !a) return g(x);
    const b = e.enter("chunkText", { contentType: "text", previous: u });
    return u && (u.next = b), (u = b), h(x);
  }
  function h(x) {
    return x === null || l > 999 || (x === 91 && ++a > 32)
      ? n(x)
      : x === 93 && !a--
        ? (e.exit("chunkText"), g(x))
        : ee(x)
          ? s
            ? n(x)
            : (e.consume(x), e.exit("chunkText"), f)
          : (e.consume(x), x === 92 ? p : h);
  }
  function p(x) {
    return x === 91 || x === 92 || x === 93 ? (e.consume(x), l++, h) : h(x);
  }
  function g(x) {
    return e.exit(o), e.enter(i), e.consume(x), e.exit(i), e.exit(r), t;
  }
}
function Hh(e, t, n, r) {
  const i = this;
  return o;
  function o(l) {
    return Wt(l) ? (e.enter(r), e.consume(l), s) : n(l);
  }
  function s(l) {
    return l === 45 || l === 95 || Dt(l)
      ? (e.consume(l), s)
      : (e.exit(r), i.previous === 45 || i.previous === 95 ? n(l) : t(l));
  }
}
const dF = { tokenize: pF, concrete: !0 },
  fF = { tokenize: gF, partial: !0 },
  hF = { tokenize: mF, partial: !0 },
  c1 = { tokenize: xF, partial: !0 };
function pF(e, t, n) {
  const r = this,
    i = r.events[r.events.length - 1],
    o = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0;
  let s = 0,
    l;
  return a;
  function a(y) {
    return (
      e.enter("directiveContainer"), e.enter("directiveContainerFence"), e.enter("directiveContainerSequence"), u(y)
    );
  }
  function u(y) {
    return y === 58
      ? (e.consume(y), s++, u)
      : s < 3
        ? n(y)
        : (e.exit("directiveContainerSequence"), Hh.call(r, e, c, n, "directiveContainerName")(y));
  }
  function c(y) {
    return y === 91 ? e.attempt(fF, d, d)(y) : d(y);
  }
  function d(y) {
    return y === 123 ? e.attempt(hF, f, f)(y) : f(y);
  }
  function f(y) {
    return ve(e, h, "whitespace")(y);
  }
  function h(y) {
    return (
      e.exit("directiveContainerFence"),
      y === null ? p(y) : ee(y) ? (r.interrupt ? t(y) : e.attempt(c1, g, p)(y)) : n(y)
    );
  }
  function p(y) {
    return e.exit("directiveContainer"), t(y);
  }
  function g(y) {
    return y === null ? (e.exit("directiveContainer"), t(y)) : (e.enter("directiveContainerContent"), x(y));
  }
  function x(y) {
    return y === null ? k(y) : e.attempt({ tokenize: w, partial: !0 }, k, o ? ve(e, b, "linePrefix", o + 1) : b)(y);
  }
  function b(y) {
    if (y === null) return k(y);
    const S = e.enter("chunkDocument", { contentType: "document", previous: l });
    return l && (l.next = S), (l = S), m(y);
  }
  function m(y) {
    if (y === null) {
      const S = e.exit("chunkDocument");
      return (r.parser.lazy[S.start.line] = !1), k(y);
    }
    return ee(y) ? e.check(c1, v, _)(y) : (e.consume(y), m);
  }
  function v(y) {
    e.consume(y);
    const S = e.exit("chunkDocument");
    return (r.parser.lazy[S.start.line] = !1), x;
  }
  function _(y) {
    const S = e.exit("chunkDocument");
    return (r.parser.lazy[S.start.line] = !1), k(y);
  }
  function k(y) {
    return e.exit("directiveContainerContent"), e.exit("directiveContainer"), t(y);
  }
  function w(y, S, T) {
    let A = 0;
    return ve(y, F, "linePrefix", 4);
    function F(B) {
      return y.enter("directiveContainerFence"), y.enter("directiveContainerSequence"), R(B);
    }
    function R(B) {
      return B === 58
        ? (y.consume(B), A++, R)
        : A < s
          ? T(B)
          : (y.exit("directiveContainerSequence"), ve(y, V, "whitespace")(B));
    }
    function V(B) {
      return B === null || ee(B) ? (y.exit("directiveContainerFence"), S(B)) : T(B);
    }
  }
}
function gF(e, t, n) {
  return Bh(e, t, n, "directiveContainerLabel", "directiveContainerLabelMarker", "directiveContainerLabelString", !0);
}
function mF(e, t, n) {
  return $h(
    e,
    t,
    n,
    "directiveContainerAttributes",
    "directiveContainerAttributesMarker",
    "directiveContainerAttribute",
    "directiveContainerAttributeId",
    "directiveContainerAttributeClass",
    "directiveContainerAttributeName",
    "directiveContainerAttributeInitializerMarker",
    "directiveContainerAttributeValueLiteral",
    "directiveContainerAttributeValue",
    "directiveContainerAttributeValueMarker",
    "directiveContainerAttributeValueData",
    !0,
  );
}
function xF(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), o;
  }
  function o(s) {
    return r.parser.lazy[r.now().line] ? n(s) : t(s);
  }
}
const vF = { tokenize: CF },
  bF = { tokenize: _F, partial: !0 },
  yF = { tokenize: wF, partial: !0 };
function CF(e, t, n) {
  const r = this;
  return i;
  function i(c) {
    return e.enter("directiveLeaf"), e.enter("directiveLeafSequence"), e.consume(c), o;
  }
  function o(c) {
    return c === 58 ? (e.consume(c), e.exit("directiveLeafSequence"), Hh.call(r, e, s, n, "directiveLeafName")) : n(c);
  }
  function s(c) {
    return c === 91 ? e.attempt(bF, l, l)(c) : l(c);
  }
  function l(c) {
    return c === 123 ? e.attempt(yF, a, a)(c) : a(c);
  }
  function a(c) {
    return ve(e, u, "whitespace")(c);
  }
  function u(c) {
    return c === null || ee(c) ? (e.exit("directiveLeaf"), t(c)) : n(c);
  }
}
function _F(e, t, n) {
  return Bh(e, t, n, "directiveLeafLabel", "directiveLeafLabelMarker", "directiveLeafLabelString", !0);
}
function wF(e, t, n) {
  return $h(
    e,
    t,
    n,
    "directiveLeafAttributes",
    "directiveLeafAttributesMarker",
    "directiveLeafAttribute",
    "directiveLeafAttributeId",
    "directiveLeafAttributeClass",
    "directiveLeafAttributeName",
    "directiveLeafAttributeInitializerMarker",
    "directiveLeafAttributeValueLiteral",
    "directiveLeafAttributeValue",
    "directiveLeafAttributeValueMarker",
    "directiveLeafAttributeValueData",
    !0,
  );
}
const EF = { tokenize: AF, previous: TF },
  kF = { tokenize: IF, partial: !0 },
  SF = { tokenize: NF, partial: !0 };
function TF(e) {
  return e !== 58 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function AF(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return (
      e.enter("directiveText"),
      e.enter("directiveTextMarker"),
      e.consume(a),
      e.exit("directiveTextMarker"),
      Hh.call(r, e, o, n, "directiveTextName")
    );
  }
  function o(a) {
    return a === 58 ? n(a) : a === 91 ? e.attempt(kF, s, s)(a) : s(a);
  }
  function s(a) {
    return a === 123 ? e.attempt(SF, l, l)(a) : l(a);
  }
  function l(a) {
    return e.exit("directiveText"), t(a);
  }
}
function IF(e, t, n) {
  return Bh(e, t, n, "directiveTextLabel", "directiveTextLabelMarker", "directiveTextLabelString");
}
function NF(e, t, n) {
  return $h(
    e,
    t,
    n,
    "directiveTextAttributes",
    "directiveTextAttributesMarker",
    "directiveTextAttribute",
    "directiveTextAttributeId",
    "directiveTextAttributeClass",
    "directiveTextAttributeName",
    "directiveTextAttributeInitializerMarker",
    "directiveTextAttributeValueLiteral",
    "directiveTextAttributeValue",
    "directiveTextAttributeValueMarker",
    "directiveTextAttributeValueData",
  );
}
function LF() {
  return { text: { 58: EF }, flow: { 58: [dF, vF] } };
}
var MF = Object.defineProperty,
  OF = (e, t, n) => (t in e ? MF(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (e[t] = n)),
  Gu = (e, t, n) => (OF(e, typeof t != "symbol" ? t + "" : t, n), n);
class As extends Cr {
  constructor(t, n) {
    super(n),
      Gu(this, "__mdastNode"),
      Gu(this, "__focusEmitter", u2()),
      Gu(this, "select", () => {
        this.__focusEmitter.publish();
      }),
      (this.__mdastNode = t);
  }
  static getType() {
    return "directive";
  }
  static clone(t) {
    return new As(structuredClone(t.__mdastNode), t.__key);
  }
  static importJSON(t) {
    return Vh(t.mdastNode);
  }
  getMdastNode() {
    return this.__mdastNode;
  }
  exportJSON() {
    return { mdastNode: structuredClone(this.__mdastNode), type: "directive", version: 1 };
  }
  createDOM() {
    return document.createElement(this.__mdastNode.type === "textDirective" ? "span" : "div");
  }
  updateDOM() {
    return !1;
  }
  setMdastNode(t) {
    this.getWritable().__mdastNode = t;
  }
  decorate(t, n) {
    return C.createElement(FF, {
      lexicalNode: this,
      mdastNode: this.getMdastNode(),
      parentEditor: t,
      config: n,
      focusEmitter: this.__focusEmitter,
    });
  }
  isInline() {
    return this.__mdastNode.type === "textDirective";
  }
  isKeyboardSelectable() {
    return !0;
  }
}
const FF = (e) => {
  const { mdastNode: t } = e,
    [n] = Le(Bi),
    r = n.find((o) => o.testNode(t));
  if (!r) throw new Error(`No descriptor found for directive ${t.name}`);
  const i = r.Editor;
  return C.createElement(
    a2.Provider,
    { value: e },
    C.createElement(i, { descriptor: r, mdastNode: t, lexicalNode: e.lexicalNode, parentEditor: e.parentEditor }),
  );
};
function Vh(e, t) {
  return new As(e, t);
}
function RF(e) {
  return e instanceof As;
}
const PF = {
    testLexicalNode: RF,
    visitLexicalNode({ actions: e, mdastParent: t, lexicalNode: n }) {
      e.appendToParent(t, n.getMdastNode());
    },
  },
  DF = ["leafDirective", "containerDirective", "textDirective"];
function $F(e) {
  return DF.includes(e.type);
}
const BF = (e) => ({
    testNode: (t, { directiveDescriptors: n }) => {
      if ($F(t)) {
        const r = n.find((i) => i.testNode(t));
        return e && !r && t.type === "textDirective" ? !0 : r !== void 0;
      }
      return !1;
    },
    visitNode({ lexicalParent: t, mdastNode: n, descriptors: r }) {
      !e || r.directiveDescriptors.some((o) => o.testNode(n)) ? t.append(Vh(n)) : t.append(Be(`:${n.name}`));
    },
  }),
  s5 = Ze((e) => {
    e.link(
      e.pipe(
        s5,
        tn((t) => () => Vh({ children: [], ...t })),
      ),
      Ma,
    );
  }),
  HF = vt({
    update: (e, t) => {
      e.pub(Bi, (t == null ? void 0 : t.directiveDescriptors) ?? []);
    },
    init: (e, t) => {
      e.pubIn({
        [Bi]: (t == null ? void 0 : t.directiveDescriptors) ?? [],
        [Vi]: tF(),
        [Hi]: LF(),
        [Gt]: BF(t == null ? void 0 : t.escapeUnknownTextDirectives),
        [fn]: As,
        [hn]: PF,
        [vs]: nF(),
      });
    },
  }),
  zh = ["note", "tip", "danger", "info", "caution"],
  VF = {
    name: "admonition",
    attributes: [],
    hasChildren: !0,
    testNode(e) {
      return zh.includes(e.name);
    },
    Editor({ mdastNode: e }) {
      const {
        config: { theme: t },
      } = Wa();
      return C.createElement(
        "div",
        { className: t.admonition[e.name] },
        C.createElement(NM, {
          block: !0,
          getContent: (n) => n.children,
          getUpdatedMdastNode: (n, r) => ({ ...n, children: r }),
        }),
      );
    },
  };
function zF(e) {
  try {
    const t = e.anchor,
      n = e.focus,
      r = e.anchor.getNode(),
      i = e.focus.getNode();
    return r === i ? r : e.isBackward() ? (jp(n) ? r : i) : jp(t) ? r : i;
  } catch {
    return null;
  }
}
function l5(e) {
  const t = J(),
    n = window.getSelection(),
    r = document.activeElement,
    i = e.getRootElement();
  if (t !== null && n !== null && i !== null && i.contains(n.anchorNode) && e.isEditable()) {
    const o = n.getRangeAt(0);
    let s;
    if (n.isCollapsed) {
      let l = n.anchorNode;
      (l == null ? void 0 : l.nodeType) == 3 && (l = l.parentNode), (s = l.getBoundingClientRect()), (s.width = 0);
    } else if (n.anchorNode === i) {
      let l = i;
      for (; l.firstElementChild != null; ) l = l.firstElementChild;
      s = l.getBoundingClientRect();
    } else s = o.getBoundingClientRect();
    return {
      top: Math.round(s.top),
      left: Math.round(s.left),
      width: Math.round(s.width),
      height: Math.round(s.height),
    };
  } else if (!r || r.className !== "link-input") return null;
  return null;
}
function jF({ url: e, title: t, onSubmit: n, onCancel: r, linkAutocompleteSuggestions: i }) {
  const { register: o, handleSubmit: s, control: l, setValue: a, reset: u } = Ad({ values: { url: e, title: t } }),
    c = Fe();
  return C.createElement(
    "form",
    {
      onSubmit: (d) => {
        s(n)(d), d.stopPropagation(), d.preventDefault();
      },
      onReset: (d) => {
        d.stopPropagation(), r();
      },
      className: we(D.multiFieldForm, D.linkDialogEditForm),
    },
    C.createElement(
      "div",
      { className: D.formField },
      C.createElement("label", { htmlFor: "link-url" }, c("createLink.url", "URL")),
      C.createElement(cy, {
        register: o,
        initialInputValue: e,
        inputName: "url",
        suggestions: i,
        setValue: a,
        control: l,
        placeholder: c("createLink.urlPlaceholder", "Select or paste an URL"),
        autofocus: !0,
      }),
    ),
    C.createElement(
      "div",
      { className: D.formField },
      C.createElement("label", { htmlFor: "link-title" }, c("createLink.title", "Title")),
      C.createElement("input", { id: "link-title", className: D.textInput, size: 40, ...o("title") }),
    ),
    C.createElement(
      "div",
      { style: { display: "flex", justifyContent: "flex-end", gap: "var(--spacing-2)" } },
      C.createElement(
        "button",
        {
          type: "submit",
          title: c("createLink.saveTooltip", "Set URL"),
          "aria-label": c("createLink.saveTooltip", "Set URL"),
          className: we(D.primaryButton),
        },
        c("dialogControls.save", "Save"),
      ),
      C.createElement(
        "button",
        {
          type: "reset",
          title: c("createLink.cancelTooltip", "Cancel change"),
          "aria-label": c("createLink.cancelTooltip", "Cancel change"),
          className: we(D.secondaryButton),
        },
        c("dialogControls.cancel", "Cancel"),
      ),
    ),
  );
}
const UF = () => {
    const [e, t, n, r, i, o] = Le(wr, je, Ke, wt, h5, p5),
      s = Ie(a5),
      l = Ie(u5),
      a = Ie(c5),
      u = Ie(d5),
      c = Ie(f5);
    C.useEffect(() => {
      const x = () => {
        t == null ||
          t.getEditorState().read(() => {
            s(!0);
          });
      };
      return (
        window.addEventListener("resize", x),
        window.addEventListener("scroll", x),
        () => {
          window.removeEventListener("resize", x), window.removeEventListener("scroll", x);
        }
      );
    }, [t, s]);
    const [d, f] = C.useState(!1),
      h = Fe();
    if (r.type === "inactive") return null;
    const p = r.rectangle,
      g = r.type === "preview" && r.url.startsWith("http");
    return C.createElement(
      Gf,
      { open: !0 },
      C.createElement(p4, {
        "data-visible": r.type === "edit",
        className: D.linkDialogAnchor,
        style: { top: `${p.top}px`, left: `${p.left}px`, width: `${p.width}px`, height: `${p.height}px` },
      }),
      C.createElement(
        Zf,
        { container: e == null ? void 0 : e.current },
        C.createElement(
          g4,
          {
            className: we(D.linkDialogPopoverContent),
            sideOffset: 5,
            onOpenAutoFocus: (x) => {
              x.preventDefault();
            },
            key: r.linkNodeKey,
          },
          r.type === "edit" &&
            C.createElement(jF, {
              url: r.url,
              title: r.title,
              onSubmit: l,
              onCancel: a.bind(null),
              linkAutocompleteSuggestions: i,
            }),
          r.type === "preview" &&
            C.createElement(
              C.Fragment,
              null,
              C.createElement(
                "a",
                {
                  className: D.linkDialogPreviewAnchor,
                  href: r.url,
                  ...(g ? { target: "_blank", rel: "noreferrer" } : {}),
                  onClick: (x) => {
                    o !== null && (x.preventDefault(), o(r.url));
                  },
                  title: g ? h("linkPreview.open", "Open {{url}} in new window", { url: r.url }) : r.url,
                },
                C.createElement("span", null, r.url),
                g && n("open_in_new"),
              ),
              C.createElement(
                Zu,
                {
                  onClick: () => {
                    u();
                  },
                  title: h("linkPreview.edit", "Edit link URL"),
                  "aria-label": h("linkPreview.edit", "Edit link URL"),
                },
                n("edit"),
              ),
              C.createElement(
                X2,
                null,
                C.createElement(
                  Q2,
                  { open: d },
                  C.createElement(
                    e5,
                    { asChild: !0 },
                    C.createElement(
                      Zu,
                      {
                        title: h("linkPreview.copyToClipboard", "Copy to clipboard"),
                        "aria-label": h("linkPreview.copyToClipboard", "Copy to clipboard"),
                        onClick: () => {
                          window.navigator.clipboard.writeText(r.url).then(() => {
                            f(!0),
                              setTimeout(() => {
                                f(!1);
                              }, 1e3);
                          });
                        },
                      },
                      n(d ? "check" : "content_copy"),
                    ),
                  ),
                  C.createElement(
                    t5,
                    { container: e == null ? void 0 : e.current },
                    C.createElement(
                      n5,
                      { className: we(D.tooltipContent), sideOffset: 5 },
                      h("linkPreview.copied", "Copied!"),
                      C.createElement(GO, null),
                    ),
                  ),
                ),
              ),
              C.createElement(
                Zu,
                {
                  title: h("linkPreview.remove", "Remove link"),
                  "aria-label": h("linkPreview.remove", "Remove link"),
                  onClick: () => {
                    c();
                  },
                },
                n("link_off"),
              ),
            ),
          C.createElement(qf, { className: D.popoverArrow }),
        ),
      ),
    );
  },
  Zu = C.forwardRef(({ className: e, ...t }, n) =>
    C.createElement("button", { className: we(D.actionButton, e), ref: n, ...t }),
  );
function Ed(e) {
  if (!e) return null;
  const t = zF(e);
  if (t === null) return null;
  const n = t.getParent();
  return zt(n) ? n : zt(t) ? t : null;
}
const a5 = Ze(),
  wt = ne({ type: "inactive" }, (e) => {
    e.pub(qo, (t) =>
      t.registerCommand(ls, () => (e.getValue(wt).type === "preview" ? (e.pub(wt, { type: "inactive" }), !0) : !1), He),
    ),
      e.sub(e.pipe(mr), (t) => {
        t !== "rich-text" && e.pub(wt, { type: "inactive" });
      }),
      e.pub(qo, (t) =>
        t.registerCommand(
          Z1,
          (n) => {
            if (n.key === "k" && (Ml ? n.metaKey : n.ctrlKey) && !e.getValue(ct)) {
              const r = J();
              return H(r) ? (e.pub(jh), n.stopPropagation(), n.preventDefault(), !0) : !1;
            }
            return !1;
          },
          wl,
        ),
      ),
      e.link(
        e.pipe(
          d5,
          Ve(wt),
          tn(([, t]) => {
            if (t.type === "preview")
              return {
                type: "edit",
                initialUrl: t.url,
                url: t.url,
                title: t.title,
                linkNodeKey: t.linkNodeKey,
                rectangle: t.rectangle,
              };
            throw new Error("Cannot switch to edit mode when not in preview mode");
          }),
        ),
        wt,
      ),
      e.sub(e.pipe(u5, Ve(je, wt, $i)), ([t, n, r, i]) => {
        var o, s;
        const l = ((o = t.url) == null ? void 0 : o.trim()) ?? "",
          a = ((s = t.title) == null ? void 0 : s.trim()) ?? "";
        if (l !== "") {
          if (i != null && i.isCollapsed()) {
            const u = a || l;
            n == null ||
              n.update(
                () => {
                  const c = Ed(i);
                  if (c) c.setURL(l), c.setTitle(a);
                  else {
                    const d = vr(l, { title: a });
                    d.append(Be(u)), Yi([d]), d.select();
                  }
                },
                { discrete: !0 },
              );
          } else n == null || n.dispatchCommand(Wi, { url: l, title: a });
          e.pub(wt, { type: "preview", linkNodeKey: r.linkNodeKey, rectangle: r.rectangle, title: a, url: l });
        } else
          r.type === "edit" && r.initialUrl !== "" && (n == null || n.dispatchCommand(Wi, null)),
            e.pub(wt, { type: "inactive" });
      }),
      e.link(
        e.pipe(
          c5,
          Ve(wt, je),
          tn(([, t, n]) => {
            if (t.type === "edit")
              return (
                n == null || n.focus(),
                t.initialUrl === ""
                  ? { type: "inactive" }
                  : { type: "preview", url: t.initialUrl, linkNodeKey: t.linkNodeKey, rectangle: t.rectangle }
              );
            throw new Error("Cannot cancel edit when not in edit mode");
          }),
        ),
        wt,
      ),
      e.link(
        e.pipe(
          e.combine($i, a5),
          Ve(je, wt, ct),
          tn(([[t], n, r, i]) => {
            if (H(t) && n && !i) {
              const o = Ed(t);
              if (o) {
                const s = l5(n);
                return s
                  ? { type: "preview", url: o.getURL(), linkNodeKey: o.getKey(), title: o.getTitle(), rectangle: s }
                  : { type: "inactive" };
              } else return { type: "inactive" };
            } else return { type: "inactive" };
          }),
        ),
        wt,
      );
  }),
  u5 = Ze(),
  c5 = Nn();
Nn();
const d5 = Nn(),
  f5 = Nn((e) => {
    e.sub(e.pipe(f5, Ve(je)), ([, t]) => {
      t == null || t.dispatchCommand(Wi, null);
    });
  }),
  jh = Nn((e) => {
    e.sub(
      e.pipe(
        jh,
        Ve($i, je),
        is(([, t]) => H(t)),
      ),
      ([, t, n]) => {
        n == null ||
          n.focus(() => {
            setTimeout(() => {
              n.getEditorState().read(() => {
                const r = Ed(t),
                  i = l5(n);
                r
                  ? e.pub(wt, {
                      type: "edit",
                      initialUrl: r.getURL(),
                      initialTitle: r.getTitle() ?? "",
                      url: r.getURL(),
                      title: r.getTitle() ?? "",
                      linkNodeKey: r.getKey(),
                      rectangle: i,
                    })
                  : e.pub(wt, {
                      type: "edit",
                      initialUrl: "",
                      initialTitle: "",
                      title: "",
                      url: "",
                      linkNodeKey: "",
                      rectangle: i,
                    });
              });
            });
          });
      },
    );
  }),
  h5 = ne([]),
  p5 = ne(null),
  g5 = ne(null, (e) => {
    e.pub(qo, (t) => {
      function n(r) {
        const [i, o] = e.getValues([ct, g5]);
        !i ||
          o === null ||
          t.update(() => {
            const s = An(r.target);
            if (s !== null) {
              const l = on(s, (a) => a instanceof or);
              l !== null && o(r, l, l.getURL());
            }
          });
      }
      return t.registerRootListener((r, i) => {
        r && r.addEventListener("click", n), i && i.removeEventListener("click", n);
      });
    });
  }),
  WF = vt({
    init(e, t) {
      e.pub(ai, (t == null ? void 0 : t.LinkDialog) ?? UF),
        e.pub(p5, (t == null ? void 0 : t.onClickLinkCallback) ?? null),
        e.pub(g5, (t == null ? void 0 : t.onReadOnlyClickLinkCallback) ?? null);
    },
    update(e, t = {}) {
      e.pub(h5, t.linkAutocompleteSuggestions ?? []);
    },
  });
function Uh(e, t) {
  return C.forwardRef((n, r) => {
    const i = we(t.className, n.className);
    return C.createElement(e, { ...t, ...n, className: i, ref: r });
  });
}
function KF(e) {
  return ({ title: t, children: n, ...r }) => C.createElement(e, { ...r }, C.createElement(uo, { title: t }, n));
}
const JF = ({ readOnly: e, children: t, className: n }) =>
    C.createElement(
      nh,
      {
        className: we("mdxeditor-toolbar", D.toolbarRoot, { [D.readOnlyToolbarRoot]: e }, n),
        ...(e ? { tabIndex: -1 } : {}),
      },
      t,
    ),
  GF = Uh(hr, { className: D.toolbarButton, "data-toolbar-item": !0 }),
  ci = KF(GF),
  m5 = Uh(ol, { className: D.toolbarToggleItem, "data-toolbar-item": !0 });
Uh(Ha, { type: "single", className: D.toolbarToggleSingleGroup });
const x5 = C.forwardRef(({ on: e, title: t, children: n, disabled: r, ...i }, o) =>
    C.createElement(
      Ha,
      { type: "single", className: D.toolbarToggleSingleGroup, ...i, value: e ? "on" : "off", ref: o },
      C.createElement(m5, { "aria-label": t, value: "on", disabled: r }, C.createElement(uo, { title: t }, n)),
    ),
  ),
  v5 = ({ items: e }) =>
    C.createElement(
      "div",
      { className: D.toolbarGroupOfGroups },
      e.map((t, n) =>
        C.createElement(
          x5,
          {
            key: n,
            title: t.title,
            on: t.active,
            onValueChange: (r) => {
              t.onChange(r === "on");
            },
            disabled: t.disabled,
          },
          t.contents,
        ),
      ),
    ),
  b5 = ({ value: e, onChange: t, className: n, ggClassName: r, items: i }) => {
    const o = Fe();
    return C.createElement(
      "div",
      { className: we(D.toolbarGroupOfGroups, r) },
      C.createElement(
        Ha,
        {
          "aria-label": o("toolbar.toggleGroup", "toggle group"),
          type: "single",
          className: we(D.toolbarToggleSingleGroup, n),
          onValueChange: t,
          value: e || "",
          onFocus: (s) => {
            s.preventDefault();
          },
        },
        i.map((s, l) =>
          C.createElement(
            m5,
            { key: l, "aria-label": s.title, value: s.value },
            C.createElement(uo, { title: s.title }, s.contents),
          ),
        ),
      ),
    );
  },
  ZF = (e) => {
    const t = qe(ct);
    return C.createElement(
      C.Fragment,
      null,
      e.items.length === 1
        ? C.createElement(
            ci,
            {
              title: e.title,
              onClick: () => {
                e.onChoose("");
              },
              disabled: t,
            },
            e.children,
          )
        : C.createElement(
            H2,
            { value: "", onValueChange: e.onChoose },
            C.createElement(qO, { title: e.title }, e.children),
            C.createElement(
              i5,
              { className: D.toolbarButtonDropdownContainer },
              e.items.map((n, r) => C.createElement(r5, { key: r, value: n.value }, n.label)),
            ),
          ),
    );
  };
function d1(e) {
  return Object.hasOwn(e, "when");
}
const qu = ({ options: e }) => {
    const t = qe(li),
      n = C.useMemo(() => {
        const r = e.find((i) => {
          if (d1(i)) {
            if (i.when(t)) return !0;
          } else return !0;
        });
        return r ? (d1(r) ? r.contents() : r.fallback()) : null;
      }, [e, t]);
    return C.createElement("div", { style: { display: "flex" } }, n);
  },
  $n = vb,
  Yu = ne(() => null),
  Xu = ne(""),
  f1 = () =>
    "This is an empty toolbar. Pass `{toolbarContents: () => { return <>toolbar components</> }}` to the toolbarPlugin to customize it.",
  qF = vt({
    init(e, t) {
      const n = (t == null ? void 0 : t.toolbarPosition) === "bottom" ? J3 : K3;
      e.pubIn({
        [Yu]: (t == null ? void 0 : t.toolbarContents) ?? f1,
        [Xu]: (t == null ? void 0 : t.toolbarClassName) ?? "",
        [n]: () => {
          const [r, i, o] = Le(Yu, ct, Xu);
          return C.createElement(JF, { className: o, readOnly: i }, r());
        },
      });
    },
    update(e, t) {
      e.pub(Yu, (t == null ? void 0 : t.toolbarContents) ?? f1),
        e.pub(Xu, (t == null ? void 0 : t.toolbarClassName) ?? "");
    },
  }),
  kd = [h2, f2, AC(), Nd(), kn.lineWrapping],
  YF = () => {
    const [e, t, n] = Le(In, ct, Wh),
      r = Ie(zi),
      i = Ie(Zo),
      o = C.useRef(null),
      s = C.useCallback(
        (l) => {
          var a;
          if (l !== null) {
            const u = [
              ...n,
              ...kd,
              kn.updateListener.of(({ state: c }) => {
                r(c.doc.toString());
              }),
              kn.focusChangeEffect.of((c, d) => (d || i(new FocusEvent("blur")), null)),
            ];
            t && u.push(jr.readOnly.of(!0)),
              (l.innerHTML = ""),
              (o.current = new kn({ parent: l, state: jr.create({ doc: e, extensions: u }) }));
          } else (a = o.current) == null || a.destroy(), (o.current = null);
        },
        [e, t, r, n, i],
      );
    return C.createElement("div", { ref: s, className: "cm-sourceView mdxeditor-source-editor" });
  };
function h1(e, t) {
  e !== void 0 && e.dispatch({ changes: { from: 0, to: e.state.doc.length, insert: t } });
}
const XF = () => {
    const e = Gi(),
      [t, n, r, i] = Le(In, Zl, ct, y5),
      o = Ie(zi),
      s = C.useRef(null),
      l = C.useRef(null),
      a = qe(Wh),
      u = Ie(Zo);
    return (
      C.useEffect(
        () =>
          e.sub(Zl, (c) => {
            var d;
            h1((d = l.current) == null ? void 0 : d.a, c);
          }),
        [e],
      ),
      C.useEffect(
        () =>
          e.sub(In, (c) => {
            var d;
            h1((d = l.current) == null ? void 0 : d.b, c);
          }),
        [e],
      ),
      C.useEffect(() => {
        const c = r || i,
          d = c
            ? { renderRevertControl: void 0, revertControls: void 0 }
            : {
                renderRevertControl: () => {
                  const f = document.createElement("button");
                  return f.classList.add("cm-merge-revert"), f.appendChild(document.createTextNode("⮕")), f;
                },
                revertControls: "a-to-b",
              };
        return (
          (l.current = new IC({
            ...d,
            parent: s.current,
            orientation: "a-b",
            gutter: !0,
            a: { doc: n, extensions: [...a, ...kd, jr.readOnly.of(!0)] },
            b: {
              doc: t,
              extensions: [
                ...a,
                ...kd,
                jr.readOnly.of(c),
                kn.updateListener.of(({ state: f }) => {
                  const h = f.doc.toString();
                  o(h);
                }),
                kn.focusChangeEffect.of((f, h) => (h || u(new FocusEvent("blur")), null)),
              ],
            },
          })),
          () => {
            var f;
            (f = l.current) == null || f.destroy(), (l.current = null);
          }
        );
      }, [o, a]),
      C.createElement("div", { ref: s, className: "mdxeditor-diff-editor" })
    );
  },
  QF = ({ children: e }) => {
    const [t, n] = Le(Go, mr);
    return C.createElement(
      "div",
      { className: "mdxeditor-diff-source-wrapper" },
      t
        ? C.createElement(
            "div",
            { className: D.markdownParseError },
            C.createElement("p", null, t.error, "."),
            C.createElement(
              "p",
              null,
              "You can fix the errors in source mode and switch to rich text mode when you are ready.",
            ),
          )
        : null,
      C.createElement(
        "div",
        {
          className: "mdxeditor-rich-text-editor",
          style: { display: n === "rich-text" && t == null ? "block" : "none" },
        },
        e,
      ),
      n === "diff" ? C.createElement(XF, null) : null,
      n === "source" ? C.createElement(YF, null) : null,
    );
  },
  Zl = ne(""),
  Wh = ne([]),
  y5 = ne(!1),
  eR = vt({
    update: (e, t) => {
      e.pub(Zl, (t == null ? void 0 : t.diffMarkdown) ?? "");
    },
    init(e, t) {
      e.pubIn({
        [Zl]: (t == null ? void 0 : t.diffMarkdown) ?? "",
        [Wh]: (t == null ? void 0 : t.codeMirrorExtensions) ?? [],
        [G3]: QF,
        [y5]: (t == null ? void 0 : t.readOnlyDiff) ?? !1,
        [mr]: (t == null ? void 0 : t.viewMode) ?? "rich-text",
      });
    },
  });
var tR = { exports: {} };
(function (e) {
  var t =
    typeof window < "u" ? window : typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope ? self : {};
  /**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   */ var n = (function (r) {
    var i = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i,
      o = 0,
      s = {},
      l = {
        manual: r.Prism && r.Prism.manual,
        disableWorkerMessageHandler: r.Prism && r.Prism.disableWorkerMessageHandler,
        util: {
          encode: function m(v) {
            return v instanceof a
              ? new a(v.type, m(v.content), v.alias)
              : Array.isArray(v)
                ? v.map(m)
                : v
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/\u00a0/g, " ");
          },
          type: function (m) {
            return Object.prototype.toString.call(m).slice(8, -1);
          },
          objId: function (m) {
            return m.__id || Object.defineProperty(m, "__id", { value: ++o }), m.__id;
          },
          clone: function m(v, _) {
            _ = _ || {};
            var k, w;
            switch (l.util.type(v)) {
              case "Object":
                if (((w = l.util.objId(v)), _[w])) return _[w];
                (k = {}), (_[w] = k);
                for (var y in v) v.hasOwnProperty(y) && (k[y] = m(v[y], _));
                return k;
              case "Array":
                return (
                  (w = l.util.objId(v)),
                  _[w]
                    ? _[w]
                    : ((k = []),
                      (_[w] = k),
                      v.forEach(function (S, T) {
                        k[T] = m(S, _);
                      }),
                      k)
                );
              default:
                return v;
            }
          },
          getLanguage: function (m) {
            for (; m; ) {
              var v = i.exec(m.className);
              if (v) return v[1].toLowerCase();
              m = m.parentElement;
            }
            return "none";
          },
          setLanguage: function (m, v) {
            (m.className = m.className.replace(RegExp(i, "gi"), "")), m.classList.add("language-" + v);
          },
          currentScript: function () {
            if (typeof document > "u") return null;
            if (document.currentScript && document.currentScript.tagName === "SCRIPT") return document.currentScript;
            try {
              throw new Error();
            } catch (k) {
              var m = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(k.stack) || [])[1];
              if (m) {
                var v = document.getElementsByTagName("script");
                for (var _ in v) if (v[_].src == m) return v[_];
              }
              return null;
            }
          },
          isActive: function (m, v, _) {
            for (var k = "no-" + v; m; ) {
              var w = m.classList;
              if (w.contains(v)) return !0;
              if (w.contains(k)) return !1;
              m = m.parentElement;
            }
            return !!_;
          },
        },
        languages: {
          plain: s,
          plaintext: s,
          text: s,
          txt: s,
          extend: function (m, v) {
            var _ = l.util.clone(l.languages[m]);
            for (var k in v) _[k] = v[k];
            return _;
          },
          insertBefore: function (m, v, _, k) {
            k = k || l.languages;
            var w = k[m],
              y = {};
            for (var S in w)
              if (w.hasOwnProperty(S)) {
                if (S == v) for (var T in _) _.hasOwnProperty(T) && (y[T] = _[T]);
                _.hasOwnProperty(S) || (y[S] = w[S]);
              }
            var A = k[m];
            return (
              (k[m] = y),
              l.languages.DFS(l.languages, function (F, R) {
                R === A && F != m && (this[F] = y);
              }),
              y
            );
          },
          DFS: function m(v, _, k, w) {
            w = w || {};
            var y = l.util.objId;
            for (var S in v)
              if (v.hasOwnProperty(S)) {
                _.call(v, S, v[S], k || S);
                var T = v[S],
                  A = l.util.type(T);
                A === "Object" && !w[y(T)]
                  ? ((w[y(T)] = !0), m(T, _, null, w))
                  : A === "Array" && !w[y(T)] && ((w[y(T)] = !0), m(T, _, S, w));
              }
          },
        },
        plugins: {},
        highlightAll: function (m, v) {
          l.highlightAllUnder(document, m, v);
        },
        highlightAllUnder: function (m, v, _) {
          var k = {
            callback: _,
            container: m,
            selector:
              'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code',
          };
          l.hooks.run("before-highlightall", k),
            (k.elements = Array.prototype.slice.apply(k.container.querySelectorAll(k.selector))),
            l.hooks.run("before-all-elements-highlight", k);
          for (var w = 0, y; (y = k.elements[w++]); ) l.highlightElement(y, v === !0, k.callback);
        },
        highlightElement: function (m, v, _) {
          var k = l.util.getLanguage(m),
            w = l.languages[k];
          l.util.setLanguage(m, k);
          var y = m.parentElement;
          y && y.nodeName.toLowerCase() === "pre" && l.util.setLanguage(y, k);
          var S = m.textContent,
            T = { element: m, language: k, grammar: w, code: S };
          function A(R) {
            (T.highlightedCode = R),
              l.hooks.run("before-insert", T),
              (T.element.innerHTML = T.highlightedCode),
              l.hooks.run("after-highlight", T),
              l.hooks.run("complete", T),
              _ && _.call(T.element);
          }
          if (
            (l.hooks.run("before-sanity-check", T),
            (y = T.element.parentElement),
            y && y.nodeName.toLowerCase() === "pre" && !y.hasAttribute("tabindex") && y.setAttribute("tabindex", "0"),
            !T.code)
          ) {
            l.hooks.run("complete", T), _ && _.call(T.element);
            return;
          }
          if ((l.hooks.run("before-highlight", T), !T.grammar)) {
            A(l.util.encode(T.code));
            return;
          }
          if (v && r.Worker) {
            var F = new Worker(l.filename);
            (F.onmessage = function (R) {
              A(R.data);
            }),
              F.postMessage(JSON.stringify({ language: T.language, code: T.code, immediateClose: !0 }));
          } else A(l.highlight(T.code, T.grammar, T.language));
        },
        highlight: function (m, v, _) {
          var k = { code: m, grammar: v, language: _ };
          if ((l.hooks.run("before-tokenize", k), !k.grammar))
            throw new Error('The language "' + k.language + '" has no grammar.');
          return (
            (k.tokens = l.tokenize(k.code, k.grammar)),
            l.hooks.run("after-tokenize", k),
            a.stringify(l.util.encode(k.tokens), k.language)
          );
        },
        tokenize: function (m, v) {
          var _ = v.rest;
          if (_) {
            for (var k in _) v[k] = _[k];
            delete v.rest;
          }
          var w = new d();
          return f(w, w.head, m), c(m, w, v, w.head, 0), p(w);
        },
        hooks: {
          all: {},
          add: function (m, v) {
            var _ = l.hooks.all;
            (_[m] = _[m] || []), _[m].push(v);
          },
          run: function (m, v) {
            var _ = l.hooks.all[m];
            if (!(!_ || !_.length)) for (var k = 0, w; (w = _[k++]); ) w(v);
          },
        },
        Token: a,
      };
    r.Prism = l;
    function a(m, v, _, k) {
      (this.type = m), (this.content = v), (this.alias = _), (this.length = (k || "").length | 0);
    }
    a.stringify = function m(v, _) {
      if (typeof v == "string") return v;
      if (Array.isArray(v)) {
        var k = "";
        return (
          v.forEach(function (A) {
            k += m(A, _);
          }),
          k
        );
      }
      var w = {
          type: v.type,
          content: m(v.content, _),
          tag: "span",
          classes: ["token", v.type],
          attributes: {},
          language: _,
        },
        y = v.alias;
      y && (Array.isArray(y) ? Array.prototype.push.apply(w.classes, y) : w.classes.push(y)), l.hooks.run("wrap", w);
      var S = "";
      for (var T in w.attributes) S += " " + T + '="' + (w.attributes[T] || "").replace(/"/g, "&quot;") + '"';
      return "<" + w.tag + ' class="' + w.classes.join(" ") + '"' + S + ">" + w.content + "</" + w.tag + ">";
    };
    function u(m, v, _, k) {
      m.lastIndex = v;
      var w = m.exec(_);
      if (w && k && w[1]) {
        var y = w[1].length;
        (w.index += y), (w[0] = w[0].slice(y));
      }
      return w;
    }
    function c(m, v, _, k, w, y) {
      for (var S in _)
        if (!(!_.hasOwnProperty(S) || !_[S])) {
          var T = _[S];
          T = Array.isArray(T) ? T : [T];
          for (var A = 0; A < T.length; ++A) {
            if (y && y.cause == S + "," + A) return;
            var F = T[A],
              R = F.inside,
              V = !!F.lookbehind,
              B = !!F.greedy,
              N = F.alias;
            if (B && !F.pattern.global) {
              var G = F.pattern.toString().match(/[imsuy]*$/)[0];
              F.pattern = RegExp(F.pattern.source, G + "g");
            }
            for (
              var U = F.pattern || F, X = k.next, te = w;
              X !== v.tail && !(y && te >= y.reach);
              te += X.value.length, X = X.next
            ) {
              var L = X.value;
              if (v.length > m.length) return;
              if (!(L instanceof a)) {
                var se = 1,
                  pe;
                if (B) {
                  if (((pe = u(U, te, m, V)), !pe || pe.index >= m.length)) break;
                  var ce = pe.index,
                    M = pe.index + pe[0].length,
                    me = te;
                  for (me += X.value.length; ce >= me; ) (X = X.next), (me += X.value.length);
                  if (((me -= X.value.length), (te = me), X.value instanceof a)) continue;
                  for (var Ee = X; Ee !== v.tail && (me < M || typeof Ee.value == "string"); Ee = Ee.next)
                    se++, (me += Ee.value.length);
                  se--, (L = m.slice(te, me)), (pe.index -= te);
                } else if (((pe = u(U, 0, L, V)), !pe)) continue;
                var ce = pe.index,
                  z = pe[0],
                  W = L.slice(0, ce),
                  Y = L.slice(ce + z.length),
                  Q = te + L.length;
                y && Q > y.reach && (y.reach = Q);
                var oe = X.prev;
                W && ((oe = f(v, oe, W)), (te += W.length)), h(v, oe, se);
                var he = new a(S, R ? l.tokenize(z, R) : z, N, z);
                if (((X = f(v, oe, he)), Y && f(v, X, Y), se > 1)) {
                  var ke = { cause: S + "," + A, reach: Q };
                  c(m, v, _, X.prev, te, ke), y && ke.reach > y.reach && (y.reach = ke.reach);
                }
              }
            }
          }
        }
    }
    function d() {
      var m = { value: null, prev: null, next: null },
        v = { value: null, prev: m, next: null };
      (m.next = v), (this.head = m), (this.tail = v), (this.length = 0);
    }
    function f(m, v, _) {
      var k = v.next,
        w = { value: _, prev: v, next: k };
      return (v.next = w), (k.prev = w), m.length++, w;
    }
    function h(m, v, _) {
      for (var k = v.next, w = 0; w < _ && k !== m.tail; w++) k = k.next;
      (v.next = k), (k.prev = v), (m.length -= w);
    }
    function p(m) {
      for (var v = [], _ = m.head.next; _ !== m.tail; ) v.push(_.value), (_ = _.next);
      return v;
    }
    if (!r.document)
      return (
        r.addEventListener &&
          (l.disableWorkerMessageHandler ||
            r.addEventListener(
              "message",
              function (m) {
                var v = JSON.parse(m.data),
                  _ = v.language,
                  k = v.code,
                  w = v.immediateClose;
                r.postMessage(l.highlight(k, l.languages[_], _)), w && r.close();
              },
              !1,
            )),
        l
      );
    var g = l.util.currentScript();
    g && ((l.filename = g.src), g.hasAttribute("data-manual") && (l.manual = !0));
    function x() {
      l.manual || l.highlightAll();
    }
    if (!l.manual) {
      var b = document.readyState;
      b === "loading" || (b === "interactive" && g && g.defer)
        ? document.addEventListener("DOMContentLoaded", x)
        : window.requestAnimationFrame
          ? window.requestAnimationFrame(x)
          : window.setTimeout(x, 16);
    }
    return l;
  })(t);
  e.exports && (e.exports = n),
    typeof Zh < "u" && (Zh.Prism = n),
    (n.languages.markup = {
      comment: { pattern: /<!--(?:(?!<!--)[\s\S])*?-->/, greedy: !0 },
      prolog: { pattern: /<\?[\s\S]+?\?>/, greedy: !0 },
      doctype: {
        pattern:
          /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: !0,
        inside: {
          "internal-subset": { pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/, lookbehind: !0, greedy: !0, inside: null },
          string: { pattern: /"[^"]*"|'[^']*'/, greedy: !0 },
          punctuation: /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          name: /[^\s<>'"]+/,
        },
      },
      cdata: { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, greedy: !0 },
      tag: {
        pattern:
          /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: !0,
        inside: {
          tag: { pattern: /^<\/?[^\s>\/]+/, inside: { punctuation: /^<\/?/, namespace: /^[^\s>\/:]+:/ } },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              punctuation: [
                { pattern: /^=/, alias: "attr-equals" },
                { pattern: /^(\s*)["']|["']$/, lookbehind: !0 },
              ],
            },
          },
          punctuation: /\/?>/,
          "attr-name": { pattern: /[^\s>\/]+/, inside: { namespace: /^[^\s>\/:]+:/ } },
        },
      },
      entity: [{ pattern: /&[\da-z]{1,8};/i, alias: "named-entity" }, /&#x?[\da-f]{1,8};/i],
    }),
    (n.languages.markup.tag.inside["attr-value"].inside.entity = n.languages.markup.entity),
    (n.languages.markup.doctype.inside["internal-subset"].inside = n.languages.markup),
    n.hooks.add("wrap", function (r) {
      r.type === "entity" && (r.attributes.title = r.content.replace(/&amp;/, "&"));
    }),
    Object.defineProperty(n.languages.markup.tag, "addInlined", {
      value: function (i, o) {
        var s = {};
        (s["language-" + o] = { pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i, lookbehind: !0, inside: n.languages[o] }),
          (s.cdata = /^<!\[CDATA\[|\]\]>$/i);
        var l = { "included-cdata": { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, inside: s } };
        l["language-" + o] = { pattern: /[\s\S]+/, inside: n.languages[o] };
        var a = {};
        (a[i] = {
          pattern: RegExp(
            /(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(
              /__/g,
              function () {
                return i;
              },
            ),
            "i",
          ),
          lookbehind: !0,
          greedy: !0,
          inside: l,
        }),
          n.languages.insertBefore("markup", "cdata", a);
      },
    }),
    Object.defineProperty(n.languages.markup.tag, "addAttribute", {
      value: function (r, i) {
        n.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(
            /(^|["'\s])/.source + "(?:" + r + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
            "i",
          ),
          lookbehind: !0,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                value: {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: !0,
                  alias: [i, "language-" + i],
                  inside: n.languages[i],
                },
                punctuation: [{ pattern: /^=/, alias: "attr-equals" }, /"|'/],
              },
            },
          },
        });
      },
    }),
    (n.languages.html = n.languages.markup),
    (n.languages.mathml = n.languages.markup),
    (n.languages.svg = n.languages.markup),
    (n.languages.xml = n.languages.extend("markup", {})),
    (n.languages.ssml = n.languages.xml),
    (n.languages.atom = n.languages.xml),
    (n.languages.rss = n.languages.xml),
    (function (r) {
      var i = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      (r.languages.css = {
        comment: /\/\*[\s\S]*?\*\//,
        atrule: {
          pattern: RegExp(
            "@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + i.source + ")*?" + /(?:;|(?=\s*\{))/.source,
          ),
          inside: {
            rule: /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: !0,
              alias: "selector",
            },
            keyword: { pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/, lookbehind: !0 },
          },
        },
        url: {
          pattern: RegExp("\\burl\\((?:" + i.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
          greedy: !0,
          inside: {
            function: /^url/i,
            punctuation: /^\(|\)$/,
            string: { pattern: RegExp("^" + i.source + "$"), alias: "url" },
          },
        },
        selector: {
          pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + i.source + ")*(?=\\s*\\{)"),
          lookbehind: !0,
        },
        string: { pattern: i, greedy: !0 },
        property: {
          pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          lookbehind: !0,
        },
        important: /!important\b/i,
        function: { pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i, lookbehind: !0 },
        punctuation: /[(){};:,]/,
      }),
        (r.languages.css.atrule.inside.rest = r.languages.css);
      var o = r.languages.markup;
      o && (o.tag.addInlined("style", "css"), o.tag.addAttribute("style", "css"));
    })(n),
    (n.languages.clike = {
      comment: [
        { pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: !0, greedy: !0 },
        { pattern: /(^|[^\\:])\/\/.*/, lookbehind: !0, greedy: !0 },
      ],
      string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: !0 },
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: !0,
        inside: { punctuation: /[.\\]/ },
      },
      keyword:
        /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
      boolean: /\b(?:false|true)\b/,
      function: /\b\w+(?=\()/,
      number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      punctuation: /[{}[\];(),.:]/,
    }),
    (n.languages.javascript = n.languages.extend("clike", {
      "class-name": [
        n.languages.clike["class-name"],
        {
          pattern:
            /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
          lookbehind: !0,
        },
      ],
      keyword: [
        { pattern: /((?:^|\})\s*)catch\b/, lookbehind: !0 },
        {
          pattern:
            /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: !0,
        },
      ],
      function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      number: {
        pattern: RegExp(
          /(^|[^\w$])/.source +
            "(?:" +
            (/NaN|Infinity/.source +
              "|" +
              /0[bB][01]+(?:_[01]+)*n?/.source +
              "|" +
              /0[oO][0-7]+(?:_[0-7]+)*n?/.source +
              "|" +
              /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source +
              "|" +
              /\d+(?:_\d+)*n/.source +
              "|" +
              /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) +
            ")" +
            /(?![\w$])/.source,
        ),
        lookbehind: !0,
      },
      operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/,
    })),
    (n.languages.javascript["class-name"][0].pattern =
      /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/),
    n.languages.insertBefore("javascript", "keyword", {
      regex: {
        pattern: RegExp(
          /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source +
            /\//.source +
            "(?:" +
            /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source +
            "|" +
            /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/
              .source +
            ")" +
            /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source,
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: !0,
            alias: "language-regex",
            inside: n.languages.regex,
          },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/,
        },
      },
      "function-variable": {
        pattern:
          /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function",
      },
      parameter: [
        {
          pattern:
            /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: !0,
          inside: n.languages.javascript,
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: !0,
          inside: n.languages.javascript,
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: !0,
          inside: n.languages.javascript,
        },
        {
          pattern:
            /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: !0,
          inside: n.languages.javascript,
        },
      ],
      constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/,
    }),
    n.languages.insertBefore("javascript", "string", {
      hashbang: { pattern: /^#!.*/, greedy: !0, alias: "comment" },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: !0,
        inside: {
          "template-punctuation": { pattern: /^`|`$/, alias: "string" },
          interpolation: {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: !0,
            inside: {
              "interpolation-punctuation": { pattern: /^\$\{|\}$/, alias: "punctuation" },
              rest: n.languages.javascript,
            },
          },
          string: /[\s\S]+/,
        },
      },
      "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: !0,
        greedy: !0,
        alias: "property",
      },
    }),
    n.languages.insertBefore("javascript", "operator", {
      "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: !0,
        alias: "property",
      },
    }),
    n.languages.markup &&
      (n.languages.markup.tag.addInlined("script", "javascript"),
      n.languages.markup.tag.addAttribute(
        /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/
          .source,
        "javascript",
      )),
    (n.languages.js = n.languages.javascript),
    (function () {
      if (typeof n > "u" || typeof document > "u") return;
      Element.prototype.matches ||
        (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector);
      var r = "Loading…",
        i = function (g, x) {
          return "✖ Error " + g + " while fetching file: " + x;
        },
        o = "✖ Error: File does not exist or is empty",
        s = {
          js: "javascript",
          py: "python",
          rb: "ruby",
          ps1: "powershell",
          psm1: "powershell",
          sh: "bash",
          bat: "batch",
          h: "c",
          tex: "latex",
        },
        l = "data-src-status",
        a = "loading",
        u = "loaded",
        c = "failed",
        d = "pre[data-src]:not([" + l + '="' + u + '"]):not([' + l + '="' + a + '"])';
      function f(g, x, b) {
        var m = new XMLHttpRequest();
        m.open("GET", g, !0),
          (m.onreadystatechange = function () {
            m.readyState == 4 &&
              (m.status < 400 && m.responseText
                ? x(m.responseText)
                : m.status >= 400
                  ? b(i(m.status, m.statusText))
                  : b(o));
          }),
          m.send(null);
      }
      function h(g) {
        var x = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(g || "");
        if (x) {
          var b = Number(x[1]),
            m = x[2],
            v = x[3];
          return m ? (v ? [b, Number(v)] : [b, void 0]) : [b, b];
        }
      }
      n.hooks.add("before-highlightall", function (g) {
        g.selector += ", " + d;
      }),
        n.hooks.add("before-sanity-check", function (g) {
          var x = g.element;
          if (x.matches(d)) {
            (g.code = ""), x.setAttribute(l, a);
            var b = x.appendChild(document.createElement("CODE"));
            b.textContent = r;
            var m = x.getAttribute("data-src"),
              v = g.language;
            if (v === "none") {
              var _ = (/\.(\w+)$/.exec(m) || [, "none"])[1];
              v = s[_] || _;
            }
            n.util.setLanguage(b, v), n.util.setLanguage(x, v);
            var k = n.plugins.autoloader;
            k && k.loadLanguages(v),
              f(
                m,
                function (w) {
                  x.setAttribute(l, u);
                  var y = h(x.getAttribute("data-range"));
                  if (y) {
                    var S = w.split(/\r\n?|\n/g),
                      T = y[0],
                      A = y[1] == null ? S.length : y[1];
                    T < 0 && (T += S.length),
                      (T = Math.max(0, Math.min(T - 1, S.length))),
                      A < 0 && (A += S.length),
                      (A = Math.max(0, Math.min(A, S.length))),
                      (w = S.slice(T, A).join(`
`)),
                      x.hasAttribute("data-start") || x.setAttribute("data-start", String(T + 1));
                  }
                  (b.textContent = w), n.highlightElement(b);
                },
                function (w) {
                  x.setAttribute(l, c), (b.textContent = w);
                },
              );
          }
        }),
        (n.plugins.fileHighlight = {
          highlight: function (x) {
            for (var b = (x || document).querySelectorAll(d), m = 0, v; (v = b[m++]); ) n.highlightElement(v);
          },
        });
      var p = !1;
      n.fileHighlight = function () {
        p ||
          (console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead."),
          (p = !0)),
          n.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    })();
})(tR);
Prism.languages.clike = {
  comment: [
    { pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: !0, greedy: !0 },
    { pattern: /(^|[^\\:])\/\/.*/, lookbehind: !0, greedy: !0 },
  ],
  string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: !0 },
  "class-name": {
    pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
    lookbehind: !0,
    inside: { punctuation: /[.\\]/ },
  },
  keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
  boolean: /\b(?:false|true)\b/,
  function: /\b\w+(?=\()/,
  number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
  operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
  punctuation: /[{}[\];(),.:]/,
};
Prism.languages.javascript = Prism.languages.extend("clike", {
  "class-name": [
    Prism.languages.clike["class-name"],
    {
      pattern:
        /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
      lookbehind: !0,
    },
  ],
  keyword: [
    { pattern: /((?:^|\})\s*)catch\b/, lookbehind: !0 },
    {
      pattern:
        /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
      lookbehind: !0,
    },
  ],
  function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
  number: {
    pattern: RegExp(
      /(^|[^\w$])/.source +
        "(?:" +
        (/NaN|Infinity/.source +
          "|" +
          /0[bB][01]+(?:_[01]+)*n?/.source +
          "|" +
          /0[oO][0-7]+(?:_[0-7]+)*n?/.source +
          "|" +
          /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source +
          "|" +
          /\d+(?:_\d+)*n/.source +
          "|" +
          /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) +
        ")" +
        /(?![\w$])/.source,
    ),
    lookbehind: !0,
  },
  operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/,
});
Prism.languages.javascript["class-name"][0].pattern =
  /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
Prism.languages.insertBefore("javascript", "keyword", {
  regex: {
    pattern: RegExp(
      /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source +
        /\//.source +
        "(?:" +
        /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source +
        "|" +
        /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/
          .source +
        ")" +
        /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source,
    ),
    lookbehind: !0,
    greedy: !0,
    inside: {
      "regex-source": {
        pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
        lookbehind: !0,
        alias: "language-regex",
        inside: Prism.languages.regex,
      },
      "regex-delimiter": /^\/|\/$/,
      "regex-flags": /^[a-z]+$/,
    },
  },
  "function-variable": {
    pattern:
      /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
    alias: "function",
  },
  parameter: [
    {
      pattern:
        /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
      lookbehind: !0,
      inside: Prism.languages.javascript,
    },
    {
      pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
      lookbehind: !0,
      inside: Prism.languages.javascript,
    },
    {
      pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
      lookbehind: !0,
      inside: Prism.languages.javascript,
    },
    {
      pattern:
        /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
      lookbehind: !0,
      inside: Prism.languages.javascript,
    },
  ],
  constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/,
});
Prism.languages.insertBefore("javascript", "string", {
  hashbang: { pattern: /^#!.*/, greedy: !0, alias: "comment" },
  "template-string": {
    pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
    greedy: !0,
    inside: {
      "template-punctuation": { pattern: /^`|`$/, alias: "string" },
      interpolation: {
        pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
        lookbehind: !0,
        inside: {
          "interpolation-punctuation": { pattern: /^\$\{|\}$/, alias: "punctuation" },
          rest: Prism.languages.javascript,
        },
      },
      string: /[\s\S]+/,
    },
  },
  "string-property": {
    pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
    lookbehind: !0,
    greedy: !0,
    alias: "property",
  },
});
Prism.languages.insertBefore("javascript", "operator", {
  "literal-property": {
    pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
    lookbehind: !0,
    alias: "property",
  },
});
Prism.languages.markup &&
  (Prism.languages.markup.tag.addInlined("script", "javascript"),
  Prism.languages.markup.tag.addAttribute(
    /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/
      .source,
    "javascript",
  ));
Prism.languages.js = Prism.languages.javascript;
Prism.languages.markup = {
  comment: { pattern: /<!--(?:(?!<!--)[\s\S])*?-->/, greedy: !0 },
  prolog: { pattern: /<\?[\s\S]+?\?>/, greedy: !0 },
  doctype: {
    pattern:
      /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
    greedy: !0,
    inside: {
      "internal-subset": { pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/, lookbehind: !0, greedy: !0, inside: null },
      string: { pattern: /"[^"]*"|'[^']*'/, greedy: !0 },
      punctuation: /^<!|>$|[[\]]/,
      "doctype-tag": /^DOCTYPE/i,
      name: /[^\s<>'"]+/,
    },
  },
  cdata: { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, greedy: !0 },
  tag: {
    pattern:
      /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
    greedy: !0,
    inside: {
      tag: { pattern: /^<\/?[^\s>\/]+/, inside: { punctuation: /^<\/?/, namespace: /^[^\s>\/:]+:/ } },
      "special-attr": [],
      "attr-value": {
        pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
        inside: {
          punctuation: [
            { pattern: /^=/, alias: "attr-equals" },
            { pattern: /^(\s*)["']|["']$/, lookbehind: !0 },
          ],
        },
      },
      punctuation: /\/?>/,
      "attr-name": { pattern: /[^\s>\/]+/, inside: { namespace: /^[^\s>\/:]+:/ } },
    },
  },
  entity: [{ pattern: /&[\da-z]{1,8};/i, alias: "named-entity" }, /&#x?[\da-f]{1,8};/i],
};
Prism.languages.markup.tag.inside["attr-value"].inside.entity = Prism.languages.markup.entity;
Prism.languages.markup.doctype.inside["internal-subset"].inside = Prism.languages.markup;
Prism.hooks.add("wrap", function (e) {
  e.type === "entity" && (e.attributes.title = e.content.replace(/&amp;/, "&"));
});
Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
  value: function (t, n) {
    var r = {};
    (r["language-" + n] = { pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i, lookbehind: !0, inside: Prism.languages[n] }),
      (r.cdata = /^<!\[CDATA\[|\]\]>$/i);
    var i = { "included-cdata": { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, inside: r } };
    i["language-" + n] = { pattern: /[\s\S]+/, inside: Prism.languages[n] };
    var o = {};
    (o[t] = {
      pattern: RegExp(
        /(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(
          /__/g,
          function () {
            return t;
          },
        ),
        "i",
      ),
      lookbehind: !0,
      greedy: !0,
      inside: i,
    }),
      Prism.languages.insertBefore("markup", "cdata", o);
  },
});
Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
  value: function (e, t) {
    Prism.languages.markup.tag.inside["special-attr"].push({
      pattern: RegExp(
        /(^|["'\s])/.source + "(?:" + e + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
        "i",
      ),
      lookbehind: !0,
      inside: {
        "attr-name": /^[^\s=]+/,
        "attr-value": {
          pattern: /=[\s\S]+/,
          inside: {
            value: {
              pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
              lookbehind: !0,
              alias: [t, "language-" + t],
              inside: Prism.languages[t],
            },
            punctuation: [{ pattern: /^=/, alias: "attr-equals" }, /"|'/],
          },
        },
      },
    });
  },
});
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;
Prism.languages.xml = Prism.languages.extend("markup", {});
Prism.languages.ssml = Prism.languages.xml;
Prism.languages.atom = Prism.languages.xml;
Prism.languages.rss = Prism.languages.xml;
(function (e) {
  var t = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
  function n(c) {
    return (
      (c = c.replace(/<inner>/g, function () {
        return t;
      })),
      RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + c + ")")
    );
  }
  var r = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source,
    i = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function () {
      return r;
    }),
    o = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
  (e.languages.markdown = e.languages.extend("markup", {})),
    e.languages.insertBefore("markdown", "prolog", {
      "front-matter-block": {
        pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          punctuation: /^---|---$/,
          "front-matter": { pattern: /\S+(?:\s+\S+)*/, alias: ["yaml", "language-yaml"], inside: e.languages.yaml },
        },
      },
      blockquote: { pattern: /^>(?:[\t ]*>)*/m, alias: "punctuation" },
      table: {
        pattern: RegExp("^" + i + o + "(?:" + i + ")*", "m"),
        inside: {
          "table-data-rows": {
            pattern: RegExp("^(" + i + o + ")(?:" + i + ")*$"),
            lookbehind: !0,
            inside: { "table-data": { pattern: RegExp(r), inside: e.languages.markdown }, punctuation: /\|/ },
          },
          "table-line": {
            pattern: RegExp("^(" + i + ")" + o + "$"),
            lookbehind: !0,
            inside: { punctuation: /\||:?-{3,}:?/ },
          },
          "table-header-row": {
            pattern: RegExp("^" + i + "$"),
            inside: {
              "table-header": { pattern: RegExp(r), alias: "important", inside: e.languages.markdown },
              punctuation: /\|/,
            },
          },
        },
      },
      code: [
        {
          pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
          lookbehind: !0,
          alias: "keyword",
        },
        {
          pattern: /^```[\s\S]*?^```$/m,
          greedy: !0,
          inside: {
            "code-block": { pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m, lookbehind: !0 },
            "code-language": { pattern: /^(```).+/, lookbehind: !0 },
            punctuation: /```/,
          },
        },
      ],
      title: [
        {
          pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
          alias: "important",
          inside: { punctuation: /==+$|--+$/ },
        },
        { pattern: /(^\s*)#.+/m, lookbehind: !0, alias: "important", inside: { punctuation: /^#+|#+$/ } },
      ],
      hr: { pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m, lookbehind: !0, alias: "punctuation" },
      list: { pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m, lookbehind: !0, alias: "punctuation" },
      "url-reference": {
        pattern:
          /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
        inside: {
          variable: { pattern: /^(!?\[)[^\]]+/, lookbehind: !0 },
          string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
          punctuation: /^[\[\]!:]|[<>]/,
        },
        alias: "url",
      },
      bold: {
        pattern: n(
          /\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source,
        ),
        lookbehind: !0,
        greedy: !0,
        inside: { content: { pattern: /(^..)[\s\S]+(?=..$)/, lookbehind: !0, inside: {} }, punctuation: /\*\*|__/ },
      },
      italic: {
        pattern: n(
          /\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source,
        ),
        lookbehind: !0,
        greedy: !0,
        inside: { content: { pattern: /(^.)[\s\S]+(?=.$)/, lookbehind: !0, inside: {} }, punctuation: /[*_]/ },
      },
      strike: {
        pattern: n(/(~~?)(?:(?!~)<inner>)+\2/.source),
        lookbehind: !0,
        greedy: !0,
        inside: { content: { pattern: /(^~~?)[\s\S]+(?=\1$)/, lookbehind: !0, inside: {} }, punctuation: /~~?/ },
      },
      "code-snippet": {
        pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
        lookbehind: !0,
        greedy: !0,
        alias: ["code", "keyword"],
      },
      url: {
        pattern: n(
          /!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source,
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          operator: /^!/,
          content: { pattern: /(^\[)[^\]]+(?=\])/, lookbehind: !0, inside: {} },
          variable: { pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/, lookbehind: !0 },
          url: { pattern: /(^\]\()[^\s)]+/, lookbehind: !0 },
          string: { pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/, lookbehind: !0 },
        },
      },
    }),
    ["url", "bold", "italic", "strike"].forEach(function (c) {
      ["url", "bold", "italic", "strike", "code-snippet"].forEach(function (d) {
        c !== d && (e.languages.markdown[c].inside.content.inside[d] = e.languages.markdown[d]);
      });
    }),
    e.hooks.add("after-tokenize", function (c) {
      if (c.language !== "markdown" && c.language !== "md") return;
      function d(f) {
        if (!(!f || typeof f == "string"))
          for (var h = 0, p = f.length; h < p; h++) {
            var g = f[h];
            if (g.type !== "code") {
              d(g.content);
              continue;
            }
            var x = g.content[1],
              b = g.content[3];
            if (x && b && x.type === "code-language" && b.type === "code-block" && typeof x.content == "string") {
              var m = x.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
              m = (/[a-z][\w-]*/i.exec(m) || [""])[0].toLowerCase();
              var v = "language-" + m;
              b.alias ? (typeof b.alias == "string" ? (b.alias = [b.alias, v]) : b.alias.push(v)) : (b.alias = [v]);
            }
          }
      }
      d(c.tokens);
    }),
    e.hooks.add("wrap", function (c) {
      if (c.type === "code-block") {
        for (var d = "", f = 0, h = c.classes.length; f < h; f++) {
          var p = c.classes[f],
            g = /language-(.+)/.exec(p);
          if (g) {
            d = g[1];
            break;
          }
        }
        var x = e.languages[d];
        if (x) c.content = e.highlight(u(c.content), x, d);
        else if (d && d !== "none" && e.plugins.autoloader) {
          var b = "md-" + new Date().valueOf() + "-" + Math.floor(Math.random() * 1e16);
          (c.attributes.id = b),
            e.plugins.autoloader.loadLanguages(d, function () {
              var m = document.getElementById(b);
              m && (m.innerHTML = e.highlight(m.textContent, e.languages[d], d));
            });
        }
      }
    });
  var s = RegExp(e.languages.markup.tag.pattern.source, "gi"),
    l = { amp: "&", lt: "<", gt: ">", quot: '"' },
    a = String.fromCodePoint || String.fromCharCode;
  function u(c) {
    var d = c.replace(s, "");
    return (
      (d = d.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function (f, h) {
        if (((h = h.toLowerCase()), h[0] === "#")) {
          var p;
          return h[1] === "x" ? (p = parseInt(h.slice(2), 16)) : (p = Number(h.slice(1))), a(p);
        } else {
          var g = l[h];
          return g || f;
        }
      })),
      d
    );
  }
  e.languages.md = e.languages.markdown;
})(Prism);
Prism.languages.c = Prism.languages.extend("clike", {
  comment: { pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/, greedy: !0 },
  string: { pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/, greedy: !0 },
  "class-name": {
    pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
    lookbehind: !0,
  },
  keyword:
    /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
  function: /\b[a-z_]\w*(?=\s*\()/i,
  number:
    /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
  operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/,
});
Prism.languages.insertBefore("c", "string", {
  char: { pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/, greedy: !0 },
});
Prism.languages.insertBefore("c", "string", {
  macro: {
    pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
    lookbehind: !0,
    greedy: !0,
    alias: "property",
    inside: {
      string: [{ pattern: /^(#\s*include\s*)<[^>]+>/, lookbehind: !0 }, Prism.languages.c.string],
      char: Prism.languages.c.char,
      comment: Prism.languages.c.comment,
      "macro-name": [
        { pattern: /(^#\s*define\s+)\w+\b(?!\()/i, lookbehind: !0 },
        { pattern: /(^#\s*define\s+)\w+\b(?=\()/i, lookbehind: !0, alias: "function" },
      ],
      directive: { pattern: /^(#\s*)[a-z]+/, lookbehind: !0, alias: "keyword" },
      "directive-hash": /^#/,
      punctuation: /##|\\(?=[\r\n])/,
      expression: { pattern: /\S[\s\S]*/, inside: Prism.languages.c },
    },
  },
});
Prism.languages.insertBefore("c", "function", {
  constant:
    /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/,
});
delete Prism.languages.c.boolean;
(function (e) {
  var t = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
  (e.languages.css = {
    comment: /\/\*[\s\S]*?\*\//,
    atrule: {
      pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + t.source + ")*?" + /(?:;|(?=\s*\{))/.source),
      inside: {
        rule: /^@[\w-]+/,
        "selector-function-argument": {
          pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
          lookbehind: !0,
          alias: "selector",
        },
        keyword: { pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/, lookbehind: !0 },
      },
    },
    url: {
      pattern: RegExp("\\burl\\((?:" + t.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
      greedy: !0,
      inside: {
        function: /^url/i,
        punctuation: /^\(|\)$/,
        string: { pattern: RegExp("^" + t.source + "$"), alias: "url" },
      },
    },
    selector: {
      pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + t.source + ")*(?=\\s*\\{)"),
      lookbehind: !0,
    },
    string: { pattern: t, greedy: !0 },
    property: {
      pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
      lookbehind: !0,
    },
    important: /!important\b/i,
    function: { pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i, lookbehind: !0 },
    punctuation: /[(){};:,]/,
  }),
    (e.languages.css.atrule.inside.rest = e.languages.css);
  var n = e.languages.markup;
  n && (n.tag.addInlined("style", "css"), n.tag.addAttribute("style", "css"));
})(Prism);
Prism.languages.objectivec = Prism.languages.extend("c", {
  string: { pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/, greedy: !0 },
  keyword:
    /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
  operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/,
});
delete Prism.languages.objectivec["class-name"];
Prism.languages.objc = Prism.languages.objectivec;
Prism.languages.sql = {
  comment: { pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/, lookbehind: !0 },
  variable: [{ pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/, greedy: !0 }, /@[\w.$]+/],
  string: { pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/, greedy: !0, lookbehind: !0 },
  identifier: {
    pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
    greedy: !0,
    lookbehind: !0,
    inside: { punctuation: /^`|`$/ },
  },
  function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
  keyword:
    /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
  boolean: /\b(?:FALSE|NULL|TRUE)\b/i,
  number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
  operator:
    /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
  punctuation: /[;[\]()`,.]/,
};
(function (e) {
  var t = (e.languages.powershell = {
    comment: [
      { pattern: /(^|[^`])<#[\s\S]*?#>/, lookbehind: !0 },
      { pattern: /(^|[^`])#.*/, lookbehind: !0 },
    ],
    string: [
      { pattern: /"(?:`[\s\S]|[^`"])*"/, greedy: !0, inside: null },
      { pattern: /'(?:[^']|'')*'/, greedy: !0 },
    ],
    namespace: /\[[a-z](?:\[(?:\[[^\]]*\]|[^\[\]])*\]|[^\[\]])*\]/i,
    boolean: /\$(?:false|true)\b/i,
    variable: /\$\w+\b/,
    function: [
      /\b(?:Add|Approve|Assert|Backup|Block|Checkpoint|Clear|Close|Compare|Complete|Compress|Confirm|Connect|Convert|ConvertFrom|ConvertTo|Copy|Debug|Deny|Disable|Disconnect|Dismount|Edit|Enable|Enter|Exit|Expand|Export|Find|ForEach|Format|Get|Grant|Group|Hide|Import|Initialize|Install|Invoke|Join|Limit|Lock|Measure|Merge|Move|New|Open|Optimize|Out|Ping|Pop|Protect|Publish|Push|Read|Receive|Redo|Register|Remove|Rename|Repair|Request|Reset|Resize|Resolve|Restart|Restore|Resume|Revoke|Save|Search|Select|Send|Set|Show|Skip|Sort|Split|Start|Step|Stop|Submit|Suspend|Switch|Sync|Tee|Test|Trace|Unblock|Undo|Uninstall|Unlock|Unprotect|Unpublish|Unregister|Update|Use|Wait|Watch|Where|Write)-[a-z]+\b/i,
      /\b(?:ac|cat|chdir|clc|cli|clp|clv|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|ebp|echo|epal|epcsv|epsn|erase|fc|fl|ft|fw|gal|gbp|gc|gci|gcs|gdr|gi|gl|gm|gp|gps|group|gsv|gu|gv|gwmi|iex|ii|ipal|ipcsv|ipsn|irm|iwmi|iwr|kill|lp|ls|measure|mi|mount|move|mp|mv|nal|ndr|ni|nv|ogv|popd|ps|pushd|pwd|rbp|rd|rdr|ren|ri|rm|rmdir|rni|rnp|rp|rv|rvpa|rwmi|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls|sort|sp|spps|spsv|start|sv|swmi|tee|trcm|type|write)\b/i,
    ],
    keyword:
      /\b(?:Begin|Break|Catch|Class|Continue|Data|Define|Do|DynamicParam|Else|ElseIf|End|Exit|Filter|Finally|For|ForEach|From|Function|If|InlineScript|Parallel|Param|Process|Return|Sequence|Switch|Throw|Trap|Try|Until|Using|Var|While|Workflow)\b/i,
    operator: {
      pattern:
        /(^|\W)(?:!|-(?:b?(?:and|x?or)|as|(?:Not)?(?:Contains|In|Like|Match)|eq|ge|gt|is(?:Not)?|Join|le|lt|ne|not|Replace|sh[lr])\b|-[-=]?|\+[+=]?|[*\/%]=?)/i,
      lookbehind: !0,
    },
    punctuation: /[|{}[\];(),.]/,
  });
  t.string[0].inside = {
    function: { pattern: /(^|[^`])\$\((?:\$\([^\r\n()]*\)|(?!\$\()[^\r\n)])*\)/, lookbehind: !0, inside: t },
    boolean: t.boolean,
    variable: t.variable,
  };
})(Prism);
Prism.languages.python = {
  comment: { pattern: /(^|[^\\])#.*/, lookbehind: !0, greedy: !0 },
  "string-interpolation": {
    pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
    greedy: !0,
    inside: {
      interpolation: {
        pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
        lookbehind: !0,
        inside: {
          "format-spec": { pattern: /(:)[^:(){}]+(?=\}$)/, lookbehind: !0 },
          "conversion-option": { pattern: /![sra](?=[:}]$)/, alias: "punctuation" },
          rest: null,
        },
      },
      string: /[\s\S]+/,
    },
  },
  "triple-quoted-string": { pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i, greedy: !0, alias: "string" },
  string: { pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i, greedy: !0 },
  function: { pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g, lookbehind: !0 },
  "class-name": { pattern: /(\bclass\s+)\w+/i, lookbehind: !0 },
  decorator: {
    pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
    lookbehind: !0,
    alias: ["annotation", "punctuation"],
    inside: { punctuation: /\./ },
  },
  keyword:
    /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
  builtin:
    /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
  boolean: /\b(?:False|None|True)\b/,
  number:
    /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
  operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
  punctuation: /[{}[\];(),.:]/,
};
Prism.languages.python["string-interpolation"].inside.interpolation.inside.rest = Prism.languages.python;
Prism.languages.py = Prism.languages.python;
(function (e) {
  for (var t = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source, n = 0; n < 2; n++)
    t = t.replace(/<self>/g, function () {
      return t;
    });
  (t = t.replace(/<self>/g, function () {
    return /[^\s\S]/.source;
  })),
    (e.languages.rust = {
      comment: [
        { pattern: RegExp(/(^|[^\\])/.source + t), lookbehind: !0, greedy: !0 },
        { pattern: /(^|[^\\:])\/\/.*/, lookbehind: !0, greedy: !0 },
      ],
      string: { pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/, greedy: !0 },
      char: { pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/, greedy: !0 },
      attribute: {
        pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
        greedy: !0,
        alias: "attr-name",
        inside: { string: null },
      },
      "closure-params": {
        pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
        lookbehind: !0,
        greedy: !0,
        inside: { "closure-punctuation": { pattern: /^\||\|$/, alias: "punctuation" }, rest: null },
      },
      "lifetime-annotation": { pattern: /'\w+/, alias: "symbol" },
      "fragment-specifier": { pattern: /(\$\w+:)[a-z]+/, lookbehind: !0, alias: "punctuation" },
      variable: /\$\w+/,
      "function-definition": { pattern: /(\bfn\s+)\w+/, lookbehind: !0, alias: "function" },
      "type-definition": { pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/, lookbehind: !0, alias: "class-name" },
      "module-declaration": [
        { pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/, lookbehind: !0, alias: "namespace" },
        {
          pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
          lookbehind: !0,
          alias: "namespace",
          inside: { punctuation: /::/ },
        },
      ],
      keyword: [
        /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
        /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/,
      ],
      function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
      macro: { pattern: /\b\w+!/, alias: "property" },
      constant: /\b[A-Z_][A-Z_\d]+\b/,
      "class-name": /\b[A-Z]\w*\b/,
      namespace: {
        pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
        inside: { punctuation: /::/ },
      },
      number:
        /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
      boolean: /\b(?:false|true)\b/,
      punctuation: /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
      operator: /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/,
    }),
    (e.languages.rust["closure-params"].inside.rest = e.languages.rust),
    (e.languages.rust.attribute.inside.string = e.languages.rust.string);
})(Prism);
Prism.languages.swift = {
  comment: {
    pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
    lookbehind: !0,
    greedy: !0,
  },
  "string-literal": [
    {
      pattern: RegExp(
        /(^|[^"#])/.source +
          "(?:" +
          /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source +
          "|" +
          /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source +
          ")" +
          /(?!["#])/.source,
      ),
      lookbehind: !0,
      greedy: !0,
      inside: {
        interpolation: { pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/, lookbehind: !0, inside: null },
        "interpolation-punctuation": { pattern: /^\)|\\\($/, alias: "punctuation" },
        punctuation: /\\(?=[\r\n])/,
        string: /[\s\S]+/,
      },
    },
    {
      pattern: RegExp(
        /(^|[^"#])(#+)/.source +
          "(?:" +
          /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source +
          "|" +
          /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source +
          ")\\2",
      ),
      lookbehind: !0,
      greedy: !0,
      inside: {
        interpolation: { pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/, lookbehind: !0, inside: null },
        "interpolation-punctuation": { pattern: /^\)|\\#+\($/, alias: "punctuation" },
        string: /[\s\S]+/,
      },
    },
  ],
  directive: {
    pattern: RegExp(
      /#/.source +
        "(?:" +
        (/(?:elseif|if)\b/.source +
          "(?:[ 	]*" +
          /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/
            .source +
          ")+") +
        "|" +
        /(?:else|endif)\b/.source +
        ")",
    ),
    alias: "property",
    inside: {
      "directive-name": /^#\w+/,
      boolean: /\b(?:false|true)\b/,
      number: /\b\d+(?:\.\d+)*\b/,
      operator: /!|&&|\|\||[<>]=?/,
      punctuation: /[(),]/,
    },
  },
  literal: {
    pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
    alias: "constant",
  },
  "other-directive": { pattern: /#\w+\b/, alias: "property" },
  attribute: { pattern: /@\w+/, alias: "atrule" },
  "function-definition": { pattern: /(\bfunc\s+)\w+/, lookbehind: !0, alias: "function" },
  label: {
    pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
    lookbehind: !0,
    alias: "important",
  },
  keyword:
    /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
  boolean: /\b(?:false|true)\b/,
  nil: { pattern: /\bnil\b/, alias: "constant" },
  "short-argument": /\$\d+\b/,
  omit: { pattern: /\b_\b/, alias: "keyword" },
  number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
  "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
  function: /\b[a-z_]\w*(?=\s*\()/i,
  constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
  operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
  punctuation: /[{}[\]();,.:\\]/,
};
Prism.languages.swift["string-literal"].forEach(function (e) {
  e.inside.interpolation.inside = Prism.languages.swift;
});
(function (e) {
  (e.languages.typescript = e.languages.extend("javascript", {
    "class-name": {
      pattern:
        /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
      lookbehind: !0,
      greedy: !0,
      inside: null,
    },
    builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/,
  })),
    e.languages.typescript.keyword.push(
      /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
      /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
      /\btype\b(?=\s*(?:[\{*]|$))/,
    ),
    delete e.languages.typescript.parameter,
    delete e.languages.typescript["literal-property"];
  var t = e.languages.extend("typescript", {});
  delete t["class-name"],
    (e.languages.typescript["class-name"].inside = t),
    e.languages.insertBefore("typescript", "function", {
      decorator: {
        pattern: /@[$\w\xA0-\uFFFF]+/,
        inside: { at: { pattern: /^@/, alias: "operator" }, function: /^[\s\S]+/ },
      },
      "generic-function": {
        pattern:
          /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
        greedy: !0,
        inside: {
          function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
          generic: { pattern: /<[\s\S]+/, alias: "class-name", inside: t },
        },
      },
    }),
    (e.languages.ts = e.languages.typescript);
})(Prism);
(function (e) {
  var t =
      /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/,
    n = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source,
    r = {
      pattern: RegExp(/(^|[^\w.])/.source + n + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
      lookbehind: !0,
      inside: {
        namespace: { pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/, inside: { punctuation: /\./ } },
        punctuation: /\./,
      },
    };
  (e.languages.java = e.languages.extend("clike", {
    string: { pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/, lookbehind: !0, greedy: !0 },
    "class-name": [
      r,
      {
        pattern: RegExp(
          /(^|[^\w.])/.source + n + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source,
        ),
        lookbehind: !0,
        inside: r.inside,
      },
      {
        pattern: RegExp(
          /(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source +
            n +
            /[A-Z]\w*\b/.source,
        ),
        lookbehind: !0,
        inside: r.inside,
      },
    ],
    keyword: t,
    function: [e.languages.clike.function, { pattern: /(::\s*)[a-z_]\w*/, lookbehind: !0 }],
    number:
      /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
    operator: { pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m, lookbehind: !0 },
    constant: /\b[A-Z][A-Z_\d]+\b/,
  })),
    e.languages.insertBefore("java", "string", {
      "triple-quoted-string": {
        pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
        greedy: !0,
        alias: "string",
      },
      char: { pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/, greedy: !0 },
    }),
    e.languages.insertBefore("java", "class-name", {
      annotation: { pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/, lookbehind: !0, alias: "punctuation" },
      generics: {
        pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
        inside: { "class-name": r, keyword: t, punctuation: /[<>(),.:]/, operator: /[?&|]/ },
      },
      import: [
        {
          pattern: RegExp(/(\bimport\s+)/.source + n + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
          lookbehind: !0,
          inside: { namespace: r.inside.namespace, punctuation: /\./, operator: /\*/, "class-name": /\w+/ },
        },
        {
          pattern: RegExp(/(\bimport\s+static\s+)/.source + n + /(?:\w+|\*)(?=\s*;)/.source),
          lookbehind: !0,
          alias: "static",
          inside: {
            namespace: r.inside.namespace,
            static: /\b\w+$/,
            punctuation: /\./,
            operator: /\*/,
            "class-name": /\w+/,
          },
        },
      ],
      namespace: {
        pattern: RegExp(
          /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(
            /<keyword>/g,
            function () {
              return t.source;
            },
          ),
        ),
        lookbehind: !0,
        inside: { punctuation: /\./ },
      },
    });
})(Prism);
(function (e) {
  var t =
      /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/,
    n = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function () {
      return t.source;
    });
  (e.languages.cpp = e.languages.extend("c", {
    "class-name": [
      {
        pattern: RegExp(
          /(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function () {
            return t.source;
          }),
        ),
        lookbehind: !0,
      },
      /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
      /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
      /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/,
    ],
    keyword: t,
    number: {
      pattern:
        /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
      greedy: !0,
    },
    operator:
      />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
    boolean: /\b(?:false|true)\b/,
  })),
    e.languages.insertBefore("cpp", "string", {
      module: {
        pattern: RegExp(
          /(\b(?:import|module)\s+)/.source +
            "(?:" +
            /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source +
            "|" +
            /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function () {
              return n;
            }) +
            ")",
        ),
        lookbehind: !0,
        greedy: !0,
        inside: { string: /^[<"][\s\S]+/, operator: /:/, punctuation: /\./ },
      },
      "raw-string": { pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/, alias: "string", greedy: !0 },
    }),
    e.languages.insertBefore("cpp", "keyword", {
      "generic-function": {
        pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
        inside: { function: /^\w+/, generic: { pattern: /<[\s\S]+/, alias: "class-name", inside: e.languages.cpp } },
      },
    }),
    e.languages.insertBefore("cpp", "operator", { "double-colon": { pattern: /::/, alias: "punctuation" } }),
    e.languages.insertBefore("cpp", "class-name", {
      "base-clause": {
        pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
        lookbehind: !0,
        greedy: !0,
        inside: e.languages.extend("cpp", {}),
      },
    }),
    e.languages.insertBefore(
      "inside",
      "double-colon",
      { "class-name": /\b[a-z_]\w*\b(?!\s*::)/i },
      e.languages.cpp["base-clause"],
    );
})(Prism);
const nR = globalThis.Prism || window.Prism,
  p1 = (e) => {
    try {
      return !!e && nR.languages.hasOwnProperty(e);
    } catch {
      return !1;
    }
  };
function C5(e, t) {
  for (const n of e.childNodes) {
    if (We(n) && n.tagName === t) return !0;
    C5(n, t);
  }
  return !1;
}
const ko = "data-language",
  Zs = "data-highlight-language";
class Is extends dn {
  static getType() {
    return "code";
  }
  static clone(t) {
    return new Is(t.__language, t.__key);
  }
  constructor(t, n) {
    super(n), (this.__language = t || void 0), (this.__isSyntaxHighlightSupported = p1(t));
  }
  createDOM(t) {
    const n = document.createElement("code");
    un(n, t.theme.code), n.setAttribute("spellcheck", "false");
    const r = this.getLanguage();
    return r && (n.setAttribute(ko, r), this.getIsSyntaxHighlightSupported() && n.setAttribute(Zs, r)), n;
  }
  updateDOM(t, n, r) {
    const i = this.__language,
      o = t.__language;
    return (
      i
        ? i !== o && (n.setAttribute(ko, i), this.__isSyntaxHighlightSupported && n.setAttribute(Zs, i))
        : o && (n.removeAttribute(ko), t.__isSyntaxHighlightSupported && n.removeAttribute(Zs)),
      !1
    );
  }
  exportDOM(t) {
    const n = document.createElement("pre");
    un(n, t._config.theme.code), n.setAttribute("spellcheck", "false");
    const r = this.getLanguage();
    return r && (n.setAttribute(ko, r), this.getIsSyntaxHighlightSupported() && n.setAttribute(Zs, r)), { element: n };
  }
  static importDOM() {
    return {
      code: (t) =>
        t.textContent != null && (/\r?\n/.test(t.textContent) || C5(t, "BR")) ? { conversion: g1, priority: 1 } : null,
      div: () => ({ conversion: rR, priority: 1 }),
      pre: () => ({ conversion: g1, priority: 0 }),
      table: (t) => (Qu(t) ? { conversion: iR, priority: 3 } : null),
      td: (t) => {
        const n = t,
          r = n.closest("table");
        return n.classList.contains("js-file-line") || (r && Qu(r)) ? { conversion: m1, priority: 3 } : null;
      },
      tr: (t) => {
        const n = t.closest("table");
        return n && Qu(n) ? { conversion: m1, priority: 3 } : null;
      },
    };
  }
  static importJSON(t) {
    return Jn().updateFromJSON(t);
  }
  updateFromJSON(t) {
    return super.updateFromJSON(t).setLanguage(t.language);
  }
  exportJSON() {
    return { ...super.exportJSON(), language: this.getLanguage() };
  }
  insertNewAfter(t, n = !0) {
    const r = this.getChildren(),
      i = r.length;
    if (
      i >= 2 &&
      r[i - 1].getTextContent() ===
        `
` &&
      r[i - 2].getTextContent() ===
        `
` &&
      t.isCollapsed() &&
      t.anchor.key === this.__key &&
      t.anchor.offset === i
    ) {
      r[i - 1].remove(), r[i - 2].remove();
      const a = Se();
      return this.insertAfter(a, n), a;
    }
    const { anchor: o, focus: s } = t,
      l = (o.isBefore(s) ? o : s).getNode();
    if (Z(l)) {
      let a = sR(l);
      const u = [];
      for (;;)
        if (ua(a)) u.push(Zi()), (a = a.getNextSibling());
        else {
          if (!k5(a)) break;
          {
            let x = 0;
            const b = a.getTextContent(),
              m = a.getTextContentSize();
            for (; x < m && b[x] === " "; ) x++;
            if ((x !== 0 && u.push(E5(" ".repeat(x))), x !== m)) break;
            a = a.getNextSibling();
          }
        }
      const c = l.splitText(o.offset)[0],
        d = o.offset === 0 ? 0 : 1,
        f = c.getIndexWithinParent() + d,
        h = l.getParentOrThrow(),
        p = [sn(), ...u];
      h.splice(f, 0, p);
      const g = u[u.length - 1];
      g ? g.select() : o.offset === 0 ? c.selectPrevious() : c.getNextSibling().selectNext(0, 0);
    }
    if (Kh(l)) {
      const { offset: a } = t.anchor;
      l.splice(a, 0, [sn()]), l.select(a + 1, a + 1);
    }
    return null;
  }
  canIndent() {
    return !1;
  }
  collapseAtStart() {
    const t = Se();
    return this.getChildren().forEach((n) => t.append(n)), this.replace(t), !0;
  }
  setLanguage(t) {
    const n = this.getWritable();
    return (n.__language = t || void 0), (n.__isSyntaxHighlightSupported = p1(t)), n;
  }
  getLanguage() {
    return this.getLatest().__language;
  }
  getIsSyntaxHighlightSupported() {
    return this.getLatest().__isSyntaxHighlightSupported;
  }
}
function Jn(e) {
  return Mt(new Is(e));
}
function Kh(e) {
  return e instanceof Is;
}
function g1(e) {
  return { node: Jn(e.getAttribute(ko)) };
}
function rR(e) {
  const t = e,
    n = x1(t);
  return n ||
    (function (r) {
      let i = r.parentElement;
      for (; i !== null; ) {
        if (x1(i)) return !0;
        i = i.parentElement;
      }
      return !1;
    })(t)
    ? { node: n ? Jn() : null }
    : { node: null };
}
function iR() {
  return { node: Jn() };
}
function m1() {
  return { node: null };
}
function x1(e) {
  return e.style.fontFamily.match("monospace") !== null;
}
function Qu(e) {
  return e.classList.contains("js-file-line-container");
}
let _5 = class w5 extends Ln {
  constructor(t = "", n, r) {
    super(t, r), (this.__highlightType = n);
  }
  static getType() {
    return "code-highlight";
  }
  static clone(t) {
    return new w5(t.__text, t.__highlightType || void 0, t.__key);
  }
  getHighlightType() {
    return this.getLatest().__highlightType;
  }
  setHighlightType(t) {
    const n = this.getWritable();
    return (n.__highlightType = t || void 0), n;
  }
  canHaveFormat() {
    return !1;
  }
  createDOM(t) {
    const n = super.createDOM(t),
      r = ec(t.theme, this.__highlightType);
    return un(n, r), n;
  }
  updateDOM(t, n, r) {
    const i = super.updateDOM(t, n, r),
      o = ec(r.theme, t.__highlightType),
      s = ec(r.theme, this.__highlightType);
    return o !== s && (o && va(n, o), s && un(n, s)), i;
  }
  static importJSON(t) {
    return E5().updateFromJSON(t);
  }
  updateFromJSON(t) {
    return super.updateFromJSON(t).setHighlightType(t.highlightType);
  }
  exportJSON() {
    return { ...super.exportJSON(), highlightType: this.getHighlightType() };
  }
  setFormat(t) {
    return this;
  }
  isParentRequired() {
    return !0;
  }
  createParentElementNode() {
    return Jn();
  }
};
function ec(e, t) {
  return t && e && e.codeHighlight && e.codeHighlight[t];
}
function E5(e = "", t) {
  return Mt(new _5(e, t));
}
function k5(e) {
  return e instanceof _5;
}
function oR(e, t) {
  let n = e;
  for (let r = nt(e, t); r && (k5(r.origin) || ua(r.origin)); r = xw(r)) n = r.origin;
  return n;
}
function sR(e) {
  return oR(e, "previous");
}
function Sd(e, t) {
  const n = {};
  for (const r of e) {
    const i = t(r);
    i && (n[i] ? n[i].push(r) : (n[i] = [r]));
  }
  return n;
}
function lR(e) {
  const t = Sd(e, (n) => n.type);
  return {
    element: t.element || [],
    multilineElement: t["multiline-element"] || [],
    textFormat: t["text-format"] || [],
    textMatch: t["text-match"] || [],
  };
}
const v1 = /[!-/:-@[-`{-~\s]/;
function aR(e) {
  return Z(e) && !e.hasFormat("code");
}
function uR(e, ...t) {
  const n = new URL("https://lexical.dev/docs/error"),
    r = new URLSearchParams();
  r.append("code", e);
  for (const i of t) r.append("v", i);
  throw (
    ((n.search = r.toString()),
    Error(
      `Minified Lexical error #${e}; visit ${n.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`,
    ))
  );
}
function b1(e, t, n) {
  const r = n.length;
  for (let i = t; i >= r; i--) {
    const o = i - r;
    if (S5(e, o, n, 0, r) && e[o + r] !== " ") return o;
  }
  return -1;
}
function S5(e, t, n, r, i) {
  for (let o = 0; o < i; o++) if (e[t + o] !== n[r + o]) return !1;
  return !0;
}
function cR(e, t = H5) {
  const n = lR(t),
    r = Sd(n.textFormat, ({ tag: s }) => s[s.length - 1]),
    i = Sd(n.textMatch, ({ trigger: s }) => s);
  for (const s of t) {
    const l = s.type;
    if (l === "element" || l === "text-match" || l === "multiline-element") {
      const a = s.dependencies;
      for (const u of a) e.hasNode(u) || uR(173, u.getType());
    }
  }
  const o = (s, l, a) => {
    (function (u, c, d, f) {
      const h = u.getParent();
      if (!tt(h) || u.getFirstChild() !== c) return !1;
      const p = c.getTextContent();
      if (p[d - 1] !== " ") return !1;
      for (const { regExp: g, replace: x } of f) {
        const b = p.match(g);
        if (b && b[0].length === (b[0].endsWith(" ") ? d : d - 1)) {
          const m = c.getNextSiblings(),
            [v, _] = c.splitText(d);
          if (x(u, _ ? [_, ...m] : m, b, !1) !== !1) return v.remove(), !0;
        }
      }
      return !1;
    })(s, l, a, n.element) ||
      (function (u, c, d, f) {
        const h = u.getParent();
        if (!tt(h) || u.getFirstChild() !== c) return !1;
        const p = c.getTextContent();
        if (p[d - 1] !== " ") return !1;
        for (const { regExpStart: g, replace: x, regExpEnd: b } of f) {
          if ((b && !("optional" in b)) || (b && "optional" in b && !b.optional)) continue;
          const m = p.match(g);
          if (m && m[0].length === (m[0].endsWith(" ") ? d : d - 1)) {
            const v = c.getNextSiblings(),
              [_, k] = c.splitText(d);
            if (x(u, k ? [k, ...v] : v, m, null, null, !1) !== !1) return _.remove(), !0;
          }
        }
        return !1;
      })(s, l, a, n.multilineElement) ||
      (function (u, c, d) {
        let f = u.getTextContent();
        const h = d[f[c - 1]];
        if (h == null) return !1;
        c < f.length && (f = f.slice(0, c));
        for (const p of h) {
          if (!p.replace || !p.regExp) continue;
          const g = f.match(p.regExp);
          if (g === null) continue;
          const x = g.index || 0,
            b = x + g[0].length;
          let m;
          return (
            x === 0 ? ([m] = u.splitText(b)) : ([, m] = u.splitText(x, b)), m.selectNext(0, 0), p.replace(m, g), !0
          );
        }
        return !1;
      })(l, a, i) ||
      (function (u, c, d) {
        const f = u.getTextContent(),
          h = c - 1,
          p = f[h],
          g = d[p];
        if (!g) return !1;
        for (const x of g) {
          const { tag: b } = x,
            m = b.length,
            v = h - m + 1;
          if ((m > 1 && !S5(f, v, b, 0, m)) || f[v - 1] === " ") continue;
          const _ = f[h + 1];
          if (x.intraword === !1 && _ && !v1.test(_)) continue;
          const k = u;
          let w = k,
            y = b1(f, v, b),
            S = w;
          for (; y < 0 && (S = S.getPreviousSibling()) && !rn(S); )
            if (Z(S)) {
              if (S.hasFormat("code")) continue;
              const U = S.getTextContent();
              (w = S), (y = b1(U, U.length, b));
            }
          if (y < 0 || (w === k && y + m === v)) continue;
          const T = w.getTextContent();
          if (y > 0 && T[y - 1] === p) continue;
          const A = T[y - 1];
          if (x.intraword === !1 && A && !v1.test(A)) continue;
          const F = k.getTextContent(),
            R = F.slice(0, v) + F.slice(h + 1);
          k.setTextContent(R);
          const V = w === k ? R : T;
          w.setTextContent(V.slice(0, y) + V.slice(y + m));
          const B = J(),
            N = qi();
          Ye(N);
          const G = h - m * (w === k ? 2 : 1) + 1;
          N.anchor.set(w.__key, y, "text"), N.focus.set(k.__key, G, "text");
          for (const U of x.format) N.hasFormat(U) || N.formatText(U);
          N.anchor.set(N.focus.key, N.focus.offset, N.focus.type);
          for (const U of x.format) N.hasFormat(U) && N.toggleFormat(U);
          return H(B) && (N.format = B.format), !0;
        }
      })(l, a, r);
  };
  return e.registerUpdateListener(({ tags: s, dirtyLeaves: l, editorState: a, prevEditorState: u }) => {
    if (s.has(g0) || s.has(_l) || e.isComposing()) return;
    const c = a.read(J),
      d = u.read(J);
    if (!H(d) || !H(c) || !c.isCollapsed() || c.is(d)) return;
    const f = c.anchor.key,
      h = c.anchor.offset,
      p = a._nodeMap.get(f);
    !Z(p) ||
      !l.has(f) ||
      (h !== 1 && h > d.anchor.offset + 1) ||
      e.update(() => {
        if (!aR(p)) return;
        const g = p.getParent();
        g === null || Kh(g) || o(g, p, c.anchor.offset);
      });
  });
}
const dR = /^(\s*)(\d{1,})\.\s/,
  fR = /^(\s*)[-*+]\s/,
  hR = /^(\s*)(?:-\s)?\s?(\[(\s|x)?\])\s/i,
  pR = /^(#{1,6})\s/,
  gR = /^>\s/,
  mR = /^[ \t]*```(\w+)?/,
  xR = /[ \t]*```$/,
  T5 = (e) => (t, n, r, i) => {
    const o = e(r);
    o.append(...n), t.replace(o), i || o.select(0, 0);
  },
  Jh = (e) => (t, n, r, i) => {
    const o = t.getPreviousSibling(),
      s = t.getNextSibling(),
      l = mt(e === "check" ? r[3] === "x" : void 0);
    if (ue(s) && s.getListType() === e) {
      const u = s.getFirstChild();
      u !== null ? u.insertBefore(l) : s.append(l), t.remove();
    } else if (ue(o) && o.getListType() === e) o.append(l), t.remove();
    else {
      const u = gt(e, e === "number" ? Number(r[2]) : void 0);
      u.append(l), t.replace(u);
    }
    l.append(...n), i || l.select(0, 0);
    const a = (function (u) {
      const c = u.match(/\t/g),
        d = u.match(/ /g);
      let f = 0;
      return c && (f += c.length), d && (f += Math.floor(d.length / 4)), f;
    })(r[1]);
    a && l.setIndent(a);
  },
  Qa = (e, t, n) => {
    const r = [],
      i = e.getChildren();
    let o = 0;
    for (const s of i)
      if (xe(s)) {
        if (s.getChildrenSize() === 1) {
          const c = s.getFirstChild();
          if (ue(c)) {
            r.push(Qa(c, t, n + 1));
            continue;
          }
        }
        const l = " ".repeat(4 * n),
          a = e.getListType(),
          u = a === "number" ? `${e.getStart() + o}. ` : a === "check" ? `- [${s.getChecked() ? "x" : " "}] ` : "- ";
        r.push(l + u + t(s)), o++;
      }
    return r.join(`
`);
  },
  vR = {
    dependencies: [ms],
    export: (e, t) => {
      if (!ba(e)) return null;
      const n = Number(e.getTag().slice(1));
      return "#".repeat(n) + " " + t(e);
    },
    regExp: pR,
    replace: T5((e) => {
      const t = "h" + e[1].length;
      return wn(t);
    }),
    type: "element",
  },
  A5 = {
    dependencies: [to],
    export: (e, t) => {
      if (!Tc(e)) return null;
      const n = t(e).split(`
`),
        r = [];
      for (const i of n) r.push("> " + i);
      return r.join(`
`);
    },
    regExp: gR,
    replace: (e, t, n, r) => {
      if (r) {
        const o = e.getPreviousSibling();
        if (Tc(o)) return o.splice(o.getChildrenSize(), 0, [sn(), ...t]), void e.remove();
      }
      const i = gs();
      i.append(...t), e.replace(i), r || i.select(0, 0);
    },
    type: "element",
  },
  I5 = {
    dependencies: [Is],
    export: (e) => {
      if (!Kh(e)) return null;
      const t = e.getTextContent();
      return (
        "```" +
        (e.getLanguage() || "") +
        (t
          ? `
` + t
          : "") +
        "\n```"
      );
    },
    regExpEnd: { optional: !0, regExp: xR },
    regExpStart: mR,
    replace: (e, t, n, r, i, o) => {
      let s, l;
      if (!t && i) {
        if (i.length === 1)
          r ? ((s = Jn()), (l = n[1] + i[0])) : ((s = Jn(n[1])), (l = i[0].startsWith(" ") ? i[0].slice(1) : i[0]));
        else {
          if (((s = Jn(n[1])), i[0].trim().length === 0)) for (; i.length > 0 && !i[0].length; ) i.shift();
          else i[0] = i[0].startsWith(" ") ? i[0].slice(1) : i[0];
          for (; i.length > 0 && !i[i.length - 1].length; ) i.pop();
          l = i.join(`
`);
        }
        const a = Be(l);
        s.append(a), e.append(s);
      } else t && T5((a) => Jn(a ? a[1] : void 0))(e, t, n, o);
    },
    type: "multiline-element",
  },
  N5 = {
    dependencies: [rr, nr],
    export: (e, t) => (ue(e) ? Qa(e, t, 0) : null),
    regExp: fR,
    replace: Jh("bullet"),
    type: "element",
  },
  bR = {
    dependencies: [rr, nr],
    export: (e, t) => (ue(e) ? Qa(e, t, 0) : null),
    regExp: hR,
    replace: Jh("check"),
    type: "element",
  },
  L5 = {
    dependencies: [rr, nr],
    export: (e, t) => (ue(e) ? Qa(e, t, 0) : null),
    regExp: dR,
    replace: Jh("number"),
    type: "element",
  },
  M5 = { format: ["code"], tag: "`", type: "text-format" },
  yR = { format: ["highlight"], tag: "==", type: "text-format" },
  O5 = { format: ["bold", "italic"], tag: "***", type: "text-format" },
  F5 = { format: ["bold", "italic"], intraword: !1, tag: "___", type: "text-format" },
  R5 = { format: ["bold"], tag: "**", type: "text-format" },
  P5 = { format: ["bold"], intraword: !1, tag: "__", type: "text-format" },
  CR = { format: ["strikethrough"], tag: "~~", type: "text-format" },
  D5 = { format: ["italic"], tag: "*", type: "text-format" },
  $5 = { format: ["italic"], intraword: !1, tag: "_", type: "text-format" },
  B5 = {
    dependencies: [or],
    export: (e, t, n) => {
      if (!zt(e) || _n(e)) return null;
      const r = e.getTitle(),
        i = t(e);
      return r ? `[${i}](${e.getURL()} "${r}")` : `[${i}](${e.getURL()})`;
    },
    importRegExp: /(?:\[([^[]+)\])(?:\((?:([^()\s]+)(?:\s"((?:[^"]*\\")*[^"]*)"\s*)?)\))/,
    regExp: /(?:\[([^[]+)\])(?:\((?:([^()\s]+)(?:\s"((?:[^"]*\\")*[^"]*)"\s*)?)\))$/,
    replace: (e, t) => {
      const [, n, r, i] = t,
        o = vr(r, { title: i }),
        s = Be(n);
      return s.setFormat(e.getFormat()), o.append(s), e.replace(o), s;
    },
    trigger: ")",
    type: "text-match",
  },
  _R = [vR, A5, N5, L5],
  wR = [I5],
  ER = [M5, O5, F5, R5, P5, yR, D5, $5, CR],
  kR = [B5],
  H5 = [..._R, ...wR, ...ER, ...kR],
  SR = [
    {
      dependencies: [bs],
      export: (e) => ($f(e) ? "***" : null),
      regExp: /^(---|\*\*\*|___)\s?$/,
      replace: (e, t, n, r) => {
        const i = io();
        r || e.getNextSibling() != null ? e.replace(i) : e.insertBefore(i), i.selectNext();
      },
      type: "element",
    },
    ...H5,
  ];
function y1({ transformers: e = SR }) {
  const [t] = bt();
  return E.useEffect(() => cR(t, e), [t, e]), null;
}
const TR = vt({
    init(e) {
      const t = e.getValue(Ff),
        n = t.includes("headings") ? e.getValue(Oa) : [],
        r = NR(t, n);
      e.pubIn({
        [ai]: () => C.createElement(y1, { transformers: r }),
        [Yx]: () => C.createElement(y1, { transformers: r }),
      });
    },
  }),
  AR = (e) => (t, n, r) => {
    const i = e(r);
    i.append(...n), t.replace(i), i.select(0, 0);
  },
  IR = {
    dependencies: [bs],
    export: (e) => ($f(e) ? "***" : null),
    regExp: /^(---|\*\*\*|___)\s?$/,
    replace: (e, t, n, r) => {
      const i = io();
      r || e.getNextSibling() != null ? e.replace(i) : e.insertBefore(i), i.selectNext();
    },
    type: "element",
  };
function NR(e, t) {
  const n = [O5, F5, R5, P5, M5, D5, $5];
  if (e.includes("headings")) {
    const r = Math.min(...t),
      i = Math.max(...t),
      o = new RegExp(`^(#{${r},${i}})\\s`),
      s = {
        dependencies: [ms],
        export: (l, a) => {
          if (!ba(l)) return null;
          const u = Number(l.getTag().slice(1));
          return "#".repeat(u) + " " + a(l);
        },
        regExp: o,
        replace: AR((l) => {
          const a = `h${l[1].length}`;
          return wn(a);
        }),
        type: "element",
      };
    n.push(s);
  }
  if (
    (e.includes("thematicBreak") && n.push(IR),
    e.includes("quote") && n.push(A5),
    e.includes("link") && n.push(B5),
    e.includes("lists") && n.push(L5, N5, bR),
    e.includes("codeblock"))
  ) {
    const r = {
      ...I5,
      dependencies: [lo],
      replace: (i, o, s) => {
        const l = Ss({ code: "", language: s[1] ?? "", meta: "" });
        i.replace(l),
          setTimeout(() => {
            l.select();
          }, 80);
      },
    };
    n.push(r);
  }
  return n;
}
const LR = () => {
    const e = Ie(Nl),
      t = qe(Xx),
      n = qe(Ff),
      r = n.includes("quote"),
      i = n.includes("headings"),
      o = Fe();
    if (!r && !i) return null;
    const s = [{ label: o("toolbar.blockTypes.paragraph", "Paragraph"), value: "paragraph" }];
    if ((r && s.push({ label: o("toolbar.blockTypes.quote", "Quote"), value: "quote" }), i)) {
      const l = qe(Oa);
      s.push(
        ...l.map((a) => ({
          label: o("toolbar.blockTypes.heading", "Heading {{level}}", { level: a }),
          value: `h${a}`,
        })),
      );
    }
    return C.createElement(Xa, {
      value: t,
      onChange: (l) => {
        switch (l) {
          case "quote":
            e(() => gs());
            break;
          case "paragraph":
            e(() => Se());
            break;
          case "":
            break;
          default:
            if (l.startsWith("h")) e(() => wn(l));
            else throw new Error(`Unknown block type: ${l}`);
        }
      },
      triggerTitle: o("toolbar.blockTypeSelect.selectBlockTypeTooltip", "Select block type"),
      placeholder: o("toolbar.blockTypeSelect.placeholder", "Block type"),
      items: s,
    });
  },
  Ii = ({ format: e, addTitle: t, removeTitle: n, icon: r, formatName: i }) => {
    const [o, s] = Le(If, Ke),
      l = Ie(Nf),
      a = (o & e) !== 0;
    return C.createElement(
      x5,
      {
        title: a ? n : t,
        on: a,
        onValueChange: () => {
          l(i);
        },
      },
      s(r),
    );
  },
  MR = ({ options: e }) => {
    const t = Fe(),
      n = typeof e > "u";
    return C.createElement(
      "div",
      { className: D.toolbarGroupOfGroups },
      n || e.includes("Bold")
        ? C.createElement(Ii, {
            format: No,
            addTitle: t("toolbar.bold", "Bold"),
            removeTitle: t("toolbar.removeBold", "Remove bold"),
            icon: "format_bold",
            formatName: "bold",
          })
        : null,
      n || e.includes("Italic")
        ? C.createElement(Ii, {
            format: Lo,
            addTitle: t("toolbar.italic", "Italic"),
            removeTitle: t("toolbar.removeItalic", "Remove italic"),
            icon: "format_italic",
            formatName: "italic",
          })
        : null,
      n || e.includes("Underline")
        ? C.createElement(Ii, {
            format: Oo,
            addTitle: t("toolbar.underline", "Underline"),
            removeTitle: t("toolbar.removeUnderline", "Remove underline"),
            icon: "format_underlined",
            formatName: "underline",
          })
        : null,
    );
  },
  OR = ({ options: e }) => {
    const t = Fe(),
      n = typeof e > "u";
    return C.createElement(
      "div",
      { className: D.toolbarGroupOfGroups },
      n || e.includes("Strikethrough")
        ? C.createElement(Ii, {
            format: Mo,
            addTitle: t("toolbar.strikethrough", "Strikethrough"),
            removeTitle: t("toolbar.removeStrikethrough", "Remove strikethrough"),
            icon: "strikeThrough",
            formatName: "strikethrough",
          })
        : null,
      n || e.includes("Sup")
        ? C.createElement(Ii, {
            format: Ro,
            addTitle: t("toolbar.superscript", "Superscript"),
            removeTitle: t("toolbar.removeSuperscript", "Remove superscript"),
            icon: "superscript",
            formatName: "superscript",
          })
        : null,
      n || e.includes("Sub")
        ? C.createElement(Ii, {
            format: Fo,
            addTitle: t("toolbar.subscript", "Subscript"),
            removeTitle: t("toolbar.removeSubscript", "Remove subscript"),
            icon: "subscript",
            formatName: "subscript",
          })
        : null,
    );
  };
function V5(e) {
  return {
    note: e("admonitions.note", "Note"),
    tip: e("admonitions.tip", "Tip"),
    danger: e("admonitions.danger", "Danger"),
    info: e("admonitions.info", "Info"),
    caution: e("admonitions.caution", "Caution"),
  };
}
const FR = () => {
    const [e, t] = Le(li, Ht),
      n = e.rootNode,
      r = Fe(),
      i = V5(r);
    return C.createElement(Xa, {
      value: n.getMdastNode().name,
      onChange: (o) => {
        t == null ||
          t.update(() => {
            n.setMdastNode({ ...n.getMdastNode(), name: o }),
              setTimeout(() => {
                t.update(() => {
                  n.getLatest().select();
                });
              }, 80);
          });
      },
      triggerTitle: r("admonitions.changeType", "Select admonition type"),
      placeholder: r("admonitions.placeholder", "Admonition type"),
      items: zh.map((o) => ({ label: i[o], value: o })),
    });
  },
  tc = "__EMPTY_VALUE__",
  RR = () => {
    const [e, t, n] = Le(li, je, Gl),
      r = e.rootNode,
      i = Fe();
    let o = r.getLanguage();
    return (
      o === "" && (o = tc),
      C.createElement(
        "div",
        { className: D.selectWithLabel },
        C.createElement("label", null, i("codeBlock.language", "Code block language")),
        C.createElement(Xa, {
          value: o,
          onChange: (s) => {
            t == null ||
              t.update(() => {
                r.setLanguage(s === tc ? "" : s),
                  setTimeout(() => {
                    t.update(() => {
                      r.getLatest().select();
                    });
                  });
              });
          },
          triggerTitle: i("codeBlock.selectLanguage", "Select code block language"),
          placeholder: i("codeBlock.language", "Code block language"),
          items: Object.entries(n).map(([s, l]) => ({ value: s || tc, label: l })),
        }),
      )
    );
  },
  PR = () => {
    const [e, t] = Le(If, Ke),
      n = Ie(Nf),
      r = Fe(),
      i = (e & Ea) !== 0,
      o = i ? r("toolbar.removeInlineCode", "Remove code format") : r("toolbar.inlineCode", "Inline code format");
    return C.createElement(v5, {
      items: [{ title: o, contents: t("code"), active: i, onChange: n.bind(null, "code") }],
    });
  },
  DR = () => {
    const e = Ie(jh),
      t = qe(Ke),
      n = Fe();
    return C.createElement(
      ci,
      {
        "aria-label": n("toolbar.link", "Create link"),
        title: n("toolbar.link", "Create link"),
        onClick: (r) => {
          e();
        },
      },
      t("link"),
    );
  },
  $R = ({ children: e, SourceToolbar: t, options: n = ["rich-text", "diff", "source"] }) => {
    const [r, i] = Le(mr, Ke),
      o = Ie(mr),
      s = Fe(),
      l = [];
    return (
      n.includes("rich-text") &&
        l.push({ title: s("toolbar.richText", "Rich text"), contents: i("rich_text"), value: "rich-text" }),
      n.includes("diff") &&
        l.push({ title: s("toolbar.diffMode", "Diff mode"), contents: i("difference"), value: "diff" }),
      n.includes("source") &&
        l.push({ title: s("toolbar.source", "Source mode"), contents: i("markdown"), value: "source" }),
      C.createElement(
        C.Fragment,
        null,
        r === "rich-text"
          ? e
          : r === "diff"
            ? C.createElement("span", { className: D.toolbarTitleMode }, s("toolbar.diffMode", "Diff mode"))
            : t ?? C.createElement("span", { className: D.toolbarTitleMode }, s("toolbar.source", "Source mode")),
        C.createElement(
          "div",
          { className: D.diffSourceToggleWrapper },
          C.createElement(b5, {
            className: D.diffSourceToggle,
            ggClassName: D.ggDiffSourceToggle,
            value: r,
            items: l,
            onChange: (a) => {
              o(a === "" ? "rich-text" : a);
            },
          }),
        ),
      )
    );
  },
  BR = () => {
    const e = Ie(s5),
      t = qe(Ke),
      n = Fe(),
      r = C.useMemo(() => {
        const i = V5(n);
        return zh.map((o) => ({ value: o, label: i[o] }));
      }, [n]);
    return C.createElement(
      ZF,
      {
        title: n("toolbar.admonition", "Insert Admonition"),
        onChoose: (i) => {
          e({ type: "containerDirective", name: i });
        },
        items: r,
      },
      t("admonition"),
    );
  },
  HR = () => {
    const e = Ie(Ka),
      t = qe(Ke),
      n = Fe();
    return C.createElement(
      ci,
      {
        title: n("toolbar.codeBlock", "Insert Code Block"),
        onClick: () => {
          e({});
        },
      },
      t("frame_source"),
    );
  },
  VR = () => {
    const e = Ie(o2),
      [t, n] = Le(l2, Ke),
      r = Fe();
    return C.createElement(
      ci,
      {
        title: t
          ? r("toolbar.editFrontmatter", "Edit frontmatter")
          : r("toolbar.insertFrontmatter", "Insert frontmatter"),
        className: we({ [D.activeToolbarButton]: t }),
        onClick: () => {
          e();
        },
      },
      n("frontmatter"),
    );
  },
  zR = C.forwardRef((e, t) => {
    const n = Ie(dy),
      [r, i] = Le(ct, Ke),
      o = Fe();
    return C.createElement(
      hr,
      {
        className: D.toolbarButton,
        ref: t,
        disabled: r,
        onClick: () => {
          n();
        },
      },
      C.createElement(uo, { title: o("toolbar.image", "Insert image") }, i("add_photo")),
    );
  }),
  z5 = ne(!1, (e) => {
    e.link(
      e.pipe(
        je,
        tn((t) => {
          var n, r;
          return ["td", "th"].includes(
            ((r = (n = t == null ? void 0 : t.getRootElement()) == null ? void 0 : n.parentNode) == null
              ? void 0
              : r.nodeName.toLowerCase()) ?? "",
          );
        }),
      ),
      z5,
    );
  }),
  jR = () => {
    const e = qe(Ke),
      t = Ie(Cb),
      n = Fe(),
      r = qe(z5);
    return C.createElement(
      ci,
      {
        title: n("toolbar.table", "Insert Table"),
        onClick: () => {
          t({ rows: 3, columns: 3 });
        },
        ...(r ? { "aria-disabled": !0, "data-disabled": !0, disabled: !0 } : {}),
      },
      e("table"),
    );
  },
  UR = () => {
    const e = Ie(uv),
      t = qe(Ke),
      n = Fe();
    return C.createElement(
      ci,
      {
        title: n("toolbar.thematicBreak", "Insert thematic break"),
        onClick: () => {
          e();
        },
      },
      t("horizontal_rule"),
    );
  },
  WR = { bullet: "format_list_bulleted", number: "format_list_numbered", check: "format_list_checked" },
  KR = ({ options: e = ["bullet", "number", "check"] }) => {
    const [t, n] = Le(Gc, Ke),
      r = Ie(bv),
      i = Fe(),
      o = {
        bullet: i("toolbar.bulletedList", "Bulleted list"),
        number: i("toolbar.numberedList", "Numbered list"),
        check: i("toolbar.checkList", "Check list"),
      },
      s = e.map((l) => ({ value: l, title: o[l], contents: n(WR[l]) }));
    return C.createElement(b5, { value: t || "", items: s, onChange: r });
  },
  JR = () => {
    const [e, t, n, r] = Le(li, je, Ke, d2),
      i = e.rootNode,
      o = Fe(),
      s = r.presets.find((l) => l.meta === i.getMeta());
    return C.createElement(
      "div",
      { className: D.selectWithLabel },
      C.createElement(
        ci,
        {
          title: o("toolbar.deleteSandpack", "Delete this code block"),
          onClick: () => {
            t == null ||
              t.update(() => {
                i.getNextSibling() ? i.selectNext() : i.selectPrevious(), i.remove();
              });
          },
        },
        n("delete_big"),
      ),
      C.createElement("label", null, "Sandpack preset: ", s.name),
    );
  },
  GR = () => {
    const [e, t] = Le(Ke, je),
      [n, r] = C.useState(!1),
      [i, o] = C.useState(!1),
      s = Fe();
    return (
      C.useEffect(() => {
        if (t)
          return yt(
            t.registerCommand(Co, (l) => (r(l), !1), Bt),
            t.registerCommand(yo, (l) => (o(l), !1), Bt),
          );
      }, [t]),
      C.createElement(v5, {
        items: [
          {
            title: s("toolbar.undo", "Undo {{shortcut}}", { shortcut: Ml ? "⌘Z" : "Ctrl+Z" }),
            disabled: !n,
            contents: e("undo"),
            active: !1,
            onChange: () => (t == null ? void 0 : t.dispatchCommand(ea, void 0)),
          },
          {
            title: s("toolbar.redo", "Redo {{shortcut}}", { shortcut: Ml ? "⌘Y" : "Ctrl+Y" }),
            disabled: !i,
            contents: e("redo"),
            active: !1,
            onChange: () => (t == null ? void 0 : t.dispatchCommand(ta, void 0)),
          },
        ],
      })
    );
  };
function C1(e) {
  const t = e == null ? void 0 : e.rootNode;
  return !t || t.getType() !== "directive"
    ? !1
    : ["note", "tip", "danger", "info", "caution"].includes(t.getMdastNode().name);
}
function ZR(e) {
  let t, n;
  document.createRange &&
    ((t = document.createRange()),
    t.selectNodeContents(e),
    t.collapse(!1),
    (n = window.getSelection()),
    n == null || n.removeAllRanges(),
    n == null || n.addRange(t));
}
const fP = (e) => {
  const { t } = G5(),
    [n, r] = E.useState(!1);
  return (
    E.useEffect(() => {
      NC.loadNamespaces(["markdown_editor"]).then(() => {
        r(!0);
      });
    }, []),
    O.jsxs(Yh, {
      sx: { display: "flex", flexDirection: "column", minHeight: e.displayOnly ? "100%" : "calc(100vh - 200px)" },
      onKeyDown: (i) => {
        var o;
        (i.ctrlKey || i.metaKey) && i.key === "s" && (i.preventDefault(), (o = e.onSaveShortcut) == null || o.call(e));
      },
      children: [
        n &&
          O.jsx(o6, {
            className: e.darkMode ? "dark-theme dark-editor" : void 0,
            translation: (i, o, s) => t("markdown_editor:" + i, s),
            readOnly: e.readOnly,
            onChange: e.onChange,
            plugins: [
              eR({ diffMarkdown: e.initialValue, viewMode: "rich-text" }),
              ...(e.displayOnly
                ? []
                : [
                    qF({
                      toolbarContents: () =>
                        O.jsx(qu, {
                          options: [
                            {
                              when: (i) => (i == null ? void 0 : i.editorType) === "codeblock",
                              contents: () => O.jsx(RR, {}),
                            },
                            {
                              when: (i) => (i == null ? void 0 : i.editorType) === "sandpack",
                              contents: () => O.jsx(JR, {}),
                            },
                            {
                              fallback: () =>
                                O.jsxs($R, {
                                  children: [
                                    O.jsx(GR, {}),
                                    O.jsx($n, {}),
                                    O.jsx(MR, {}),
                                    O.jsx(PR, {}),
                                    O.jsx($n, {}),
                                    O.jsx(OR, {}),
                                    O.jsx($n, {}),
                                    O.jsx(KR, {}),
                                    O.jsx($n, {}),
                                    O.jsx(qu, {
                                      options: [
                                        { when: C1, contents: () => O.jsx(FR, {}) },
                                        { fallback: () => O.jsx(LR, {}) },
                                      ],
                                    }),
                                    O.jsx($n, {}),
                                    O.jsx(DR, {}),
                                    O.jsx(zR, {}),
                                    O.jsx($n, {}),
                                    O.jsx(jR, {}),
                                    O.jsx(UR, {}),
                                    O.jsx($n, {}),
                                    O.jsx(HR, {}),
                                    O.jsx(qu, {
                                      options: [
                                        {
                                          when: (i) => !C1(i),
                                          contents: () =>
                                            O.jsxs(O.Fragment, { children: [O.jsx($n, {}), O.jsx(BR, {})] }),
                                        },
                                      ],
                                    }),
                                    O.jsx($n, {}),
                                    O.jsx(VR, {}),
                                  ],
                                }),
                            },
                          ],
                        }),
                    }),
                  ]),
              z6(),
              TM(),
              d6({ allowedHeadingLevels: [1, 2, 3] }),
              CA(),
              WF(),
              OI({
                imageUploadHandler: e.imageUploadHandler,
                imagePreviewHandler: e.imagePreviewHandler,
                imageAutocompleteSuggestions: e.imageAutocompleteSuggestions ?? void 0,
              }),
              rA(),
              x6(),
              EM(),
              HM({
                defaultCodeBlockLanguage: "",
                codeBlockEditorDescriptors: [{ priority: -10, match: (i) => !0, Editor: o5 }],
              }),
              XO({
                codeBlockLanguages: {
                  js: "JavaScript",
                  jsx: "JSX",
                  css: "CSS",
                  txt: "Plain Text",
                  tsx: "TSX",
                  ts: "TypeScript",
                  html: "HTML",
                  json: "JSON",
                  sh: "Shell",
                  bash: "Bash",
                  yaml: "YAML",
                  markdown: "Markdown",
                  dockerfile: "Dockerfile",
                  sql: "SQL",
                  python: "Python",
                  go: "Go",
                  java: "Java",
                  c: "C",
                  cpp: "C++",
                  php: "PHP",
                  ruby: "Ruby",
                  perl: "Perl",
                  swift: "Swift",
                  r: "R",
                  rust: "Rust",
                  kotlin: "Kotlin",
                  scala: "Scala",
                  "": "Unspecified",
                },
              }),
              HF({ directiveDescriptors: [VF] }),
              TR(),
            ],
            contentEditableClassName: e.darkMode ? "markdown-body-dark" : "markdown-body-light",
            markdown: e.value,
          }),
        !n && O.jsx("div", { className: "mdxeditor" }),
        O.jsx(Yh, {
          onClick: () => {
            ZR(document.querySelector(e.darkMode ? ".markdown-body-dark" : ".markdown-body-light"));
          },
          sx: { cursor: "text", flexGrow: 1 },
        }),
      ],
    })
  );
};
export { fP as default };
